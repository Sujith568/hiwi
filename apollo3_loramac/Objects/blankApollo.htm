<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html><head>
<title>Static Call Graph - [.\Objects\blankApollo.axf]</title></head>
<body><HR>
<H1>Static Call Graph for image .\Objects\blankApollo.axf</H1><HR>
<BR><P>#&#060CALLGRAPH&#062# ARM Linker, 6220000: Last Updated: Sat Feb 15 19:44:52 2025
<BR><P>
<H3>Maximum Stack Usage =       1440 bytes + Unknown(Cycles, Untraceable Function Pointers)</H3><H3>
Call chain for Maximum Stack Depth:</H3>
__rt_entry_main &rArr; main &rArr; periodicUplink &rArr; UplinkProcess &rArr; PrepareTxFrame &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
<P>
<H3>
Mutually Recursive functions
</H3> <LI><a href="#[28]">NMI_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[28]">NMI_Handler</a><BR>
 <LI><a href="#[2a]">MemManage_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[2a]">MemManage_Handler</a><BR>
 <LI><a href="#[2b]">BusFault_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[2b]">BusFault_Handler</a><BR>
 <LI><a href="#[2c]">UsageFault_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[2c]">UsageFault_Handler</a><BR>
 <LI><a href="#[2d]">SecureFault_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[2d]">SecureFault_Handler</a><BR>
 <LI><a href="#[2e]">SVC_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[2e]">SVC_Handler</a><BR>
 <LI><a href="#[2f]">DebugMon_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[2f]">DebugMon_Handler</a><BR>
 <LI><a href="#[30]">PendSV_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[30]">PendSV_Handler</a><BR>
 <LI><a href="#[31]">SysTick_Handler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[31]">SysTick_Handler</a><BR>
 <LI><a href="#[3e]">am_ble_isr</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[3e]">am_ble_isr</a><BR>
 <LI><a href="#[86]">RadioSetPublicNetwork</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[72]">RadioSetModem</a><BR>
</UL>
<P>
<H3>
Function Pointers
</H3><UL>
 <LI><a href="#[7]">BoardGetBatteryLevel</a> from board.o(.text.BoardGetBatteryLevel) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[8]">BoardGetRandomSeed</a> from board.o(.text.BoardGetRandomSeed) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[2b]">BusFault_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[2f]">DebugMon_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[29]">HardFault_Handler</a> from am_util_faultisr.o(.text.HardFault_Handler) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[5a]">LmHandlerDeviceTimeReq</a> from lmhandler.o(.text.LmHandlerDeviceTimeReq) referenced 2 times from lmhandler.o(.text.LmHandlerPackageRegister)
 <LI><a href="#[59]">LmHandlerJoinRequest</a> from lmhandler.o(.text.LmHandlerJoinRequest) referenced 2 times from lmhandler.o(.text.LmHandlerPackageRegister)
 <LI><a href="#[14]">LmhpClockSyncInit</a> from lmhpclocksync.o(.text.LmhpClockSyncInit) referenced 2 times from lmhpclocksync.o(.data.LmhpClockSyncPackage)
 <LI><a href="#[15]">LmhpClockSyncIsInitialized</a> from lmhpclocksync.o(.text.LmhpClockSyncIsInitialized) referenced 2 times from lmhpclocksync.o(.data.LmhpClockSyncPackage)
 <LI><a href="#[16]">LmhpClockSyncIsTxPending</a> from lmhpclocksync.o(.text.LmhpClockSyncIsTxPending) referenced 2 times from lmhpclocksync.o(.data.LmhpClockSyncPackage)
 <LI><a href="#[18]">LmhpClockSyncOnMcpsConfirm</a> from lmhpclocksync.o(.text.LmhpClockSyncOnMcpsConfirm) referenced 2 times from lmhpclocksync.o(.data.LmhpClockSyncPackage)
 <LI><a href="#[19]">LmhpClockSyncOnMcpsIndication</a> from lmhpclocksync.o(.text.LmhpClockSyncOnMcpsIndication) referenced 2 times from lmhpclocksync.o(.data.LmhpClockSyncPackage)
 <LI><a href="#[17]">LmhpClockSyncProcess</a> from lmhpclocksync.o(.text.LmhpClockSyncProcess) referenced 2 times from lmhpclocksync.o(.data.LmhpClockSyncPackage)
 <LI><a href="#[0]">LmhpComplianceInit</a> from lmhpcompliance.o(.text.LmhpComplianceInit) referenced 2 times from lmhpcompliance.o(.data.CompliancePackage)
 <LI><a href="#[1]">LmhpComplianceIsInitialized</a> from lmhpcompliance.o(.text.LmhpComplianceIsInitialized) referenced 2 times from lmhpcompliance.o(.data.CompliancePackage)
 <LI><a href="#[2]">LmhpComplianceIsTxPending</a> from lmhpcompliance.o(.text.LmhpComplianceIsTxPending) referenced 2 times from lmhpcompliance.o(.data.CompliancePackage)
 <LI><a href="#[4]">LmhpComplianceOnMcpsIndication</a> from lmhpcompliance.o(.text.LmhpComplianceOnMcpsIndication) referenced 2 times from lmhpcompliance.o(.data.CompliancePackage)
 <LI><a href="#[5]">LmhpComplianceOnMlmeConfirm</a> from lmhpcompliance.o(.text.LmhpComplianceOnMlmeConfirm) referenced 2 times from lmhpcompliance.o(.data.CompliancePackage)
 <LI><a href="#[6]">LmhpComplianceOnMlmeIndication</a> from lmhpcompliance.o(.text.LmhpComplianceOnMlmeIndication) referenced 2 times from lmhpcompliance.o(.data.CompliancePackage)
 <LI><a href="#[3]">LmhpComplianceProcess</a> from lmhpcompliance.o(.text.LmhpComplianceProcess) referenced 2 times from lmhpcompliance.o(.data.CompliancePackage)
 <LI><a href="#[1d]">LmhpFragmentationInit</a> from lmhpfragmentation.o(.text.LmhpFragmentationInit) referenced 2 times from lmhpfragmentation.o(.data.LmhpFragmentationPackage)
 <LI><a href="#[1e]">LmhpFragmentationIsInitialized</a> from lmhpfragmentation.o(.text.LmhpFragmentationIsInitialized) referenced 2 times from lmhpfragmentation.o(.data.LmhpFragmentationPackage)
 <LI><a href="#[1f]">LmhpFragmentationIsTxPending</a> from lmhpfragmentation.o(.text.LmhpFragmentationIsTxPending) referenced 2 times from lmhpfragmentation.o(.data.LmhpFragmentationPackage)
 <LI><a href="#[21]">LmhpFragmentationOnMcpsIndication</a> from lmhpfragmentation.o(.text.LmhpFragmentationOnMcpsIndication) referenced 2 times from lmhpfragmentation.o(.data.LmhpFragmentationPackage)
 <LI><a href="#[20]">LmhpFragmentationProcess</a> from lmhpfragmentation.o(.text.LmhpFragmentationProcess) referenced 2 times from lmhpfragmentation.o(.data.LmhpFragmentationPackage)
 <LI><a href="#[22]">LmhpRemoteMcastSetupInit</a> from lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupInit) referenced 2 times from lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
 <LI><a href="#[23]">LmhpRemoteMcastSetupIsInitialized</a> from lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupIsInitialized) referenced 2 times from lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
 <LI><a href="#[24]">LmhpRemoteMcastSetupIsTxPending</a> from lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupIsTxPending) referenced 2 times from lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
 <LI><a href="#[26]">LmhpRemoteMcastSetupOnMcpsIndication</a> from lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupOnMcpsIndication) referenced 2 times from lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
 <LI><a href="#[25]">LmhpRemoteMcastSetupProcess</a> from lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupProcess) referenced 2 times from lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
 <LI><a href="#[54]">McpsConfirm</a> from lmhandler.o(.text.McpsConfirm) referenced 2 times from lmhandler.o(.text.LmHandlerInit)
 <LI><a href="#[55]">McpsIndication</a> from lmhandler.o(.text.McpsIndication) referenced 2 times from lmhandler.o(.text.LmHandlerInit)
 <LI><a href="#[2a]">MemManage_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[56]">MlmeConfirm</a> from lmhandler.o(.text.MlmeConfirm) referenced 2 times from lmhandler.o(.text.LmHandlerInit)
 <LI><a href="#[57]">MlmeIndication</a> from lmhandler.o(.text.MlmeIndication) referenced 2 times from lmhandler.o(.text.LmHandlerInit)
 <LI><a href="#[28]">NMI_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[58]">NvmDataMgmtEvent</a> from nvmdatamgmt.o(.text.NvmDataMgmtEvent) referenced 2 times from lmhandler.o(.text.LmHandlerInit)
 <LI><a href="#[53]">OnAbpJoinPendingTimerEvent</a> from loramac.o(.text.OnAbpJoinPendingTimerEvent) referenced 2 times from loramac.o(.text.AbpJoinPendingStart)
 <LI><a href="#[12]">OnBeaconStatusChange</a> from periodicuplink.o(.text.OnBeaconStatusChange) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[11]">OnClassChange</a> from periodicuplink.o(.text.OnClassChange) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[64]">OnForceRejoinReqCycleTimerEvent</a> from loramac.o(.text.OnForceRejoinReqCycleTimerEvent) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[5b]">OnFragmentTxDelay</a> from lmhpfragmentation.o(.text.OnFragmentTxDelay) referenced 2 times from lmhpfragmentation.o(.text.LmhpFragmentationInit)
 <LI><a href="#[e]">OnJoinRequest</a> from periodicuplink.o(.text.OnJoinRequest) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[c]">OnMacMcpsRequest</a> from periodicuplink.o(.text.OnMacMcpsRequest) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[d]">OnMacMlmeRequest</a> from periodicuplink.o(.text.OnMacMlmeRequest) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[9]">OnMacProcessNotify</a> from periodicuplink.o(.text.OnMacProcessNotify) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[b]">OnNetworkParametersChange</a> from periodicuplink.o(.text.OnNetworkParametersChange) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[a]">OnNvmDataChange</a> from periodicuplink.o(.text.OnNvmDataChange) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[1c]">OnPingSlotPeriodicityChanged</a> from periodicuplink.o(.text.OnPingSlotPeriodicityChanged) referenced 2 times from periodicuplink.o(.data.LmhpComplianceParams)
 <LI><a href="#[66]">OnRadioRxDone</a> from loramac.o(.text.OnRadioRxDone) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[67]">OnRadioRxError</a> from loramac.o(.text.OnRadioRxError) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[69]">OnRadioRxTimeout</a> from loramac.o(.text.OnRadioRxTimeout) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[65]">OnRadioTxDone</a> from loramac.o(.text.OnRadioTxDone) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[68]">OnRadioTxTimeout</a> from loramac.o(.text.OnRadioTxTimeout) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[62]">OnRejoin0CycleTimerEvent</a> from loramac.o(.text.OnRejoin0CycleTimerEvent) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[63]">OnRejoin1CycleTimerEvent</a> from loramac.o(.text.OnRejoin1CycleTimerEvent) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[61]">OnRetransmitTimeoutTimerEvent</a> from loramac.o(.text.OnRetransmitTimeoutTimerEvent) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[10]">OnRxData</a> from periodicuplink.o(.text.OnRxData) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[5f]">OnRxWindow1TimerEvent</a> from loramac.o(.text.OnRxWindow1TimerEvent) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[60]">OnRxWindow2TimerEvent</a> from loramac.o(.text.OnRxWindow2TimerEvent) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[5c]">OnSessionStartTimer</a> from lmhpremotemcastsetup.o(.text.OnSessionStartTimer) referenced 2 times from lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupInit)
 <LI><a href="#[5d]">OnSessionStopTimer</a> from lmhpremotemcastsetup.o(.text.OnSessionStopTimer) referenced 2 times from lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupInit)
 <LI><a href="#[13]">OnSysTimeUpdate</a> from periodicuplink.o(.text.OnSysTimeUpdate) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[f]">OnTxData</a> from periodicuplink.o(.text.OnTxData) referenced 2 times from periodicuplink.o(.data.LmHandlerCallbacks)
 <LI><a href="#[5e]">OnTxDelayedTimerEvent</a> from loramac.o(.text.OnTxDelayedTimerEvent) referenced 2 times from loramac.o(.text.LoRaMacInitialization)
 <LI><a href="#[1b]">OnTxFrameCtrlChanged</a> from periodicuplink.o(.text.OnTxFrameCtrlChanged) referenced 2 times from periodicuplink.o(.data.LmhpComplianceParams)
 <LI><a href="#[1a]">OnTxPeriodicityChanged</a> from periodicuplink.o(.text.OnTxPeriodicityChanged) referenced 2 times from periodicuplink.o(.data.LmhpComplianceParams)
 <LI><a href="#[6d]">OnTxTimerEvent</a> from periodicuplink.o(.text.OnTxTimerEvent) referenced 2 times from periodicuplink.o(.text.StartTxProcess)
 <LI><a href="#[30]">PendSV_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[78]">RadioCheckRfFrequency</a> from radio.o(.text.RadioCheckRfFrequency) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[71]">RadioGetStatus</a> from radio.o(.text.RadioGetStatus) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[87]">RadioGetWakeupTime</a> from radio.o(.text.RadioGetWakeupTime) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[70]">RadioInit</a> from radio.o(.text.RadioInit) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[88]">RadioIrqProcess</a> from radio.o(.text.RadioIrqProcess) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[74]">RadioIsChannelFree</a> from radio.o(.text.RadioIsChannelFree) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[6a]">RadioOnDioIrq</a> from radio.o(.text.RadioOnDioIrq) referenced 2 times from radio.o(.text.RadioInit)
 <LI><a href="#[6c]">RadioOnRxTimeoutIrq</a> from radio.o(.text.RadioOnRxTimeoutIrq) referenced 2 times from radio.o(.text.RadioInit)
 <LI><a href="#[6b]">RadioOnTxTimeoutIrq</a> from radio.o(.text.RadioOnTxTimeoutIrq) referenced 2 times from radio.o(.text.RadioInit)
 <LI><a href="#[75]">RadioRandom</a> from radio.o(.text.RadioRandom) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[82]">RadioRead</a> from radio.o(.text.RadioRead) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[84]">RadioReadBuffer</a> from radio.o(.text.RadioReadBuffer) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[80]">RadioRssi</a> from radio.o(.text.RadioRssi) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[7d]">RadioRx</a> from radio.o(.text.RadioRx) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[89]">RadioRxBoosted</a> from radio.o(.text.RadioRxBoosted) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[7a]">RadioSend</a> from radio.o(.text.RadioSend) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[73]">RadioSetChannel</a> from radio.o(.text.RadioSetChannel) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[85]">RadioSetMaxPayloadLength</a> from radio.o(.text.RadioSetMaxPayloadLength) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[72]">RadioSetModem</a> from radio.o(.text.RadioSetModem) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[86]">RadioSetPublicNetwork</a> from radio.o(.text.RadioSetPublicNetwork) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[76]">RadioSetRxConfig</a> from radio.o(.text.RadioSetRxConfig) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[8a]">RadioSetRxDutyCycle</a> from radio.o(.text.RadioSetRxDutyCycle) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[77]">RadioSetTxConfig</a> from radio.o(.text.RadioSetTxConfig) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[7f]">RadioSetTxContinuousWave</a> from radio.o(.text.RadioSetTxContinuousWave) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[7b]">RadioSleep</a> from radio.o(.text.RadioSleep) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[7c]">RadioStandby</a> from radio.o(.text.RadioStandby) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[7e]">RadioStartCad</a> from radio.o(.text.RadioStartCad) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[79]">RadioTimeOnAir</a> from radio.o(.text.RadioTimeOnAir) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[81]">RadioWrite</a> from radio.o(.text.RadioWrite) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[83]">RadioWriteBuffer</a> from radio.o(.text.RadioWriteBuffer) referenced from radio.o(.rodata.Radio)
 <LI><a href="#[27]">Reset_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[2e]">SVC_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[2d]">SecureFault_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[31]">SysTick_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[2c]">UsageFault_Handler</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[52]">__main</a> from __main.o(!!!main) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[44]">am_adc_isr</a> from adc.o(.text.am_adc_isr) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[3e]">am_ble_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[32]">am_brownout_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[51]">am_clkgen_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[40]">am_ctimer_isr</a> from timing.o(.text.am_ctimer_isr) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[3f]">am_gpio_isr</a> from gpio.o(.text.am_gpio_isr) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[6e]">am_hal_itm_print</a> from am_hal_itm.o(.text.am_hal_itm_print) referenced 2 times from gpio.o(.text.enable_printf)
 <LI><a href="#[38]">am_iomaster0_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[39]">am_iomaster1_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[3a]">am_iomaster2_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[3b]">am_iomaster3_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[3c]">am_iomaster4_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[3d]">am_iomaster5_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[37]">am_ioslave_acc_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[36]">am_ioslave_ios_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[46]">am_mspi0_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[45]">am_pdm0_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[34]">am_rtc_isr</a> from rtc-board.o(.text.am_rtc_isr) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[43]">am_scard_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[47]">am_software0_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[49]">am_stimer_cmpr0_isr</a> from timing.o(.text.am_stimer_cmpr0_isr) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[4a]">am_stimer_cmpr1_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[4b]">am_stimer_cmpr2_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[4c]">am_stimer_cmpr3_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[4d]">am_stimer_cmpr4_isr</a> from timing.o(.text.am_stimer_cmpr4_isr) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[4e]">am_stimer_cmpr5_isr</a> from timing.o(.text.am_stimer_cmpr5_isr) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[4f]">am_stimer_cmpr6_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[50]">am_stimer_cmpr7_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[48]">am_stimer_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[42]">am_uart1_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[41]">am_uart_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[35]">am_vcomp_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[33]">am_watchdog_isr</a> from startup_apollo3.o(RESET) referenced from startup_apollo3.o(RESET)
 <LI><a href="#[6f]">as7341IRQ</a> from as7341.o(.text.as7341IRQ) referenced 2 times from taskhandler.o(.text.initSpecMeasurement)
</UL>
<P>
<H3>
Global Symbols
</H3>
<P><STRONG><a name="[27]"></a>Reset_Handler</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[28]"></a>NMI_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NMI_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NMI_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[2a]"></a>MemManage_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[2a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MemManage_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[2a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MemManage_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[2b]"></a>BusFault_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[2b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BusFault_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[2b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BusFault_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[2c]"></a>UsageFault_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UsageFault_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UsageFault_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[2d]"></a>SecureFault_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[2d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFault_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[2d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFault_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[2e]"></a>SVC_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[2e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SVC_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[2e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SVC_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[2f]"></a>DebugMon_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[2f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DebugMon_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[2f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DebugMon_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[30]"></a>PendSV_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PendSV_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PendSV_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[31]"></a>SysTick_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[31]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTick_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[31]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTick_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[3e]"></a>am_ble_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[3e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_ble_isr
</UL>
<BR>[Called By]<UL><LI><a href="#[3e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_ble_isr
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[32]"></a>am_brownout_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[51]"></a>am_clkgen_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[38]"></a>am_iomaster0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[39]"></a>am_iomaster1_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[3a]"></a>am_iomaster2_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[3b]"></a>am_iomaster3_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[3c]"></a>am_iomaster4_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[3d]"></a>am_iomaster5_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[37]"></a>am_ioslave_acc_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[36]"></a>am_ioslave_ios_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[46]"></a>am_mspi0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[45]"></a>am_pdm0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[43]"></a>am_scard_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[47]"></a>am_software0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[4a]"></a>am_stimer_cmpr1_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[4b]"></a>am_stimer_cmpr2_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[4c]"></a>am_stimer_cmpr3_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[4f]"></a>am_stimer_cmpr6_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[50]"></a>am_stimer_cmpr7_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[48]"></a>am_stimer_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[8b]"></a>am_uart0_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET), UNUSED, KEPT)

<P><STRONG><a name="[42]"></a>am_uart1_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[41]"></a>am_uart_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[35]"></a>am_vcomp_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[33]"></a>am_watchdog_isr</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_apollo3.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[52]"></a>__main</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, __main.o(!!!main))
<BR><BR>[Calls]<UL><LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
<LI><a href="#[8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[8c]"></a>__scatterload</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter))
<BR><BR>[Called By]<UL><LI><a href="#[52]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[8e]"></a>__scatterload_rt2</STRONG> (Thumb, 84 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[8d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[340]"></a>__scatterload_rt2_thumb_only</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)

<P><STRONG><a name="[341]"></a>__scatterload_loop</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)

<P><STRONG><a name="[342]"></a>__decompress</STRONG> (Thumb, 90 bytes, Stack size unknown bytes, __dczerorl2.o(!!dczerorl2), UNUSED)

<P><STRONG><a name="[343]"></a>__decompress1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __dczerorl2.o(!!dczerorl2), UNUSED)

<P><STRONG><a name="[344]"></a>__scatterload_null</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, __scatter.o(!!handler_null), UNUSED)

<P><STRONG><a name="[345]"></a>__scatterload_zeroinit</STRONG> (Thumb, 28 bytes, Stack size unknown bytes, __scatter_zi.o(!!handler_zi), UNUSED)

<P><STRONG><a name="[94]"></a>__rt_lib_init</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit.o(.ARM.Collect$$libinit$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[93]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry_li
</UL>

<P><STRONG><a name="[8f]"></a>__rt_lib_init_fp_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000001))
<BR><BR>[Calls]<UL><LI><a href="#[90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_init
</UL>

<P><STRONG><a name="[346]"></a>__rt_lib_init_alloca_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000030))

<P><STRONG><a name="[347]"></a>__rt_lib_init_argv_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000002E))

<P><STRONG><a name="[348]"></a>__rt_lib_init_atexit_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000001D))

<P><STRONG><a name="[349]"></a>__rt_lib_init_clock_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000023))

<P><STRONG><a name="[34a]"></a>__rt_lib_init_cpp_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000034))

<P><STRONG><a name="[34b]"></a>__rt_lib_init_exceptions_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000032))

<P><STRONG><a name="[34c]"></a>__rt_lib_init_fp_trap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000021))

<P><STRONG><a name="[34d]"></a>__rt_lib_init_getenv_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000025))

<P><STRONG><a name="[34e]"></a>__rt_lib_init_heap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000000C))

<P><STRONG><a name="[34f]"></a>__rt_lib_init_lc_collate_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000013))

<P><STRONG><a name="[350]"></a>__rt_lib_init_lc_ctype_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000015))

<P><STRONG><a name="[351]"></a>__rt_lib_init_lc_monetary_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000017))

<P><STRONG><a name="[352]"></a>__rt_lib_init_lc_numeric_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000019))

<P><STRONG><a name="[353]"></a>__rt_lib_init_lc_time_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000001B))

<P><STRONG><a name="[354]"></a>__rt_lib_init_preinit_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000006))

<P><STRONG><a name="[355]"></a>__rt_lib_init_rand_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000010))

<P><STRONG><a name="[356]"></a>__rt_lib_init_relocate_pie_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000004))

<P><STRONG><a name="[357]"></a>__rt_lib_init_return</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000035))

<P><STRONG><a name="[358]"></a>__rt_lib_init_signal_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000001F))

<P><STRONG><a name="[359]"></a>__rt_lib_init_stdio_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$00000027))

<P><STRONG><a name="[35a]"></a>__rt_lib_init_user_alloc_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libinit2.o(.ARM.Collect$$libinit$$0000000E))

<P><STRONG><a name="[99]"></a>__rt_lib_shutdown</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown.o(.ARM.Collect$$libshutdown$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit_ls
</UL>

<P><STRONG><a name="[35b]"></a>__rt_lib_shutdown_cpp_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$00000002))

<P><STRONG><a name="[35c]"></a>__rt_lib_shutdown_fp_trap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$00000007))

<P><STRONG><a name="[35d]"></a>__rt_lib_shutdown_heap_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$0000000F))

<P><STRONG><a name="[35e]"></a>__rt_lib_shutdown_return</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$00000010))

<P><STRONG><a name="[35f]"></a>__rt_lib_shutdown_signal_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$0000000A))

<P><STRONG><a name="[360]"></a>__rt_lib_shutdown_stdio_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$00000004))

<P><STRONG><a name="[361]"></a>__rt_lib_shutdown_user_alloc_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, libshutdown2.o(.ARM.Collect$$libshutdown$$0000000C))

<P><STRONG><a name="[8d]"></a>__rt_entry</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry.o(.ARM.Collect$$rtentry$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[52]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main
<LI><a href="#[8e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload_rt2
</UL>

<P><STRONG><a name="[362]"></a>__rt_entry_presh_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$00000002))

<P><STRONG><a name="[91]"></a>__rt_entry_sh</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry4.o(.ARM.Collect$$rtentry$$00000004))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = __rt_entry_sh &rArr; __user_setup_stackheap
</UL>
<BR>[Calls]<UL><LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[93]"></a>__rt_entry_li</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$0000000A))
<BR><BR>[Calls]<UL><LI><a href="#[94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>

<P><STRONG><a name="[363]"></a>__rt_entry_postsh_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$00000009))

<P><STRONG><a name="[95]"></a>__rt_entry_main</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$0000000D))
<BR><BR>[Stack]<UL><LI>Max Depth = 1440 + Unknown Stack Size
<LI>Call Chain = __rt_entry_main &rArr; main &rArr; periodicUplink &rArr; UplinkProcess &rArr; PrepareTxFrame &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[96]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[97]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit
</UL>

<P><STRONG><a name="[364]"></a>__rt_entry_postli_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, __rtentry2.o(.ARM.Collect$$rtentry$$0000000C))

<P><STRONG><a name="[a5]"></a>__rt_exit</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rtexit.o(.ARM.Collect$$rtexit$$00000000))
<BR><BR>[Called By]<UL><LI><a href="#[97]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit
</UL>

<P><STRONG><a name="[98]"></a>__rt_exit_ls</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rtexit2.o(.ARM.Collect$$rtexit$$00000003))
<BR><BR>[Calls]<UL><LI><a href="#[99]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown
</UL>

<P><STRONG><a name="[365]"></a>__rt_exit_prels_1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rtexit2.o(.ARM.Collect$$rtexit$$00000002))

<P><STRONG><a name="[9a]"></a>__rt_exit_exit</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rtexit2.o(.ARM.Collect$$rtexit$$00000004))
<BR><BR>[Calls]<UL><LI><a href="#[9b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_exit
</UL>

<P><STRONG><a name="[a4]"></a>__user_initial_stackheap</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, startup_apollo3.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[285]"></a>__aeabi_memcpy4</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_memcpy4
</UL>
<BR>[Called By]<UL><LI><a href="#[197]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementInit
</UL>

<P><STRONG><a name="[366]"></a>__aeabi_memcpy8</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[367]"></a>__rt_memcpy_w</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[368]"></a>_memcpy_lastbytes_aligned</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[168]"></a>__aeabi_memclr</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementProcessJoinAccept
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
</UL>

<P><STRONG><a name="[369]"></a>__rt_memclr</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memclr.o(.text), UNUSED)

<P><STRONG><a name="[9c]"></a>_memset</STRONG> (Thumb, 64 bytes, Stack size 0 bytes, rt_memclr.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[9d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset_w
</UL>

<P><STRONG><a name="[a2]"></a>__aeabi_memclr4</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memclr_w.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868InitDefaults
<LI><a href="#[9f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_localtime_r
</UL>

<P><STRONG><a name="[36a]"></a>__aeabi_memclr8</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[36b]"></a>__rt_memclr_w</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[9d]"></a>_memset_w</STRONG> (Thumb, 74 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset
</UL>

<P><STRONG><a name="[9e]"></a>localtime</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, localtime.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = localtime &rArr; _localtime_r
</UL>
<BR>[Calls]<UL><LI><a href="#[9f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_localtime_r
</UL>
<BR>[Called By]<UL><LI><a href="#[140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSet
</UL>

<P><STRONG><a name="[a0]"></a>mktime</STRONG> (Thumb, 352 bytes, Stack size 56 bytes, mktime.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = mktime &rArr; _tm_carry
</UL>
<BR>[Calls]<UL><LI><a href="#[a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_tm_carry
</UL>
<BR>[Called By]<UL><LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGet
</UL>

<P><STRONG><a name="[36c]"></a>__use_two_region_memory</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, heapauxi.o(.text), UNUSED)

<P><STRONG><a name="[36d]"></a>__rt_heap_escrow$2region</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, heapauxi.o(.text), UNUSED)

<P><STRONG><a name="[36e]"></a>__rt_heap_expand$2region</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, heapauxi.o(.text), UNUSED)

<P><STRONG><a name="[9f]"></a>_localtime_r</STRONG> (Thumb, 178 bytes, Stack size 16 bytes, localtime_internal.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _localtime_r
</UL>
<BR>[Calls]<UL><LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[9e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;localtime
</UL>

<P><STRONG><a name="[36f]"></a>_n$localtime_r</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, localtime_internal.o(.text), UNUSED)

<P><STRONG><a name="[370]"></a>__user_libspace</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[a3]"></a>__user_perproc_libspace</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, libspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[92]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[371]"></a>__user_perthread_libspace</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[92]"></a>__user_setup_stackheap</STRONG> (Thumb, 74 bytes, Stack size 8 bytes, sys_stackheap_outer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __user_setup_stackheap
</UL>
<BR>[Calls]<UL><LI><a href="#[a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_initial_stackheap
<LI><a href="#[a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perproc_libspace
</UL>
<BR>[Called By]<UL><LI><a href="#[91]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry_sh
</UL>

<P><STRONG><a name="[97]"></a>exit</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, exit.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = exit
</UL>
<BR>[Calls]<UL><LI><a href="#[a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit
</UL>
<BR>[Called By]<UL><LI><a href="#[95]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry_main
</UL>

<P><STRONG><a name="[9b]"></a>_sys_exit</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, sys_exit.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[9a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit_exit
</UL>

<P><STRONG><a name="[372]"></a>__I$use$semihosting</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, use_no_semi.o(.text), UNUSED)

<P><STRONG><a name="[373]"></a>__use_no_semihosting_swi</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, use_no_semi.o(.text), UNUSED)

<P><STRONG><a name="[374]"></a>__semihosting_library_function</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, indicate_semi.o(.text), UNUSED)

<P><STRONG><a name="[a6]"></a>AES_CMAC_Final</STRONG> (Thumb, 562 bytes, Stack size 88 bytes, cmac.o(.text.AES_CMAC_Final))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
<LI><a href="#[a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_encrypt
</UL>
<BR>[Called By]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmac
</UL>

<P><STRONG><a name="[aa]"></a>AES_CMAC_Init</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, cmac.o(.text.AES_CMAC_Init))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = AES_CMAC_Init &rArr; memset1
</UL>
<BR>[Calls]<UL><LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmac
</UL>

<P><STRONG><a name="[ab]"></a>AES_CMAC_SetKey</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, cmac.o(.text.AES_CMAC_SetKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = AES_CMAC_SetKey &rArr; aes_set_key &rArr; copy_block_nn
</UL>
<BR>[Calls]<UL><LI><a href="#[ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_set_key
</UL>
<BR>[Called By]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmac
</UL>

<P><STRONG><a name="[ad]"></a>AES_CMAC_Update</STRONG> (Thumb, 372 bytes, Stack size 72 bytes, cmac.o(.text.AES_CMAC_Update))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = AES_CMAC_Update &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
<LI><a href="#[a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_encrypt
</UL>
<BR>[Called By]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmac
</UL>

<P><STRONG><a name="[c6]"></a>BoardCriticalSectionBegin</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, board.o(.text.BoardCriticalSectionBegin))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = BoardCriticalSectionBegin
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
<LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UplinkProcess
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleIrqEvents
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWakeup
<LI><a href="#[c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardResetMcu
<LI><a href="#[25]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupProcess
<LI><a href="#[20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationProcess
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
</UL>

<P><STRONG><a name="[148]"></a>BoardCriticalSectionEnd</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, board.o(.text.BoardCriticalSectionEnd))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = BoardCriticalSectionEnd
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
<LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UplinkProcess
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleIrqEvents
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWakeup
<LI><a href="#[25]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupProcess
<LI><a href="#[20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationProcess
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
</UL>

<P><STRONG><a name="[7]"></a>BoardGetBatteryLevel</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, board.o(.text.BoardGetBatteryLevel))
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[8]"></a>BoardGetRandomSeed</STRONG> (Thumb, 46 bytes, Stack size 12 bytes, board.o(.text.BoardGetRandomSeed))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = BoardGetRandomSeed
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[b6]"></a>BoardInitMcu</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, board.o(.text.BoardInitMcu))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = BoardInitMcu &rArr; am_hal_pwrctrl_low_power_init &rArr; am_hal_cachectrl_control &rArr; set_RDWAIT &rArr; am_hal_flash_store_ui32
</UL>
<BR>[Calls]<UL><LI><a href="#[b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_osc_disable
<LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_control
<LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[bb]"></a>BoardInitPeriph</STRONG> (Thumb, 64 bytes, Stack size 8 bytes, board.o(.text.BoardInitPeriph))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = BoardInitPeriph &rArr; am_devices_am1805_config_init &rArr; am_devices_am1805_read_register &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enable_printf
<LI><a href="#[bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnLoRa
<LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_init
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_I2C_init
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
<LI><a href="#[c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_config_init
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[c3]"></a>BoardLowPowerHandler</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, board.o(.text.BoardLowPowerHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = BoardLowPowerHandler &rArr; am_hal_sysctrl_sleep &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_sleep
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[c5]"></a>BoardResetMcu</STRONG> (Thumb, 14 bytes, Stack size 16 bytes, board.o(.text.BoardResetMcu))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = BoardResetMcu &rArr; BoardCriticalSectionBegin
</UL>
<BR>[Calls]<UL><LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_SystemReset
</UL>
<BR>[Called By]<UL><LI><a href="#[3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceProcess
</UL>

<P><STRONG><a name="[188]"></a>Crc32</STRONG> (Thumb, 156 bytes, Stack size 24 bytes, utilities.o(.text.Crc32))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = Crc32
</UL>
<BR>[Called By]<UL><LI><a href="#[1ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RestoreNvmData
<LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleNvm
</UL>

<P><STRONG><a name="[1c3]"></a>Crc32Finalize</STRONG> (Thumb, 12 bytes, Stack size 4 bytes, utilities.o(.text.Crc32Finalize))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Crc32Finalize
</UL>
<BR>[Called By]<UL><LI><a href="#[1be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmCrc32Check
</UL>

<P><STRONG><a name="[1c1]"></a>Crc32Init</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, utilities.o(.text.Crc32Init))
<BR><BR>[Called By]<UL><LI><a href="#[1be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmCrc32Check
</UL>

<P><STRONG><a name="[1c2]"></a>Crc32Update</STRONG> (Thumb, 154 bytes, Stack size 28 bytes, utilities.o(.text.Crc32Update))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = Crc32Update
</UL>
<BR>[Called By]<UL><LI><a href="#[1be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmCrc32Check
</UL>

<P><STRONG><a name="[dc]"></a>DelayMs</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, delay.o(.text.DelayMs))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = DelayMs &rArr; am_util_delay_ms &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
</UL>
<BR>[Called By]<UL><LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
<LI><a href="#[26d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReset
<LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuReadBuffer
<LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuWriteBuffer
<LI><a href="#[7b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSleep
<LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIsChannelFree
</UL>

<P><STRONG><a name="[1ef]"></a>DetermineFrameType</STRONG> (Thumb, 166 bytes, Stack size 12 bytes, loramac.o(.text.DetermineFrameType))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = DetermineFrameType
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[e3]"></a>DisplayAppInfo</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, lmhandlermsgdisplay.o(.text.DisplayAppInfo))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = DisplayAppInfo &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[e5]"></a>DisplayBeaconUpdate</STRONG> (Thumb, 220 bytes, Stack size 24 bytes, lmhandlermsgdisplay.o(.text.DisplayBeaconUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 400<LI>Call Chain = DisplayBeaconUpdate &rArr; PrintHexBuffer &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrintHexBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[12]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnBeaconStatusChange
</UL>

<P><STRONG><a name="[e7]"></a>DisplayClassUpdate</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, lmhandlermsgdisplay.o(.text.DisplayClassUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = DisplayClassUpdate &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[11]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnClassChange
</UL>

<P><STRONG><a name="[e8]"></a>DisplayJoinRequestUpdate</STRONG> (Thumb, 164 bytes, Stack size 16 bytes, lmhandlermsgdisplay.o(.text.DisplayJoinRequestUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = DisplayJoinRequestUpdate &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnJoinRequest
</UL>

<P><STRONG><a name="[e9]"></a>DisplayMacMcpsRequestUpdate</STRONG> (Thumb, 250 bytes, Stack size 24 bytes, lmhandlermsgdisplay.o(.text.DisplayMacMcpsRequestUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = DisplayMacMcpsRequestUpdate &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacMcpsRequest
</UL>

<P><STRONG><a name="[ea]"></a>DisplayMacMlmeRequestUpdate</STRONG> (Thumb, 290 bytes, Stack size 24 bytes, lmhandlermsgdisplay.o(.text.DisplayMacMlmeRequestUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = DisplayMacMlmeRequestUpdate &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacMlmeRequest
</UL>

<P><STRONG><a name="[eb]"></a>DisplayNetworkParametersUpdate</STRONG> (Thumb, 226 bytes, Stack size 24 bytes, lmhandlermsgdisplay.o(.text.DisplayNetworkParametersUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = DisplayNetworkParametersUpdate &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnNetworkParametersChange
</UL>

<P><STRONG><a name="[ec]"></a>DisplayNvmDataChange</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, lmhandlermsgdisplay.o(.text.DisplayNvmDataChange))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = DisplayNvmDataChange &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnNvmDataChange
</UL>

<P><STRONG><a name="[ed]"></a>DisplayRxUpdate</STRONG> (Thumb, 314 bytes, Stack size 48 bytes, lmhandlermsgdisplay.o(.text.DisplayRxUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 424<LI>Call Chain = DisplayRxUpdate &rArr; PrintHexBuffer &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrintHexBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRxData
</UL>

<P><STRONG><a name="[ee]"></a>DisplayTxUpdate</STRONG> (Thumb, 562 bytes, Stack size 64 bytes, lmhandlermsgdisplay.o(.text.DisplayTxUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 440<LI>Call Chain = DisplayTxUpdate &rArr; PrintHexBuffer &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerGetActiveRegion
<LI><a href="#[ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerGetCurrentClass
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrintHexBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxData
</UL>

<P><STRONG><a name="[f2]"></a>EepromMcuReadBuffer</STRONG> (Thumb, 128 bytes, Stack size 24 bytes, eeprom-board.o(.text.EepromMcuReadBuffer))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = EepromMcuReadBuffer &rArr; am_devices_mb85rc64ta_blocking_read &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOffFram
<LI><a href="#[f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnFram
<LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_mb85rc64ta_blocking_read
<LI><a href="#[dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
</UL>
<BR>[Called By]<UL><LI><a href="#[1bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmRead
</UL>

<P><STRONG><a name="[f6]"></a>EepromMcuWriteBuffer</STRONG> (Thumb, 128 bytes, Stack size 24 bytes, eeprom-board.o(.text.EepromMcuWriteBuffer))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = EepromMcuWriteBuffer &rArr; am_devices_mb85rc64ta_blocking_write &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOffFram
<LI><a href="#[f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnFram
<LI><a href="#[f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_mb85rc64ta_blocking_write
<LI><a href="#[dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
</UL>
<BR>[Called By]<UL><LI><a href="#[1bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmReset
<LI><a href="#[1c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmWrite
</UL>

<P><STRONG><a name="[145]"></a>FragDecoderGetMaxFileSize</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, fragdecoder.o(.text.FragDecoderGetMaxFileSize))
<BR><BR>[Called By]<UL><LI><a href="#[21]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationOnMcpsIndication
</UL>

<P><STRONG><a name="[144]"></a>FragDecoderGetStatus</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, fragdecoder.o(.text.FragDecoderGetStatus))
<BR><BR>[Called By]<UL><LI><a href="#[21]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationOnMcpsIndication
</UL>

<P><STRONG><a name="[146]"></a>FragDecoderInit</STRONG> (Thumb, 296 bytes, Stack size 40 bytes, fragdecoder.o(.text.FragDecoderInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = FragDecoderInit
</UL>
<BR>[Called By]<UL><LI><a href="#[21]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationOnMcpsIndication
</UL>

<P><STRONG><a name="[fa]"></a>FragDecoderProcess</STRONG> (Thumb, 1086 bytes, Stack size 168 bytes, fragdecoder.o(.text.FragDecoderProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 220<LI>Call Chain = FragDecoderProcess &rArr; XorParityLine &rArr; SetParity
</UL>
<BR>[Calls]<UL><LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
<LI><a href="#[104]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragPushLineToBinaryMatrix
<LI><a href="#[b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BitArrayIsAllZeros
<LI><a href="#[103]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragFindMissingIndex
<LI><a href="#[102]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XorParityLine
<LI><a href="#[101]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragExtractLineFromBinaryMatrix
<LI><a href="#[b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BitArrayFindFirstOne
<LI><a href="#[100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XorDataLine
<LI><a href="#[ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetRow
<LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetParity
<LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetParity
<LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragGetParityMatrixRow
<LI><a href="#[fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragFindMissingFrags
<LI><a href="#[fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRow
</UL>
<BR>[Called By]<UL><LI><a href="#[21]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationOnMcpsIndication
</UL>

<P><STRONG><a name="[29]"></a>HardFault_Handler</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, am_util_faultisr.o(.text.HardFault_Handler))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = HardFault_Handler &rArr; am_util_faultisr_collect_data &rArr; am_hal_mcuctrl_info_get &rArr; mcuctrl_fault_status
</UL>
<BR>[Calls]<UL><LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_faultisr_collect_data
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[1d8]"></a>JalapenosLppAddBusVoltage</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, jalapenoslpp.o(.text.JalapenosLppAddBusVoltage))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = JalapenosLppAddBusVoltage
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[1da]"></a>JalapenosLppAddCapVoltage</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, jalapenoslpp.o(.text.JalapenosLppAddCapVoltage))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = JalapenosLppAddCapVoltage
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[1d9]"></a>JalapenosLppAddCurrent</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, jalapenoslpp.o(.text.JalapenosLppAddCurrent))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = JalapenosLppAddCurrent
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[1d4]"></a>JalapenosLppAddPAR</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, jalapenoslpp.o(.text.JalapenosLppAddPAR))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = JalapenosLppAddPAR
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[1d6]"></a>JalapenosLppAddRelativeHumidity</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, jalapenoslpp.o(.text.JalapenosLppAddRelativeHumidity))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = JalapenosLppAddRelativeHumidity
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[1d7]"></a>JalapenosLppAddShuntVoltage</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, jalapenoslpp.o(.text.JalapenosLppAddShuntVoltage))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = JalapenosLppAddShuntVoltage
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[1d5]"></a>JalapenosLppAddTemperature</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, jalapenoslpp.o(.text.JalapenosLppAddTemperature))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = JalapenosLppAddTemperature
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[1db]"></a>JalapenosLppAddTimestamp</STRONG> (Thumb, 152 bytes, Stack size 12 bytes, jalapenoslpp.o(.text.JalapenosLppAddTimestamp))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = JalapenosLppAddTimestamp
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[11c]"></a>JalapenosLppCopy</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, jalapenoslpp.o(.text.JalapenosLppCopy))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = JalapenosLppCopy &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[1dc]"></a>JalapenosLppGetSize</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, jalapenoslpp.o(.text.JalapenosLppGetSize))
<BR><BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[1d3]"></a>JalapenosLppReset</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, jalapenoslpp.o(.text.JalapenosLppReset))
<BR><BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[5a]"></a>LmHandlerDeviceTimeReq</STRONG> (Thumb, 104 bytes, Stack size 32 bytes, lmhandler.o(.text.LmHandlerDeviceTimeReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 984 + Unknown Stack Size
<LI>Call Chain = LmHandlerDeviceTimeReq &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
<LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerRequestClass
<LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeIndication
<LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeConfirm
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhandler.o(.text.LmHandlerPackageRegister)
</UL>
<P><STRONG><a name="[f1]"></a>LmHandlerGetActiveRegion</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, lmhandler.o(.text.LmHandlerGetActiveRegion))
<BR><BR>[Called By]<UL><LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayTxUpdate
</UL>

<P><STRONG><a name="[ef]"></a>LmHandlerGetCurrentClass</STRONG> (Thumb, 24 bytes, Stack size 48 bytes, lmhandler.o(.text.LmHandlerGetCurrentClass))
<BR><BR>[Stack]<UL><LI>Max Depth = 220<LI>Call Chain = LmHandlerGetCurrentClass &rArr; LoRaMacMibGetRequestConfirm &rArr; RegionGetPhyParam &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
</UL>
<BR>[Called By]<UL><LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayTxUpdate
</UL>

<P><STRONG><a name="[121]"></a>LmHandlerGetCurrentDatarate</STRONG> (Thumb, 24 bytes, Stack size 48 bytes, lmhandler.o(.text.LmHandlerGetCurrentDatarate))
<BR><BR>[Stack]<UL><LI>Max Depth = 220<LI>Call Chain = LmHandlerGetCurrentDatarate &rArr; LoRaMacMibGetRequestConfirm &rArr; RegionGetPhyParam &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
</UL>
<BR>[Called By]<UL><LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeConfirm
</UL>

<P><STRONG><a name="[143]"></a>LmHandlerGetDutyCycleWaitTime</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, lmhandler.o(.text.LmHandlerGetDutyCycleWaitTime))
<BR><BR>[Called By]<UL><LI><a href="#[3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceProcess
</UL>

<P><STRONG><a name="[122]"></a>LmHandlerInit</STRONG> (Thumb, 610 bytes, Stack size 96 bytes, lmhandler.o(.text.LmHandlerInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 708 + Unknown Stack Size
<LI>Call Chain = LmHandlerInit &rArr; LoRaMacInitialization &rArr; SecureElementInit &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[126]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacTestSetDutyCycleOn
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[127]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacStart
<LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
<LI><a href="#[124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtRestore
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[128]"></a>LmHandlerIsBusy</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, lmhandler.o(.text.LmHandlerIsBusy))
<BR><BR>[Stack]<UL><LI>Max Depth = 1016 + Unknown Stack Size
<LI>Call Chain = LmHandlerIsBusy &rArr; LmHandlerJoin &rArr; LmHandlerJoinRequest &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[12b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerJoin
<LI><a href="#[129]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacIsBusy
<LI><a href="#[12a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerJoinStatus
<LI><a href="#[12c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackageIsTxPending
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncAppTimeReq
</UL>

<P><STRONG><a name="[12b]"></a>LmHandlerJoin</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, lmhandler.o(.text.LmHandlerJoin))
<BR><BR>[Stack]<UL><LI>Max Depth = 1000 + Unknown Stack Size
<LI>Call Chain = LmHandlerJoin &rArr; LmHandlerJoinRequest &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerJoinRequest
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
<LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnJoinRequest
<LI><a href="#[128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerIsBusy
</UL>

<P><STRONG><a name="[12a]"></a>LmHandlerJoinStatus</STRONG> (Thumb, 68 bytes, Stack size 56 bytes, lmhandler.o(.text.LmHandlerJoinStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 228<LI>Call Chain = LmHandlerJoinStatus &rArr; LoRaMacMibGetRequestConfirm &rArr; RegionGetPhyParam &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
</UL>
<BR>[Called By]<UL><LI><a href="#[128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerIsBusy
</UL>

<P><STRONG><a name="[133]"></a>LmHandlerPackageIsInitialized</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, lmhandler.o(.text.LmHandlerPackageIsInitialized))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = LmHandlerPackageIsInitialized
</UL>
<BR>[Called By]<UL><LI><a href="#[132]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackagesProcess
</UL>

<P><STRONG><a name="[12d]"></a>LmHandlerPackageRegister</STRONG> (Thumb, 232 bytes, Stack size 24 bytes, lmhandler.o(.text.LmHandlerPackageRegister))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = LmHandlerPackageRegister
</UL>
<BR>[Calls]<UL><LI><a href="#[131]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationPackageFactory
<LI><a href="#[130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupPackageFactory
<LI><a href="#[12f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmphClockSyncPackageFactory
<LI><a href="#[12e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmphCompliancePackageFactory
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[134]"></a>LmHandlerPingSlotReq</STRONG> (Thumb, 164 bytes, Stack size 40 bytes, lmhandler.o(.text.LmHandlerPingSlotReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = LmHandlerPingSlotReq &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>
<BR>[Called By]<UL><LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeConfirm
</UL>

<P><STRONG><a name="[136]"></a>LmHandlerProcess</STRONG> (Thumb, 178 bytes, Stack size 24 bytes, lmhandler.o(.text.LmHandlerProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 1256 + Unknown Stack Size
<LI>Call Chain = LmHandlerProcess &rArr; LoRaMacProcess &rArr; LoRaMacHandleIrqEvents &rArr; ProcessRadioRxDone &rArr; LoRaMacCryptoUnsecureMessage &rArr; VerifyCmacB0 &rArr; SecureElementVerifyAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
<LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
<LI><a href="#[132]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackagesProcess
<LI><a href="#[12c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackageIsTxPending
<LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtStore
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[139]"></a>LmHandlerRequestClass</STRONG> (Thumb, 218 bytes, Stack size 64 bytes, lmhandler.o(.text.LmHandlerRequestClass))
<BR><BR>[Stack]<UL><LI>Max Depth = 1048 + Unknown Stack Size
<LI>Call Chain = LmHandlerRequestClass &rArr; LmHandlerDeviceTimeReq &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[5a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerDeviceTimeReq
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[13a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnClassChangeNotify
</UL>
<BR>[Called By]<UL><LI><a href="#[e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnJoinRequest
<LI><a href="#[25]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupProcess
<LI><a href="#[3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceProcess
</UL>

<P><STRONG><a name="[135]"></a>LmHandlerSend</STRONG> (Thumb, 244 bytes, Stack size 48 bytes, lmhandler.o(.text.LmHandlerSend))
<BR><BR>[Stack]<UL><LI>Max Depth = 1032 + Unknown Stack Size
<LI>Call Chain = LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcpsRequest
<LI><a href="#[13b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacQueryTxPossible
</UL>
<BR>[Called By]<UL><LI><a href="#[11]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnClassChange
<LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncAppTimeReq
<LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerProcess
<LI><a href="#[26]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupOnMcpsIndication
<LI><a href="#[21]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationOnMcpsIndication
<LI><a href="#[20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationProcess
<LI><a href="#[3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceProcess
<LI><a href="#[19]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncOnMcpsIndication
<LI><a href="#[134]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPingSlotReq
</UL>

<P><STRONG><a name="[13d]"></a>LmHandlerSetSystemMaxRxError</STRONG> (Thumb, 50 bytes, Stack size 56 bytes, lmhandler.o(.text.LmHandlerSetSystemMaxRxError))
<BR><BR>[Stack]<UL><LI>Max Depth = 632<LI>Call Chain = LmHandlerSetSystemMaxRxError &rArr; LoRaMacMibSetRequestConfirm &rArr; LoRaMacCryptoSetKey &rArr; LoRaMacCryptoDeriveMcKEKey &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[13e]"></a>LmhpClockSyncAppTimeReq</STRONG> (Thumb, 368 bytes, Stack size 88 bytes, lmhpclocksync.o(.text.LmhpClockSyncAppTimeReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 1120 + Unknown Stack Size
<LI>Call Chain = LmhpClockSyncAppTimeReq &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGet
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
<LI><a href="#[128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerIsBusy
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
</UL>
<BR>[Called By]<UL><LI><a href="#[17]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncProcess
</UL>

<P><STRONG><a name="[131]"></a>LmhpFragmentationPackageFactory</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, lmhpfragmentation.o(.text.LmhpFragmentationPackageFactory))
<BR><BR>[Called By]<UL><LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackageRegister
</UL>

<P><STRONG><a name="[130]"></a>LmhpRemoteMcastSetupPackageFactory</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupPackageFactory))
<BR><BR>[Called By]<UL><LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackageRegister
</UL>

<P><STRONG><a name="[12f]"></a>LmphClockSyncPackageFactory</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, lmhpclocksync.o(.text.LmphClockSyncPackageFactory))
<BR><BR>[Called By]<UL><LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackageRegister
</UL>

<P><STRONG><a name="[12e]"></a>LmphCompliancePackageFactory</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, lmhpcompliance.o(.text.LmphCompliancePackageFactory))
<BR><BR>[Called By]<UL><LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackageRegister
</UL>

<P><STRONG><a name="[14c]"></a>LoRaMacAdrCalcNext</STRONG> (Thumb, 388 bytes, Stack size 72 bytes, loramacadr.o(.text.LoRaMacAdrCalcNext))
<BR><BR>[Stack]<UL><LI>Max Depth = 308 + Unknown Stack Size
<LI>Call Chain = LoRaMacAdrCalcNext &rArr; RegionInitDefaults &rArr; RegionEU868InitDefaults &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[14d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionInitDefaults
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetPhyParam
</UL>
<BR>[Called By]<UL><LI><a href="#[13b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacQueryTxPossible
<LI><a href="#[19e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Send
</UL>

<P><STRONG><a name="[1eb]"></a>LoRaMacClassBBeaconFreqReq</STRONG> (Thumb, 10 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBBeaconFreqReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBBeaconFreqReq
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[113]"></a>LoRaMacClassBBeaconTimerEvent</STRONG> (Thumb, 8 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBBeaconTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBBeaconTimerEvent
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
<LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
</UL>

<P><STRONG><a name="[1ea]"></a>LoRaMacClassBBeaconTimingAns</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, loramacclassb.o(.text.LoRaMacClassBBeaconTimingAns))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LoRaMacClassBBeaconTimingAns
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[1e7]"></a>LoRaMacClassBDeviceTimeAns</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBDeviceTimeAns))
<BR><BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[28b]"></a>LoRaMacClassBHaltBeaconing</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBHaltBeaconing))
<BR><BR>[Called By]<UL><LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendFrameOnChannel
</UL>

<P><STRONG><a name="[247]"></a>LoRaMacClassBInit</STRONG> (Thumb, 12 bytes, Stack size 12 bytes, loramacclassb.o(.text.LoRaMacClassBInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = LoRaMacClassBInit
</UL>
<BR>[Called By]<UL><LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ResetMacParameters
</UL>

<P><STRONG><a name="[1b3]"></a>LoRaMacClassBIsAcquisitionInProgress</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBIsAcquisitionInProgress))
<BR><BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>

<P><STRONG><a name="[cb]"></a>LoRaMacClassBIsBeaconExpected</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBIsBeaconExpected))
<BR><BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckForClassBCollision
</UL>

<P><STRONG><a name="[288]"></a>LoRaMacClassBIsBeaconModeActive</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBIsBeaconModeActive))
<BR><BR>[Called By]<UL><LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendFrameOnChannel
</UL>

<P><STRONG><a name="[cd]"></a>LoRaMacClassBIsMulticastExpected</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBIsMulticastExpected))
<BR><BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckForClassBCollision
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[cc]"></a>LoRaMacClassBIsPingExpected</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBIsPingExpected))
<BR><BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckForClassBCollision
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[289]"></a>LoRaMacClassBIsUplinkCollision</STRONG> (Thumb, 10 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBIsUplinkCollision))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBIsUplinkCollision
</UL>
<BR>[Called By]<UL><LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendFrameOnChannel
</UL>

<P><STRONG><a name="[1a4]"></a>LoRaMacClassBMibGetRequestConfirm</STRONG> (Thumb, 10 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBMibGetRequestConfirm))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBMibGetRequestConfirm
</UL>
<BR>[Called By]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
</UL>

<P><STRONG><a name="[117]"></a>LoRaMacClassBMulticastSlotTimerEvent</STRONG> (Thumb, 8 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBMulticastSlotTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBMulticastSlotTimerEvent
</UL>
<BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[1e9]"></a>LoRaMacClassBPingSlotChannelReq</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, loramacclassb.o(.text.LoRaMacClassBPingSlotChannelReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LoRaMacClassBPingSlotChannelReq
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[1e8]"></a>LoRaMacClassBPingSlotInfoAns</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBPingSlotInfoAns))
<BR><BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[115]"></a>LoRaMacClassBPingSlotTimerEvent</STRONG> (Thumb, 8 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBPingSlotTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBPingSlotTimerEvent
</UL>
<BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[1b4]"></a>LoRaMacClassBProcess</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBProcess))
<BR><BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[18f]"></a>LoRaMacClassBResumeBeaconing</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBResumeBeaconing))
<BR><BR>[Called By]<UL><LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleRequestEvents
</UL>

<P><STRONG><a name="[1ec]"></a>LoRaMacClassBRxBeacon</STRONG> (Thumb, 14 bytes, Stack size 8 bytes, loramacclassb.o(.text.LoRaMacClassBRxBeacon))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LoRaMacClassBRxBeacon
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[112]"></a>LoRaMacClassBSetBeaconState</STRONG> (Thumb, 10 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBSetBeaconState))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBSetBeaconState
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
<LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
</UL>

<P><STRONG><a name="[1ee]"></a>LoRaMacClassBSetFPendingBit</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, loramacclassb.o(.text.LoRaMacClassBSetFPendingBit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LoRaMacClassBSetFPendingBit
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[19c]"></a>LoRaMacClassBSetMulticastPeriodicity</STRONG> (Thumb, 8 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBSetMulticastPeriodicity))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBSetMulticastPeriodicity
</UL>
<BR>[Called By]<UL><LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcChannelSetupRxParams
</UL>

<P><STRONG><a name="[116]"></a>LoRaMacClassBSetMulticastSlotState</STRONG> (Thumb, 10 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBSetMulticastSlotState))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBSetMulticastSlotState
</UL>
<BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[1b2]"></a>LoRaMacClassBSetPingSlotInfo</STRONG> (Thumb, 10 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBSetPingSlotInfo))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBSetPingSlotInfo
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>

<P><STRONG><a name="[114]"></a>LoRaMacClassBSetPingSlotState</STRONG> (Thumb, 10 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBSetPingSlotState))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBSetPingSlotState
</UL>
<BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[28a]"></a>LoRaMacClassBStopRxSlots</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, loramacclassb.o(.text.LoRaMacClassBStopRxSlots))
<BR><BR>[Called By]<UL><LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendFrameOnChannel
</UL>

<P><STRONG><a name="[296]"></a>LoRaMacClassBSwitchClass</STRONG> (Thumb, 12 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacClassBSwitchClass))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacClassBSwitchClass
</UL>
<BR>[Called By]<UL><LI><a href="#[1a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SwitchClass
</UL>

<P><STRONG><a name="[150]"></a>LoRaMacCommandsAddCmd</STRONG> (Thumb, 162 bytes, Stack size 24 bytes, loramaccommands.o(.text.LoRaMacCommandsAddCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = LoRaMacCommandsAddCmd &rArr; MallocNewMacCommandSlot &rArr; IsSlotFree
</UL>
<BR>[Calls]<UL><LI><a href="#[154]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsConfirmationRequired
<LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsSticky
<LI><a href="#[152]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LinkedListAdd
<LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MallocNewMacCommandSlot
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[1a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SwitchClass
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[1df]"></a>LoRaMacCommandsGetCmd</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, loramaccommands.o(.text.LoRaMacCommandsGetCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = LoRaMacCommandsGetCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[185]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StopRetransmission
</UL>

<P><STRONG><a name="[1de]"></a>LoRaMacCommandsGetCmdSize</STRONG> (Thumb, 236 bytes, Stack size 8 bytes, loramaccommands.o(.text.LoRaMacCommandsGetCmdSize))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LoRaMacCommandsGetCmdSize
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[15b]"></a>LoRaMacCommandsGetSizeSerializedCmds</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, loramaccommands.o(.text.LoRaMacCommandsGetSizeSerializedCmds))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LoRaMacCommandsGetSizeSerializedCmds
</UL>
<BR>[Called By]<UL><LI><a href="#[13b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacQueryTxPossible
<LI><a href="#[15a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsSerializeCmds
<LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareFrame
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyTxFrame
</UL>

<P><STRONG><a name="[155]"></a>LoRaMacCommandsInit</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, loramaccommands.o(.text.LoRaMacCommandsInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = LoRaMacCommandsInit &rArr; LinkedListInit
</UL>
<BR>[Calls]<UL><LI><a href="#[156]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LinkedListInit
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
</UL>

<P><STRONG><a name="[157]"></a>LoRaMacCommandsRemoveCmd</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, loramaccommands.o(.text.LoRaMacCommandsRemoveCmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = LoRaMacCommandsRemoveCmd &rArr; LinkedListRemove &rArr; LinkedListGetPrevious
</UL>
<BR>[Calls]<UL><LI><a href="#[107]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FreeMacCommandSlot
<LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LinkedListRemove
</UL>
<BR>[Called By]<UL><LI><a href="#[159]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveStickyAnsCmds
<LI><a href="#[15a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsSerializeCmds
<LI><a href="#[158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveNoneStickyCmds
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[158]"></a>LoRaMacCommandsRemoveNoneStickyCmds</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, loramaccommands.o(.text.LoRaMacCommandsRemoveNoneStickyCmds))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = LoRaMacCommandsRemoveNoneStickyCmds &rArr; LoRaMacCommandsRemoveCmd &rArr; LinkedListRemove &rArr; LinkedListGetPrevious
</UL>
<BR>[Calls]<UL><LI><a href="#[157]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[19e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Send
</UL>

<P><STRONG><a name="[159]"></a>LoRaMacCommandsRemoveStickyAnsCmds</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, loramaccommands.o(.text.LoRaMacCommandsRemoveStickyAnsCmds))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = LoRaMacCommandsRemoveStickyAnsCmds &rArr; LoRaMacCommandsRemoveCmd &rArr; LinkedListRemove &rArr; LinkedListGetPrevious
</UL>
<BR>[Calls]<UL><LI><a href="#[154]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsConfirmationRequired
<LI><a href="#[153]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsSticky
<LI><a href="#[157]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveCmd
</UL>
<BR>[Called By]<UL><LI><a href="#[1f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RemoveMacCommands
</UL>

<P><STRONG><a name="[15a]"></a>LoRaMacCommandsSerializeCmds</STRONG> (Thumb, 186 bytes, Stack size 40 bytes, loramaccommands.o(.text.LoRaMacCommandsSerializeCmds))
<BR><BR>[Stack]<UL><LI>Max Depth = 100<LI>Call Chain = LoRaMacCommandsSerializeCmds &rArr; LoRaMacCommandsRemoveCmd &rArr; LinkedListRemove &rArr; LinkedListGetPrevious
</UL>
<BR>[Calls]<UL><LI><a href="#[157]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveCmd
<LI><a href="#[15b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsGetSizeSerializedCmds
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareFrame
</UL>

<P><STRONG><a name="[15c]"></a>LoRaMacConfirmQueueAdd</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, loramacconfirmqueue.o(.text.LoRaMacConfirmQueueAdd))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = LoRaMacConfirmQueueAdd &rArr; IncreaseBufferPointer
</UL>
<BR>[Calls]<UL><LI><a href="#[10a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IncreaseBufferPointer
<LI><a href="#[15d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsListFull
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
<LI><a href="#[15e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueHandleCb
</UL>

<P><STRONG><a name="[18e]"></a>LoRaMacConfirmQueueGetCnt</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, loramacconfirmqueue.o(.text.LoRaMacConfirmQueueGetCnt))
<BR><BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
<LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleRequestEvents
</UL>

<P><STRONG><a name="[15e]"></a>LoRaMacConfirmQueueHandleCb</STRONG> (Thumb, 206 bytes, Stack size 24 bytes, loramacconfirmqueue.o(.text.LoRaMacConfirmQueueHandleCb))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = LoRaMacConfirmQueueHandleCb &rArr; LoRaMacConfirmQueueAdd &rArr; IncreaseBufferPointer
</UL>
<BR>[Calls]<UL><LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueRemoveFirst
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueAdd
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleRequestEvents
</UL>

<P><STRONG><a name="[160]"></a>LoRaMacConfirmQueueInit</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, loramacconfirmqueue.o(.text.LoRaMacConfirmQueueInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = LoRaMacConfirmQueueInit &rArr; memset1
</UL>
<BR>[Calls]<UL><LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
</UL>

<P><STRONG><a name="[14f]"></a>LoRaMacConfirmQueueIsCmdActive</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, loramacconfirmqueue.o(.text.LoRaMacConfirmQueueIsCmdActive))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = LoRaMacConfirmQueueIsCmdActive &rArr; GetElement &rArr; IsListEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetElement
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
<LI><a href="#[186]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleMlmeRequest
<LI><a href="#[14e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCheckForBeaconAcquisition
</UL>

<P><STRONG><a name="[161]"></a>LoRaMacConfirmQueueIsFull</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, loramacconfirmqueue.o(.text.LoRaMacConfirmQueueIsFull))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = LoRaMacConfirmQueueIsFull &rArr; IsListFull
</UL>
<BR>[Calls]<UL><LI><a href="#[15d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsListFull
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>

<P><STRONG><a name="[15f]"></a>LoRaMacConfirmQueueRemoveFirst</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, loramacconfirmqueue.o(.text.LoRaMacConfirmQueueRemoveFirst))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = LoRaMacConfirmQueueRemoveFirst &rArr; IsListEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsListEmpty
<LI><a href="#[10a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IncreaseBufferPointer
</UL>
<BR>[Called By]<UL><LI><a href="#[15e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueHandleCb
</UL>

<P><STRONG><a name="[162]"></a>LoRaMacConfirmQueueSetStatus</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, loramacconfirmqueue.o(.text.LoRaMacConfirmQueueSetStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = LoRaMacConfirmQueueSetStatus &rArr; GetElement &rArr; IsListEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetElement
<LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsListEmpty
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[118]"></a>LoRaMacConfirmQueueSetStatusCmn</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, loramacconfirmqueue.o(.text.LoRaMacConfirmQueueSetStatusCmn))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = LoRaMacConfirmQueueSetStatusCmn &rArr; IsListEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsListEmpty
<LI><a href="#[10a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IncreaseBufferPointer
</UL>
<BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxDelayedTimerEvent
<LI><a href="#[181]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxTimeout
</UL>

<P><STRONG><a name="[163]"></a>LoRaMacCryptoDeriveMcKEKey</STRONG> (Thumb, 76 bytes, Stack size 32 bytes, loramaccrypto.o(.text.LoRaMacCryptoDeriveMcKEKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 496<LI>Call Chain = LoRaMacCryptoDeriveMcKEKey &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementDeriveAndStoreKey
</UL>
<BR>[Called By]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
<LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSetKey
</UL>

<P><STRONG><a name="[164]"></a>LoRaMacCryptoDeriveMcRootKey</STRONG> (Thumb, 96 bytes, Stack size 32 bytes, loramaccrypto.o(.text.LoRaMacCryptoDeriveMcRootKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 496<LI>Call Chain = LoRaMacCryptoDeriveMcRootKey &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementDeriveAndStoreKey
</UL>
<BR>[Called By]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
<LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSetKey
</UL>

<P><STRONG><a name="[165]"></a>LoRaMacCryptoDeriveMcSessionKeyPair</STRONG> (Thumb, 218 bytes, Stack size 64 bytes, loramaccrypto.o(.text.LoRaMacCryptoDeriveMcSessionKeyPair))
<BR><BR>[Stack]<UL><LI>Max Depth = 528<LI>Call Chain = LoRaMacCryptoDeriveMcSessionKeyPair &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementDeriveAndStoreKey
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetKeyAddrItem
</UL>
<BR>[Called By]<UL><LI><a href="#[149]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcChannelSetup
</UL>

<P><STRONG><a name="[10c]"></a>LoRaMacCryptoGetFCntDown</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, loramaccrypto.o(.text.LoRaMacCryptoGetFCntDown))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = LoRaMacCryptoGetFCntDown &rArr; GetLastFcntDown
</UL>
<BR>[Calls]<UL><LI><a href="#[c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetLastFcntDown
</UL>
<BR>[Called By]<UL><LI><a href="#[10b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetFCntDown
</UL>

<P><STRONG><a name="[1cf]"></a>LoRaMacCryptoGetFCntUp</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, loramaccrypto.o(.text.LoRaMacCryptoGetFCntUp))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LoRaMacCryptoGetFCntUp
</UL>
<BR>[Called By]<UL><LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareFrame
<LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFrame
</UL>

<P><STRONG><a name="[28c]"></a>LoRaMacCryptoGetRJcount</STRONG> (Thumb, 106 bytes, Stack size 12 bytes, loramaccrypto.o(.text.LoRaMacCryptoGetRJcount))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = LoRaMacCryptoGetRJcount
</UL>
<BR>[Called By]<UL><LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendReJoinReq
</UL>

<P><STRONG><a name="[167]"></a>LoRaMacCryptoHandleJoinAccept</STRONG> (Thumb, 786 bytes, Stack size 88 bytes, loramaccrypto.o(.text.LoRaMacCryptoHandleJoinAccept))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = LoRaMacCryptoHandleJoinAccept &rArr; SecureElementProcessJoinAccept &rArr; SecureElementVerifyAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[16a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacParserJoinAccept
<LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementProcessJoinAccept
<LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoDeriveMcKEKey
<LI><a href="#[164]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoDeriveMcRootKey
<LI><a href="#[e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeriveSessionKey10x
<LI><a href="#[e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeriveSessionKey11x
<LI><a href="#[16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsJoinNonce10xOk
<LI><a href="#[16b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsJoinNonce11xOk
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[16d]"></a>LoRaMacCryptoInit</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, loramaccrypto.o(.text.LoRaMacCryptoInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = LoRaMacCryptoInit &rArr; memset1
</UL>
<BR>[Calls]<UL><LI><a href="#[16e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ResetFCnts
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
</UL>

<P><STRONG><a name="[16f]"></a>LoRaMacCryptoPrepareJoinRequest</STRONG> (Thumb, 184 bytes, Stack size 24 bytes, loramaccrypto.o(.text.LoRaMacCryptoPrepareJoinRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 576<LI>Call Chain = LoRaMacCryptoPrepareJoinRequest &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementComputeAesCmac
<LI><a href="#[de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeriveLifeTimeSessionKey
<LI><a href="#[170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerJoinRequest
</UL>
<BR>[Called By]<UL><LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFrame
</UL>

<P><STRONG><a name="[171]"></a>LoRaMacCryptoPrepareReJoinType0or2</STRONG> (Thumb, 146 bytes, Stack size 24 bytes, loramaccrypto.o(.text.LoRaMacCryptoPrepareReJoinType0or2))
<BR><BR>[Stack]<UL><LI>Max Depth = 576<LI>Call Chain = LoRaMacCryptoPrepareReJoinType0or2 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementComputeAesCmac
<LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerReJoinType0or2
</UL>
<BR>[Called By]<UL><LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFrame
</UL>

<P><STRONG><a name="[173]"></a>LoRaMacCryptoPrepareReJoinType1</STRONG> (Thumb, 150 bytes, Stack size 24 bytes, loramaccrypto.o(.text.LoRaMacCryptoPrepareReJoinType1))
<BR><BR>[Stack]<UL><LI>Max Depth = 576<LI>Call Chain = LoRaMacCryptoPrepareReJoinType1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementComputeAesCmac
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerReJoinType1
</UL>
<BR>[Called By]<UL><LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFrame
</UL>

<P><STRONG><a name="[175]"></a>LoRaMacCryptoSecureMessage</STRONG> (Thumb, 576 bytes, Stack size 64 bytes, loramaccrypto.o(.text.LoRaMacCryptoSecureMessage))
<BR><BR>[Stack]<UL><LI>Max Depth = 688<LI>Call Chain = LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmacB0
<LI><a href="#[d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmacB1
<LI><a href="#[f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FOptsEncrypt
<LI><a href="#[176]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PayloadEncrypt
<LI><a href="#[177]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerData
</UL>
<BR>[Called By]<UL><LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFrame
</UL>

<P><STRONG><a name="[178]"></a>LoRaMacCryptoSetKey</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, loramaccrypto.o(.text.LoRaMacCryptoSetKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 512<LI>Call Chain = LoRaMacCryptoSetKey &rArr; LoRaMacCryptoDeriveMcKEKey &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoDeriveMcKEKey
<LI><a href="#[164]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoDeriveMcRootKey
<LI><a href="#[179]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[149]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcChannelSetup
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>

<P><STRONG><a name="[1ac]"></a>LoRaMacCryptoSetLrWanVersion</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, loramaccrypto.o(.text.LoRaMacCryptoSetLrWanVersion))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacCryptoSetLrWanVersion
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>

<P><STRONG><a name="[198]"></a>LoRaMacCryptoSetMulticastReference</STRONG> (Thumb, 88 bytes, Stack size 12 bytes, loramaccrypto.o(.text.LoRaMacCryptoSetMulticastReference))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = LoRaMacCryptoSetMulticastReference
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
</UL>

<P><STRONG><a name="[17a]"></a>LoRaMacCryptoUnsecureMessage</STRONG> (Thumb, 450 bytes, Stack size 64 bytes, loramaccrypto.o(.text.LoRaMacCryptoUnsecureMessage))
<BR><BR>[Stack]<UL><LI>Max Depth = 944<LI>Call Chain = LoRaMacCryptoUnsecureMessage &rArr; VerifyCmacB0 &rArr; SecureElementVerifyAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[17d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateFCntDown
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyCmacB0
<LI><a href="#[166]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetKeyAddrItem
<LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckFCntDown
<LI><a href="#[f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FOptsEncrypt
<LI><a href="#[176]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PayloadEncrypt
<LI><a href="#[17b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacParserData
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[123]"></a>LoRaMacInitialization</STRONG> (Thumb, 1364 bytes, Stack size 168 bytes, loramac.o(.text.LoRaMacInitialization))
<BR><BR>[Stack]<UL><LI>Max Depth = 612 + Unknown Stack Size
<LI>Call Chain = LoRaMacInitialization &rArr; SecureElementInit &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInit
<LI><a href="#[19a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetDeviceErrors
<LI><a href="#[198]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSetMulticastReference
<LI><a href="#[155]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsInit
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoInit
<LI><a href="#[197]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementInit
<LI><a href="#[196]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetStatus
<LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetStandby
<LI><a href="#[14d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionInitDefaults
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueInit
<LI><a href="#[191]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionIsActive
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetPhyParam
<LI><a href="#[193]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGetMcuTime
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ResetMacParameters
<LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacEnableRequests
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
<LI><a href="#[199]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;srand1
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerInit
</UL>

<P><STRONG><a name="[129]"></a>LoRaMacIsBusy</STRONG> (Thumb, 110 bytes, Stack size 4 bytes, loramac.o(.text.LoRaMacIsBusy))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacIsBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerIsBusy
<LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcpsRequest
<LI><a href="#[1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacStop
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>

<P><STRONG><a name="[14a]"></a>LoRaMacMcChannelDelete</STRONG> (Thumb, 214 bytes, Stack size 64 bytes, loramac.o(.text.LoRaMacMcChannelDelete))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = LoRaMacMcChannelDelete &rArr; memset1
</UL>
<BR>[Calls]<UL><LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[26]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupOnMcpsIndication
</UL>

<P><STRONG><a name="[149]"></a>LoRaMacMcChannelSetup</STRONG> (Thumb, 344 bytes, Stack size 48 bytes, loramac.o(.text.LoRaMacMcChannelSetup))
<BR><BR>[Stack]<UL><LI>Max Depth = 576<LI>Call Chain = LoRaMacMcChannelSetup &rArr; LoRaMacCryptoDeriveMcSessionKeyPair &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoDeriveMcSessionKeyPair
<LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[26]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupOnMcpsIndication
</UL>

<P><STRONG><a name="[14b]"></a>LoRaMacMcChannelSetupRxParams</STRONG> (Thumb, 416 bytes, Stack size 24 bytes, loramac.o(.text.LoRaMacMcChannelSetupRxParams))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = LoRaMacMcChannelSetupRxParams &rArr; RegionVerify &rArr; RegionEU868Verify &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[19c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSetMulticastPeriodicity
<LI><a href="#[19b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionVerify
</UL>
<BR>[Called By]<UL><LI><a href="#[26]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupOnMcpsIndication
</UL>

<P><STRONG><a name="[13c]"></a>LoRaMacMcpsRequest</STRONG> (Thumb, 758 bytes, Stack size 88 bytes, loramac.o(.text.LoRaMacMcpsRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 984 + Unknown Stack Size
<LI>Call Chain = LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[19b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionVerify
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetPhyParam
<LI><a href="#[19e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Send
<LI><a href="#[129]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacIsBusy
<LI><a href="#[19d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckForMinimumAbpDatarate
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleResponseTimeout
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
</UL>

<P><STRONG><a name="[1ae]"></a>LoRaMacMibClassBSetRequestConfirm</STRONG> (Thumb, 10 bytes, Stack size 4 bytes, loramacclassb.o(.text.LoRaMacMibClassBSetRequestConfirm))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacMibClassBSetRequestConfirm
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>

<P><STRONG><a name="[f0]"></a>LoRaMacMibGetRequestConfirm</STRONG> (Thumb, 1068 bytes, Stack size 56 bytes, loramac.o(.text.LoRaMacMibGetRequestConfirm))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = LoRaMacMibGetRequestConfirm &rArr; RegionGetPhyParam &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[1a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBMibGetRequestConfirm
<LI><a href="#[1a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetVersion
<LI><a href="#[1a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementGetPin
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetPhyParam
<LI><a href="#[19f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementGetDevEui
<LI><a href="#[1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementGetJoinEui
<LI><a href="#[1a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNvmData
</UL>
<BR>[Called By]<UL><LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayTxUpdate
<LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerRequestClass
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncAppTimeReq
<LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerInit
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceOnMcpsIndication
<LI><a href="#[12a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerJoinStatus
<LI><a href="#[121]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerGetCurrentDatarate
<LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeConfirm
<LI><a href="#[124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtRestore
<LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtStore
<LI><a href="#[ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerGetCurrentClass
</UL>

<P><STRONG><a name="[125]"></a>LoRaMacMibSetRequestConfirm</STRONG> (Thumb, 2746 bytes, Stack size 64 bytes, loramac.o(.text.LoRaMacMibSetRequestConfirm))
<BR><BR>[Stack]<UL><LI>Max Depth = 576<LI>Call Chain = LoRaMacMibSetRequestConfirm &rArr; LoRaMacCryptoSetKey &rArr; LoRaMacCryptoDeriveMcKEKey &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[1ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibClassBSetRequestConfirm
<LI><a href="#[1ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSetLrWanVersion
<LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionChanMaskSet
<LI><a href="#[19b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionVerify
<LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSetKey
<LI><a href="#[1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetPin
<LI><a href="#[1a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetJoinEui
<LI><a href="#[1a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetDevEui
<LI><a href="#[1ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RestoreNvmData
<LI><a href="#[1ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertRejoinCycleTime
<LI><a href="#[1a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SwitchClass
<LI><a href="#[1a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OpenContinuousRxCWindow
</UL>
<BR>[Called By]<UL><LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerRequestClass
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncAppTimeReq
<LI><a href="#[13d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSetSystemMaxRxError
<LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerInit
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceOnMcpsIndication
<LI><a href="#[18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncOnMcpsConfirm
<LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeIndication
<LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeConfirm
</UL>

<P><STRONG><a name="[120]"></a>LoRaMacMlmeRequest</STRONG> (Thumb, 870 bytes, Stack size 72 bytes, loramac.o(.text.LoRaMacMlmeRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 952 + Unknown Stack Size
<LI>Call Chain = LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueAdd
<LI><a href="#[113]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBBeaconTimerEvent
<LI><a href="#[112]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSetBeaconState
<LI><a href="#[1b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsAcquisitionInProgress
<LI><a href="#[1b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSetPingSlotInfo
<LI><a href="#[1af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionAlternateDr
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueIsFull
<LI><a href="#[14d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionInitDefaults
<LI><a href="#[1b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTxContinuousWave
<LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsAddCmd
<LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendReJoinReq
<LI><a href="#[18e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueGetCnt
<LI><a href="#[129]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacIsBusy
<LI><a href="#[ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AbpJoinPendingStart
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ResetMacParameters
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[5a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerDeviceTimeReq
<LI><a href="#[18a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleRejoinEvents
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceOnMcpsIndication
<LI><a href="#[134]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPingSlotReq
<LI><a href="#[59]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerJoinRequest
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerBeaconReq
</UL>

<P><STRONG><a name="[17b]"></a>LoRaMacParserData</STRONG> (Thumb, 460 bytes, Stack size 24 bytes, loramacparser.o(.text.LoRaMacParserData))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = LoRaMacParserData &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoUnsecureMessage
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[16a]"></a>LoRaMacParserJoinAccept</STRONG> (Thumb, 438 bytes, Stack size 24 bytes, loramacparser.o(.text.LoRaMacParserJoinAccept))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = LoRaMacParserJoinAccept &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
</UL>

<P><STRONG><a name="[137]"></a>LoRaMacProcess</STRONG> (Thumb, 216 bytes, Stack size 16 bytes, loramac.o(.text.LoRaMacProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 1232 + Unknown Stack Size
<LI>Call Chain = LoRaMacProcess &rArr; LoRaMacHandleIrqEvents &rArr; ProcessRadioRxDone &rArr; LoRaMacCryptoUnsecureMessage &rArr; VerifyCmacB0 &rArr; SecureElementVerifyAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[1b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBProcess
<LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleNvm
<LI><a href="#[1a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OpenContinuousRxCWindow
<LI><a href="#[18a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleRejoinEvents
<LI><a href="#[1b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleIndicationEvents
<LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleRequestEvents
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleMcpsRequest
<LI><a href="#[186]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleMlmeRequest
<LI><a href="#[14e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCheckForBeaconAcquisition
<LI><a href="#[1b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsRequestPending
<LI><a href="#[1b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCheckForRxAbort
<LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacEnableRequests
<LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleIrqEvents
</UL>
<BR>[Called By]<UL><LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerProcess
</UL>

<P><STRONG><a name="[13b]"></a>LoRaMacQueryTxPossible</STRONG> (Thumb, 308 bytes, Stack size 56 bytes, loramac.o(.text.LoRaMacQueryTxPossible))
<BR><BR>[Stack]<UL><LI>Max Depth = 364 + Unknown Stack Size
<LI>Call Chain = LoRaMacQueryTxPossible &rArr; LoRaMacAdrCalcNext &rArr; RegionInitDefaults &rArr; RegionEU868InitDefaults &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[15b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsGetSizeSerializedCmds
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacAdrCalcNext
<LI><a href="#[10d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetMaxAppPayloadWithoutFOptsLength
</UL>
<BR>[Called By]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
</UL>

<P><STRONG><a name="[177]"></a>LoRaMacSerializerData</STRONG> (Thumb, 488 bytes, Stack size 24 bytes, loramacserializer.o(.text.LoRaMacSerializerData))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = LoRaMacSerializerData &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSecureMessage
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SerializeTxFrame
</UL>

<P><STRONG><a name="[170]"></a>LoRaMacSerializerJoinRequest</STRONG> (Thumb, 262 bytes, Stack size 24 bytes, loramacserializer.o(.text.LoRaMacSerializerJoinRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = LoRaMacSerializerJoinRequest &rArr; memcpyr
</UL>
<BR>[Calls]<UL><LI><a href="#[df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpyr
</UL>
<BR>[Called By]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareJoinRequest
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SerializeTxFrame
</UL>

<P><STRONG><a name="[172]"></a>LoRaMacSerializerReJoinType0or2</STRONG> (Thumb, 278 bytes, Stack size 24 bytes, loramacserializer.o(.text.LoRaMacSerializerReJoinType0or2))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = LoRaMacSerializerReJoinType0or2 &rArr; memcpyr
</UL>
<BR>[Calls]<UL><LI><a href="#[df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpyr
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareReJoinType0or2
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SerializeTxFrame
</UL>

<P><STRONG><a name="[174]"></a>LoRaMacSerializerReJoinType1</STRONG> (Thumb, 280 bytes, Stack size 24 bytes, loramacserializer.o(.text.LoRaMacSerializerReJoinType1))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = LoRaMacSerializerReJoinType1 &rArr; memcpyr
</UL>
<BR>[Calls]<UL><LI><a href="#[df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpyr
</UL>
<BR>[Called By]<UL><LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareReJoinType1
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SerializeTxFrame
</UL>

<P><STRONG><a name="[127]"></a>LoRaMacStart</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, loramac.o(.text.LoRaMacStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = LoRaMacStart
</UL>
<BR>[Calls]<UL><LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateRxSlotIdleState
</UL>
<BR>[Called By]<UL><LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerInit
<LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtStore
</UL>

<P><STRONG><a name="[1b8]"></a>LoRaMacStop</STRONG> (Thumb, 110 bytes, Stack size 16 bytes, loramac.o(.text.LoRaMacStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = LoRaMacStop &rArr; LoRaMacIsBusy
</UL>
<BR>[Calls]<UL><LI><a href="#[129]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacIsBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtStore
</UL>

<P><STRONG><a name="[126]"></a>LoRaMacTestSetDutyCycleOn</STRONG> (Thumb, 90 bytes, Stack size 16 bytes, loramac.o(.text.LoRaMacTestSetDutyCycleOn))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = LoRaMacTestSetDutyCycleOn &rArr; RegionVerify &rArr; RegionEU868Verify &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[19b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionVerify
</UL>
<BR>[Called By]<UL><LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerInit
<LI><a href="#[4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceOnMcpsIndication
</UL>

<P><STRONG><a name="[58]"></a>NvmDataMgmtEvent</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, nvmdatamgmt.o(.text.NvmDataMgmtEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = NvmDataMgmtEvent
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhandler.o(.text.LmHandlerInit)
</UL>
<P><STRONG><a name="[1bc]"></a>NvmDataMgmtFactoryReset</STRONG> (Thumb, 258 bytes, Stack size 16 bytes, nvmdatamgmt.o(.text.NvmDataMgmtFactoryReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = NvmDataMgmtFactoryReset &rArr; NvmmReset &rArr; EepromMcuWriteBuffer &rArr; am_devices_mb85rc64ta_blocking_write &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmReset
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[124]"></a>NvmDataMgmtRestore</STRONG> (Thumb, 282 bytes, Stack size 64 bytes, nvmdatamgmt.o(.text.NvmDataMgmtRestore))
<BR><BR>[Stack]<UL><LI>Max Depth = 464<LI>Call Chain = NvmDataMgmtRestore &rArr; NvmmCrc32Check &rArr; NvmmRead &rArr; EepromMcuReadBuffer &rArr; am_devices_mb85rc64ta_blocking_read &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[1be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmCrc32Check
<LI><a href="#[1bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmRead
</UL>
<BR>[Called By]<UL><LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerInit
</UL>

<P><STRONG><a name="[138]"></a>NvmDataMgmtStore</STRONG> (Thumb, 506 bytes, Stack size 64 bytes, nvmdatamgmt.o(.text.NvmDataMgmtStore))
<BR><BR>[Stack]<UL><LI>Max Depth = 432<LI>Call Chain = NvmDataMgmtStore &rArr; NvmmWrite &rArr; EepromMcuWriteBuffer &rArr; am_devices_mb85rc64ta_blocking_write &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[1b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacStop
<LI><a href="#[127]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacStart
<LI><a href="#[1c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerProcess
</UL>

<P><STRONG><a name="[1be]"></a>NvmmCrc32Check</STRONG> (Thumb, 188 bytes, Stack size 32 bytes, nvmm.o(.text.NvmmCrc32Check))
<BR><BR>[Stack]<UL><LI>Max Depth = 400<LI>Call Chain = NvmmCrc32Check &rArr; NvmmRead &rArr; EepromMcuReadBuffer &rArr; am_devices_mb85rc64ta_blocking_read &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Crc32Finalize
<LI><a href="#[1c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Crc32Update
<LI><a href="#[1c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Crc32Init
<LI><a href="#[1bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmRead
</UL>
<BR>[Called By]<UL><LI><a href="#[124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtRestore
</UL>

<P><STRONG><a name="[1bf]"></a>NvmmRead</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, nvmm.o(.text.NvmmRead))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = NvmmRead &rArr; EepromMcuReadBuffer &rArr; am_devices_mb85rc64ta_blocking_read &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuReadBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtRestore
<LI><a href="#[1be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmmCrc32Check
</UL>

<P><STRONG><a name="[1bd]"></a>NvmmReset</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, nvmm.o(.text.NvmmReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = NvmmReset &rArr; EepromMcuWriteBuffer &rArr; am_devices_mb85rc64ta_blocking_write &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuWriteBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[1bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtFactoryReset
</UL>

<P><STRONG><a name="[1c0]"></a>NvmmWrite</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, nvmm.o(.text.NvmmWrite))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = NvmmWrite &rArr; EepromMcuWriteBuffer &rArr; am_devices_mb85rc64ta_blocking_write &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuWriteBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtStore
</UL>

<P><STRONG><a name="[1c8]"></a>PARCalc</STRONG> (Thumb, 696 bytes, Stack size 144 bytes, taskhandler.o(.text.PARCalc))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = PARCalc &rArr; __aeabi_dmul
</UL>
<BR>[Calls]<UL><LI><a href="#[1ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d
<LI><a href="#[1cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[1c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2d
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dadd
<LI><a href="#[1cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f
</UL>
<BR>[Called By]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[1ce]"></a>PrepareFrame</STRONG> (Thumb, 648 bytes, Stack size 64 bytes, loramac.o(.text.PrepareFrame))
<BR><BR>[Stack]<UL><LI>Max Depth = 204<LI>Call Chain = PrepareFrame &rArr; GetMaxAppPayloadWithoutFOptsLength &rArr; RegionGetPhyParam &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[15a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsSerializeCmds
<LI><a href="#[15b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsGetSizeSerializedCmds
<LI><a href="#[1cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoGetFCntUp
<LI><a href="#[10d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetMaxAppPayloadWithoutFOptsLength
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[19e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Send
</UL>

<P><STRONG><a name="[e6]"></a>PrintHexBuffer</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, lmhandlermsgdisplay.o(.text.PrintHexBuffer))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = PrintHexBuffer &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayBeaconUpdate
<LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayRxUpdate
<LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayTxUpdate
</UL>

<P><STRONG><a name="[1f2]"></a>RadioAddRegisterToRetentionList</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, radio.o(.text.RadioAddRegisterToRetentionList))
<BR><BR>[Stack]<UL><LI>Max Depth = 440<LI>Call Chain = RadioAddRegisterToRetentionList &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegisters
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegisters
</UL>
<BR>[Called By]<UL><LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
</UL>

<P><STRONG><a name="[78]"></a>RadioCheckRfFrequency</STRONG> (Thumb, 10 bytes, Stack size 4 bytes, radio.o(.text.RadioCheckRfFrequency))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RadioCheckRfFrequency
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[71]"></a>RadioGetStatus</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, radio.o(.text.RadioGetStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = RadioGetStatus
</UL>
<BR>[Calls]<UL><LI><a href="#[1f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetOperatingMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[87]"></a>RadioGetWakeupTime</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, radio.o(.text.RadioGetWakeupTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = RadioGetWakeupTime
</UL>
<BR>[Calls]<UL><LI><a href="#[1f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetBoardTcxoWakeupTime
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[70]"></a>RadioInit</STRONG> (Thumb, 146 bytes, Stack size 16 bytes, radio.o(.text.RadioInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 456<LI>Call Chain = RadioInit &rArr; SX126xSetTxParams &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInit
<LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetStandby
<LI><a href="#[1fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxParams
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioAddRegisterToRetentionList
<LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetDioIrqParams
<LI><a href="#[1f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetBufferBaseAddress
<LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRegulatorMode
<LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[88]"></a>RadioIrqProcess</STRONG> (Thumb, 844 bytes, Stack size 32 bytes, radio.o(.text.RadioIrqProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 504<LI>Call Chain = RadioIrqProcess &rArr; SX126xGetPayload &rArr; SX126xGetRxBufferStatus &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[1f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetOperatingMode
<LI><a href="#[1fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetDio1PinState
<LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegister
<LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
<LI><a href="#[203]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPacketStatus
<LI><a href="#[202]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPayload
<LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xClearIrqStatus
<LI><a href="#[1fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetIrqStatus
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[74]"></a>RadioIsChannelFree</STRONG> (Thumb, 168 bytes, Stack size 88 bytes, radio.o(.text.RadioIsChannelFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 640<LI>Call Chain = RadioIsChannelFree &rArr; RadioSetRxConfig &rArr; SX126xSetWhiteningSeed &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetElapsedTime
<LI><a href="#[142]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetCurrentTime
<LI><a href="#[dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[7b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSleep
<LI><a href="#[80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRssi
<LI><a href="#[7d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRx
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
<LI><a href="#[73]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetChannel
<LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetModem
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[6a]"></a>RadioOnDioIrq</STRONG> (Thumb, 20 bytes, Stack size 4 bytes, radio.o(.text.RadioOnDioIrq))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RadioOnDioIrq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.text.RadioInit)
</UL>
<P><STRONG><a name="[6c]"></a>RadioOnRxTimeoutIrq</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, radio.o(.text.RadioOnRxTimeoutIrq))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = RadioOnRxTimeoutIrq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.text.RadioInit)
</UL>
<P><STRONG><a name="[6b]"></a>RadioOnTxTimeoutIrq</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, radio.o(.text.RadioOnTxTimeoutIrq))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = RadioOnTxTimeoutIrq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.text.RadioInit)
</UL>
<P><STRONG><a name="[75]"></a>RadioRandom</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, radio.o(.text.RadioRandom))
<BR><BR>[Stack]<UL><LI>Max Depth = 472<LI>Call Chain = RadioRandom &rArr; SX126xGetRandom &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[204]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRandom
<LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetModem
<LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetDioIrqParams
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[82]"></a>RadioRead</STRONG> (Thumb, 18 bytes, Stack size 16 bytes, radio.o(.text.RadioRead))
<BR><BR>[Stack]<UL><LI>Max Depth = 440<LI>Call Chain = RadioRead &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegister
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[84]"></a>RadioReadBuffer</STRONG> (Thumb, 30 bytes, Stack size 24 bytes, radio.o(.text.RadioReadBuffer))
<BR><BR>[Stack]<UL><LI>Max Depth = 432<LI>Call Chain = RadioReadBuffer &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegisters
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[80]"></a>RadioRssi</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, radio.o(.text.RadioRssi))
<BR><BR>[Stack]<UL><LI>Max Depth = 408<LI>Call Chain = RadioRssi &rArr; SX126xGetRssiInst &rArr; SX126xReadCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[205]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRssiInst
</UL>
<BR>[Called By]<UL><LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIsChannelFree
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[7d]"></a>RadioRx</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, radio.o(.text.RadioRx))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = RadioRx &rArr; SX126xSetRx &rArr; SX126xWriteRegister &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRx
<LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetDioIrqParams
</UL>
<BR>[Called By]<UL><LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIsChannelFree
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[89]"></a>RadioRxBoosted</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, radio.o(.text.RadioRxBoosted))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = RadioRxBoosted &rArr; SX126xSetRxBoosted &rArr; SX126xWriteRegister &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRxBoosted
<LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetDioIrqParams
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[7a]"></a>RadioSend</STRONG> (Thumb, 136 bytes, Stack size 24 bytes, radio.o(.text.RadioSend))
<BR><BR>[Stack]<UL><LI>Max Depth = 416<LI>Call Chain = RadioSend &rArr; SX126xGetStatus &rArr; SX126xReadCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[196]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetStatus
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
<LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSendPayload
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPacketType
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketParams
<LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetDioIrqParams
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[73]"></a>RadioSetChannel</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, radio.o(.text.RadioSetChannel))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = RadioSetChannel &rArr; SX126xSetRfFrequency &rArr; SX126xCalibrateImage &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[20b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRfFrequency
</UL>
<BR>[Called By]<UL><LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIsChannelFree
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[85]"></a>RadioSetMaxPayloadLength</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, radio.o(.text.RadioSetMaxPayloadLength))
<BR><BR>[Stack]<UL><LI>Max Depth = 400<LI>Call Chain = RadioSetMaxPayloadLength &rArr; SX126xSetPacketParams &rArr; SX126xSetCrcPolynomial &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketParams
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[72]"></a>RadioSetModem</STRONG> (Thumb, 118 bytes, Stack size 24 bytes, radio.o(.text.RadioSetModem))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = RadioSetModem &rArr; RadioSetPublicNetwork &rArr;  RadioSetModem (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetPublicNetwork
<LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketType
</UL>
<BR>[Called By]<UL><LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
<LI><a href="#[75]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRandom
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
<LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIsChannelFree
<LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetPublicNetwork
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[86]"></a>RadioSetPublicNetwork</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, radio.o(.text.RadioSetPublicNetwork))
<BR><BR>[Stack]<UL><LI>Max Depth = 408 + In Cycle
<LI>Call Chain = RadioSetPublicNetwork &rArr;  RadioSetModem (Cycle)
</UL>
<BR>[Calls]<UL><LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetModem
</UL>
<BR>[Called By]<UL><LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetModem
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[76]"></a>RadioSetRxConfig</STRONG> (Thumb, 844 bytes, Stack size 112 bytes, radio.o(.text.RadioSetRxConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 552<LI>Call Chain = RadioSetRxConfig &rArr; SX126xSetWhiteningSeed &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegister
<LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetLoRaSymbNumTimeout
<LI><a href="#[211]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetWhiteningSeed
<LI><a href="#[210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetSyncWord
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketParams
<LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetModulationParams
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioStandby
<LI><a href="#[20d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetStopRxTimerOnPreambleDetect
<LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetModem
<LI><a href="#[20e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioGetFskBandwidthRegValue
</UL>
<BR>[Called By]<UL><LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIsChannelFree
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[8a]"></a>RadioSetRxDutyCycle</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, radio.o(.text.RadioSetRxDutyCycle))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = RadioSetRxDutyCycle &rArr; SX126xSetRxDutyCycle &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[213]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRxDutyCycle
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[77]"></a>RadioSetTxConfig</STRONG> (Thumb, 722 bytes, Stack size 96 bytes, radio.o(.text.RadioSetTxConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 552<LI>Call Chain = RadioSetTxConfig &rArr; SX126xSetRfTxPower &rArr; SX126xSetTxParams &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRfTxPower
<LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegister
<LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[211]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetWhiteningSeed
<LI><a href="#[210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetSyncWord
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketParams
<LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetModulationParams
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioStandby
<LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetModem
<LI><a href="#[20e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioGetFskBandwidthRegValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[7f]"></a>RadioSetTxContinuousWave</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, radio.o(.text.RadioSetTxContinuousWave))
<BR><BR>[Stack]<UL><LI>Max Depth = 480<LI>Call Chain = RadioSetTxContinuousWave &rArr; SX126xSetRfTxPower &rArr; SX126xSetTxParams &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRfTxPower
<LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxContinuousWave
<LI><a href="#[20b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRfFrequency
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[7b]"></a>RadioSleep</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, radio.o(.text.RadioSleep))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = RadioSleep &rArr; SX126xSetSleep &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetSleep
</UL>
<BR>[Called By]<UL><LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIsChannelFree
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[7c]"></a>RadioStandby</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, radio.o(.text.RadioStandby))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = RadioStandby &rArr; SX126xSetStandby &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetStandby
</UL>
<BR>[Called By]<UL><LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[7e]"></a>RadioStartCad</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, radio.o(.text.RadioStartCad))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = RadioStartCad &rArr; SX126xSetDioIrqParams &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetCad
<LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetDioIrqParams
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[79]"></a>RadioTimeOnAir</STRONG> (Thumb, 230 bytes, Stack size 64 bytes, radio.o(.text.RadioTimeOnAir))
<BR><BR>[Stack]<UL><LI>Max Depth = 116<LI>Call Chain = RadioTimeOnAir &rArr; RadioGetLoRaTimeOnAirNumerator
</UL>
<BR>[Calls]<UL><LI><a href="#[21a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioGetLoRaBandwidthInHz
<LI><a href="#[219]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioGetLoRaTimeOnAirNumerator
<LI><a href="#[218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioGetGfskTimeOnAirNumerator
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[81]"></a>RadioWrite</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, radio.o(.text.RadioWrite))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = RadioWrite &rArr; SX126xWriteRegister &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[83]"></a>RadioWriteBuffer</STRONG> (Thumb, 30 bytes, Stack size 24 bytes, radio.o(.text.RadioWriteBuffer))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = RadioWriteBuffer &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegisters
</UL>
<BR>[Address Reference Count : 1]<UL><LI> radio.o(.rodata.Radio)
</UL>
<P><STRONG><a name="[1af]"></a>RegionAlternateDr</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, region.o(.text.RegionAlternateDr))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = RegionAlternateDr &rArr; RegionEU868AlternateDr
</UL>
<BR>[Calls]<UL><LI><a href="#[21b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868AlternateDr
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>

<P><STRONG><a name="[1ed]"></a>RegionApplyCFList</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, region.o(.text.RegionApplyCFList))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = RegionApplyCFList &rArr; RegionEU868ApplyCFList &rArr; RegionEU868ChannelAdd &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[21c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ApplyCFList
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[da]"></a>RegionApplyDrOffset</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, region.o(.text.RegionApplyDrOffset))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = RegionApplyDrOffset &rArr; RegionEU868ApplyDrOffset
</UL>
<BR>[Calls]<UL><LI><a href="#[21d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ApplyDrOffset
</UL>
<BR>[Called By]<UL><LI><a href="#[d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeRxWindowParameters
</UL>

<P><STRONG><a name="[1aa]"></a>RegionChanMaskSet</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, region.o(.text.RegionChanMaskSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = RegionChanMaskSet &rArr; RegionEU868ChanMaskSet &rArr; RegionCommonChanMaskCopy
</UL>
<BR>[Calls]<UL><LI><a href="#[21e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChanMaskSet
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>

<P><STRONG><a name="[234]"></a>RegionCommonChanDisable</STRONG> (Thumb, 106 bytes, Stack size 12 bytes, regioncommon.o(.text.RegionCommonChanDisable))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = RegionCommonChanDisable
</UL>
<BR>[Called By]<UL><LI><a href="#[231]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChannelsRemove
</UL>

<P><STRONG><a name="[232]"></a>RegionCommonChanMaskCopy</STRONG> (Thumb, 80 bytes, Stack size 12 bytes, regioncommon.o(.text.RegionCommonChanMaskCopy))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = RegionCommonChanMaskCopy
</UL>
<BR>[Called By]<UL><LI><a href="#[21e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChanMaskSet
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868InitDefaults
</UL>

<P><STRONG><a name="[21f]"></a>RegionCommonChanVerifyDr</STRONG> (Thumb, 228 bytes, Stack size 24 bytes, regioncommon.o(.text.RegionCommonChanVerifyDr))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonValueInRange
</UL>
<BR>[Called By]<UL><LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonGetNextLowerTxDr
<LI><a href="#[22a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonLinkAdrReqVerifyParams
</UL>

<P><STRONG><a name="[237]"></a>RegionCommonComputeRxWindowParameters</STRONG> (Thumb, 506 bytes, Stack size 56 bytes, regioncommon.o(.text.RegionCommonComputeRxWindowParameters))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = RegionCommonComputeRxWindowParameters
</UL>
<BR>[Called By]<UL><LI><a href="#[22e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ComputeRxWindowParameters
</UL>

<P><STRONG><a name="[235]"></a>RegionCommonComputeSymbolTimeFsk</STRONG> (Thumb, 22 bytes, Stack size 4 bytes, regioncommon.o(.text.RegionCommonComputeSymbolTimeFsk))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RegionCommonComputeSymbolTimeFsk
</UL>
<BR>[Called By]<UL><LI><a href="#[22e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ComputeRxWindowParameters
</UL>

<P><STRONG><a name="[236]"></a>RegionCommonComputeSymbolTimeLoRa</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, regioncommon.o(.text.RegionCommonComputeSymbolTimeLoRa))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = RegionCommonComputeSymbolTimeLoRa
</UL>
<BR>[Called By]<UL><LI><a href="#[22e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ComputeRxWindowParameters
</UL>

<P><STRONG><a name="[221]"></a>RegionCommonComputeTxPower</STRONG> (Thumb, 96 bytes, Stack size 32 bytes, regioncommon.o(.text.RegionCommonComputeTxPower))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = RegionCommonComputeTxPower &rArr; __hardfp_floor &rArr; __aeabi_cdrcmple
</UL>
<BR>[Calls]<UL><LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__hardfp_floor
<LI><a href="#[1ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d
<LI><a href="#[223]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2iz
</UL>
<BR>[Called By]<UL><LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868TxConfig
</UL>

<P><STRONG><a name="[224]"></a>RegionCommonCountChannels</STRONG> (Thumb, 118 bytes, Stack size 24 bytes, regioncommon.o(.text.RegionCommonCountChannels))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = RegionCommonCountChannels &rArr; CountChannels
</UL>
<BR>[Calls]<UL><LI><a href="#[225]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CountChannels
</UL>
<BR>[Called By]<UL><LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868NextChannel
</UL>

<P><STRONG><a name="[226]"></a>RegionCommonCountNbOfEnabledChannels</STRONG> (Thumb, 350 bytes, Stack size 32 bytes, regioncommon.o(.text.RegionCommonCountNbOfEnabledChannels))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = RegionCommonCountNbOfEnabledChannels &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonValueInRange
</UL>
<BR>[Called By]<UL><LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonIdentifyChannels
</UL>

<P><STRONG><a name="[110]"></a>RegionCommonGetBandwidth</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, regioncommon.o(.text.RegionCommonGetBandwidth))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = RegionCommonGetBandwidth
</UL>
<BR>[Called By]<UL><LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868TxConfig
<LI><a href="#[22e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ComputeRxWindowParameters
<LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868GetPhyParam
<LI><a href="#[10f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTimeOnAir
</UL>

<P><STRONG><a name="[227]"></a>RegionCommonGetNextLowerTxDr</STRONG> (Thumb, 152 bytes, Stack size 32 bytes, regioncommon.o(.text.RegionCommonGetNextLowerTxDr))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[21f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonChanVerifyDr
</UL>
<BR>[Called By]<UL><LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868GetPhyParam
</UL>

<P><STRONG><a name="[228]"></a>RegionCommonIdentifyChannels</STRONG> (Thumb, 226 bytes, Stack size 56 bytes, regioncommon.o(.text.RegionCommonIdentifyChannels))
<BR><BR>[Stack]<UL><LI>Max Depth = 240<LI>Call Chain = RegionCommonIdentifyChannels &rArr; RegionCommonUpdateBandTimeOff &rArr; UpdateTimeCredits &rArr; SetMaxTimeCredits &rArr; GetDutyCycle
</UL>
<BR>[Calls]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetElapsedTime
<LI><a href="#[226]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonCountNbOfEnabledChannels
<LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonUpdateBandTimeOff
</UL>
<BR>[Called By]<UL><LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868NextChannel
</UL>

<P><STRONG><a name="[241]"></a>RegionCommonLimitTxPower</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, regioncommon.o(.text.RegionCommonLimitTxPower))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = RegionCommonLimitTxPower
</UL>
<BR>[Called By]<UL><LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868TxConfig
</UL>

<P><STRONG><a name="[22a]"></a>RegionCommonLinkAdrReqVerifyParams</STRONG> (Thumb, 320 bytes, Stack size 40 bytes, regioncommon.o(.text.RegionCommonLinkAdrReqVerifyParams))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = RegionCommonLinkAdrReqVerifyParams &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonValueInRange
<LI><a href="#[21f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonChanVerifyDr
</UL>
<BR>[Called By]<UL><LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868LinkAdrReq
</UL>

<P><STRONG><a name="[23b]"></a>RegionCommonParseLinkAdrReq</STRONG> (Thumb, 114 bytes, Stack size 12 bytes, regioncommon.o(.text.RegionCommonParseLinkAdrReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = RegionCommonParseLinkAdrReq
</UL>
<BR>[Called By]<UL><LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868LinkAdrReq
</UL>

<P><STRONG><a name="[22b]"></a>RegionCommonSetBandTxDone</STRONG> (Thumb, 92 bytes, Stack size 32 bytes, regioncommon.o(.text.RegionCommonSetBandTxDone))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = RegionCommonSetBandTxDone &rArr; GetDutyCycle
</UL>
<BR>[Calls]<UL><LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetDutyCycle
</UL>
<BR>[Called By]<UL><LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868SetBandTxDone
</UL>

<P><STRONG><a name="[229]"></a>RegionCommonUpdateBandTimeOff</STRONG> (Thumb, 444 bytes, Stack size 88 bytes, regioncommon.o(.text.RegionCommonUpdateBandTimeOff))
<BR><BR>[Stack]<UL><LI>Max Depth = 184<LI>Call Chain = RegionCommonUpdateBandTimeOff &rArr; UpdateTimeCredits &rArr; SetMaxTimeCredits &rArr; GetDutyCycle
</UL>
<BR>[Calls]<UL><LI><a href="#[22d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateTimeCredits
<LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetElapsedTime
<LI><a href="#[142]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetCurrentTime
</UL>
<BR>[Called By]<UL><LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonIdentifyChannels
</UL>

<P><STRONG><a name="[220]"></a>RegionCommonValueInRange</STRONG> (Thumb, 66 bytes, Stack size 4 bytes, regioncommon.o(.text.RegionCommonValueInRange))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RegionCommonValueInRange
</UL>
<BR>[Called By]<UL><LI><a href="#[21f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonChanVerifyDr
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChannelAdd
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868RxParamSetupReq
<LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868Verify
<LI><a href="#[226]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonCountNbOfEnabledChannels
<LI><a href="#[22a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonLinkAdrReqVerifyParams
</UL>

<P><STRONG><a name="[db]"></a>RegionComputeRxWindowParameters</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, region.o(.text.RegionComputeRxWindowParameters))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = RegionComputeRxWindowParameters &rArr; RegionEU868ComputeRxWindowParameters &rArr; RegionCommonComputeRxWindowParameters
</UL>
<BR>[Calls]<UL><LI><a href="#[22e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ComputeRxWindowParameters
</UL>
<BR>[Called By]<UL><LI><a href="#[d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeRxWindowParameters
<LI><a href="#[1a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OpenContinuousRxCWindow
</UL>

<P><STRONG><a name="[1e4]"></a>RegionDlChannelReq</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, region.o(.text.RegionDlChannelReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = RegionDlChannelReq &rArr; RegionEU868DlChannelReq &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[22f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868DlChannelReq
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[21b]"></a>RegionEU868AlternateDr</STRONG> (Thumb, 18 bytes, Stack size 4 bytes, regioneu868.o(.text.RegionEU868AlternateDr))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RegionEU868AlternateDr
</UL>
<BR>[Called By]<UL><LI><a href="#[1af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionAlternateDr
</UL>

<P><STRONG><a name="[21c]"></a>RegionEU868ApplyCFList</STRONG> (Thumb, 220 bytes, Stack size 40 bytes, regioneu868.o(.text.RegionEU868ApplyCFList))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = RegionEU868ApplyCFList &rArr; RegionEU868ChannelAdd &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[231]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChannelsRemove
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChannelAdd
</UL>
<BR>[Called By]<UL><LI><a href="#[1ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionApplyCFList
</UL>

<P><STRONG><a name="[21d]"></a>RegionEU868ApplyDrOffset</STRONG> (Thumb, 56 bytes, Stack size 4 bytes, regioneu868.o(.text.RegionEU868ApplyDrOffset))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RegionEU868ApplyDrOffset
</UL>
<BR>[Called By]<UL><LI><a href="#[da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionApplyDrOffset
</UL>

<P><STRONG><a name="[21e]"></a>RegionEU868ChanMaskSet</STRONG> (Thumb, 98 bytes, Stack size 24 bytes, regioneu868.o(.text.RegionEU868ChanMaskSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = RegionEU868ChanMaskSet &rArr; RegionCommonChanMaskCopy
</UL>
<BR>[Calls]<UL><LI><a href="#[232]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonChanMaskCopy
</UL>
<BR>[Called By]<UL><LI><a href="#[1aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionChanMaskSet
</UL>

<P><STRONG><a name="[230]"></a>RegionEU868ChannelAdd</STRONG> (Thumb, 348 bytes, Stack size 24 bytes, regioneu868.o(.text.RegionEU868ChannelAdd))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = RegionEU868ChannelAdd &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonValueInRange
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
<LI><a href="#[233]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyRfFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868NewChannelReq
<LI><a href="#[21c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ApplyCFList
</UL>

<P><STRONG><a name="[231]"></a>RegionEU868ChannelsRemove</STRONG> (Thumb, 114 bytes, Stack size 32 bytes, regioneu868.o(.text.RegionEU868ChannelsRemove))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = RegionEU868ChannelsRemove &rArr; RegionCommonChanDisable
</UL>
<BR>[Calls]<UL><LI><a href="#[234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonChanDisable
</UL>
<BR>[Called By]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868NewChannelReq
<LI><a href="#[21c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ApplyCFList
</UL>

<P><STRONG><a name="[22e]"></a>RegionEU868ComputeRxWindowParameters</STRONG> (Thumb, 208 bytes, Stack size 48 bytes, regioneu868.o(.text.RegionEU868ComputeRxWindowParameters))
<BR><BR>[Stack]<UL><LI>Max Depth = 104<LI>Call Chain = RegionEU868ComputeRxWindowParameters &rArr; RegionCommonComputeRxWindowParameters
</UL>
<BR>[Calls]<UL><LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonGetBandwidth
<LI><a href="#[237]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonComputeRxWindowParameters
<LI><a href="#[235]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonComputeSymbolTimeFsk
<LI><a href="#[236]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonComputeSymbolTimeLoRa
</UL>
<BR>[Called By]<UL><LI><a href="#[db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionComputeRxWindowParameters
</UL>

<P><STRONG><a name="[22f]"></a>RegionEU868DlChannelReq</STRONG> (Thumb, 162 bytes, Stack size 24 bytes, regioneu868.o(.text.RegionEU868DlChannelReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = RegionEU868DlChannelReq &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[233]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyRfFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[1e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionDlChannelReq
</UL>

<P><STRONG><a name="[238]"></a>RegionEU868GetPhyParam</STRONG> (Thumb, 542 bytes, Stack size 32 bytes, regioneu868.o(.text.RegionEU868GetPhyParam))
<BR><BR>[Stack]<UL><LI>Max Depth = 92<LI>Call Chain = RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[147]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randr
<LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonGetBandwidth
<LI><a href="#[227]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonGetNextLowerTxDr
</UL>
<BR>[Called By]<UL><LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868LinkAdrReq
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetPhyParam
</UL>

<P><STRONG><a name="[239]"></a>RegionEU868InitDefaults</STRONG> (Thumb, 384 bytes, Stack size 208 bytes, regioneu868.o(.text.RegionEU868InitDefaults))
<BR><BR>[Stack]<UL><LI>Max Depth = 220 + Unknown Stack Size
<LI>Call Chain = RegionEU868InitDefaults &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
<LI><a href="#[232]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonChanMaskCopy
<LI><a href="#[a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr4
</UL>
<BR>[Called By]<UL><LI><a href="#[14d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionInitDefaults
</UL>

<P><STRONG><a name="[23a]"></a>RegionEU868LinkAdrReq</STRONG> (Thumb, 600 bytes, Stack size 96 bytes, regioneu868.o(.text.RegionEU868LinkAdrReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 188<LI>Call Chain = RegionEU868LinkAdrReq &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868GetPhyParam
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
<LI><a href="#[22a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonLinkAdrReqVerifyParams
<LI><a href="#[23b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonParseLinkAdrReq
</UL>
<BR>[Called By]<UL><LI><a href="#[1e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionLinkAdrReq
</UL>

<P><STRONG><a name="[23c]"></a>RegionEU868NewChannelReq</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, regioneu868.o(.text.RegionEU868NewChannelReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = RegionEU868NewChannelReq &rArr; RegionEU868ChannelAdd &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[231]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChannelsRemove
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChannelAdd
</UL>
<BR>[Called By]<UL><LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionNewChannelReq
</UL>

<P><STRONG><a name="[23d]"></a>RegionEU868NextChannel</STRONG> (Thumb, 324 bytes, Stack size 112 bytes, regioneu868.o(.text.RegionEU868NextChannel))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = RegionEU868NextChannel &rArr; RegionCommonIdentifyChannels &rArr; RegionCommonUpdateBandTimeOff &rArr; UpdateTimeCredits &rArr; SetMaxTimeCredits &rArr; GetDutyCycle
</UL>
<BR>[Calls]<UL><LI><a href="#[147]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randr
<LI><a href="#[10f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTimeOnAir
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonIdentifyChannels
<LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonCountChannels
</UL>
<BR>[Called By]<UL><LI><a href="#[243]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionNextChannel
</UL>

<P><STRONG><a name="[244]"></a>RegionEU868RxConfig</STRONG> (Thumb, 442 bytes, Stack size 88 bytes, regioneu868.o(.text.RegionEU868RxConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = RegionEU868RxConfig
</UL>
<BR>[Called By]<UL><LI><a href="#[1c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionRxConfig
</UL>

<P><STRONG><a name="[23e]"></a>RegionEU868RxParamSetupReq</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, regioneu868.o(.text.RegionEU868RxParamSetupReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = RegionEU868RxParamSetupReq &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonValueInRange
<LI><a href="#[233]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyRfFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[1e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionRxParamSetupReq
</UL>

<P><STRONG><a name="[23f]"></a>RegionEU868SetBandTxDone</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, regioneu868.o(.text.RegionEU868SetBandTxDone))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = RegionEU868SetBandTxDone &rArr; RegionCommonSetBandTxDone &rArr; GetDutyCycle
</UL>
<BR>[Calls]<UL><LI><a href="#[22b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonSetBandTxDone
</UL>
<BR>[Called By]<UL><LI><a href="#[1f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionSetBandTxDone
</UL>

<P><STRONG><a name="[240]"></a>RegionEU868TxConfig</STRONG> (Thumb, 396 bytes, Stack size 88 bytes, regioneu868.o(.text.RegionEU868TxConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 176<LI>Call Chain = RegionEU868TxConfig &rArr; RegionCommonComputeTxPower &rArr; __hardfp_floor &rArr; __aeabi_cdrcmple
</UL>
<BR>[Calls]<UL><LI><a href="#[10f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTimeOnAir
<LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonGetBandwidth
<LI><a href="#[241]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonLimitTxPower
<LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonComputeTxPower
</UL>
<BR>[Called By]<UL><LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionTxConfig
</UL>

<P><STRONG><a name="[246]"></a>RegionEU868TxParamSetupReq</STRONG> (Thumb, 12 bytes, Stack size 4 bytes, regioneu868.o(.text.RegionEU868TxParamSetupReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RegionEU868TxParamSetupReq
</UL>
<BR>[Called By]<UL><LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionTxParamSetupReq
</UL>

<P><STRONG><a name="[242]"></a>RegionEU868Verify</STRONG> (Thumb, 196 bytes, Stack size 24 bytes, regioneu868.o(.text.RegionEU868Verify))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = RegionEU868Verify &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[220]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonValueInRange
<LI><a href="#[233]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyRfFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[19b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionVerify
</UL>

<P><STRONG><a name="[10e]"></a>RegionGetPhyParam</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, region.o(.text.RegionGetPhyParam))
<BR><BR>[Stack]<UL><LI>Max Depth = 116<LI>Call Chain = RegionGetPhyParam &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868GetPhyParam
</UL>
<BR>[Called By]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcpsRequest
<LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacAdrCalcNext
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[10d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetMaxAppPayloadWithoutFOptsLength
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
</UL>

<P><STRONG><a name="[1a3]"></a>RegionGetVersion</STRONG> (Thumb, 16 bytes, Stack size 4 bytes, region.o(.text.RegionGetVersion))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RegionGetVersion
</UL>
<BR>[Called By]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
</UL>

<P><STRONG><a name="[14d]"></a>RegionInitDefaults</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, region.o(.text.RegionInitDefaults))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = RegionInitDefaults &rArr; RegionEU868InitDefaults &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868InitDefaults
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacAdrCalcNext
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ResetMacParameters
</UL>

<P><STRONG><a name="[191]"></a>RegionIsActive</STRONG> (Thumb, 40 bytes, Stack size 4 bytes, region.o(.text.RegionIsActive))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RegionIsActive
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
</UL>

<P><STRONG><a name="[1e0]"></a>RegionLinkAdrReq</STRONG> (Thumb, 76 bytes, Stack size 32 bytes, region.o(.text.RegionLinkAdrReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 220<LI>Call Chain = RegionLinkAdrReq &rArr; RegionEU868LinkAdrReq &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868LinkAdrReq
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[1e2]"></a>RegionNewChannelReq</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, region.o(.text.RegionNewChannelReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = RegionNewChannelReq &rArr; RegionEU868NewChannelReq &rArr; RegionEU868ChannelAdd &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[23c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868NewChannelReq
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[243]"></a>RegionNextChannel</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, region.o(.text.RegionNextChannel))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = RegionNextChannel &rArr; RegionEU868NextChannel &rArr; RegionCommonIdentifyChannels &rArr; RegionCommonUpdateBandTimeOff &rArr; UpdateTimeCredits &rArr; SetMaxTimeCredits &rArr; GetDutyCycle
</UL>
<BR>[Calls]<UL><LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868NextChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
</UL>

<P><STRONG><a name="[1c7]"></a>RegionRxConfig</STRONG> (Thumb, 52 bytes, Stack size 24 bytes, region.o(.text.RegionRxConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = RegionRxConfig &rArr; RegionEU868RxConfig
</UL>
<BR>[Calls]<UL><LI><a href="#[244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868RxConfig
</UL>
<BR>[Called By]<UL><LI><a href="#[1c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RxWindowSetup
<LI><a href="#[1a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OpenContinuousRxCWindow
</UL>

<P><STRONG><a name="[1e1]"></a>RegionRxParamSetupReq</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, region.o(.text.RegionRxParamSetupReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = RegionRxParamSetupReq &rArr; RegionEU868RxParamSetupReq &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868RxParamSetupReq
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[1f1]"></a>RegionSetBandTxDone</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, region.o(.text.RegionSetBandTxDone))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = RegionSetBandTxDone &rArr; RegionEU868SetBandTxDone &rArr; RegionCommonSetBandTxDone &rArr; GetDutyCycle
</UL>
<BR>[Calls]<UL><LI><a href="#[23f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868SetBandTxDone
</UL>
<BR>[Called By]<UL><LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
</UL>

<P><STRONG><a name="[245]"></a>RegionTxConfig</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, region.o(.text.RegionTxConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 200<LI>Call Chain = RegionTxConfig &rArr; RegionEU868TxConfig &rArr; RegionCommonComputeTxPower &rArr; __hardfp_floor &rArr; __aeabi_cdrcmple
</UL>
<BR>[Calls]<UL><LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868TxConfig
</UL>
<BR>[Called By]<UL><LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendFrameOnChannel
</UL>

<P><STRONG><a name="[1e3]"></a>RegionTxParamSetupReq</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, region.o(.text.RegionTxParamSetupReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = RegionTxParamSetupReq &rArr; RegionEU868TxParamSetupReq
</UL>
<BR>[Calls]<UL><LI><a href="#[246]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868TxParamSetupReq
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[19b]"></a>RegionVerify</STRONG> (Thumb, 56 bytes, Stack size 24 bytes, region.o(.text.RegionVerify))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = RegionVerify &rArr; RegionEU868Verify &rArr; VerifyRfFreq
</UL>
<BR>[Calls]<UL><LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868Verify
</UL>
<BR>[Called By]<UL><LI><a href="#[126]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacTestSetDutyCycleOn
<LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcpsRequest
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcChannelSetupRxParams
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[298]"></a>RtcBkupWrite</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, rtc-board.o(.text.RtcBkupWrite))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = RtcBkupWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSet
</UL>

<P><STRONG><a name="[248]"></a>RtcGetCalendarTime</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, rtc-board.o(.text.RtcGetCalendarTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = RtcGetCalendarTime &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetCalendarValue
</UL>
<BR>[Called By]<UL><LI><a href="#[140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSet
<LI><a href="#[193]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGetMcuTime
</UL>

<P><STRONG><a name="[249]"></a>RtcGetCalendarValue</STRONG> (Thumb, 194 bytes, Stack size 24 bytes, rtc-board.o(.text.RtcGetCalendarValue))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[24a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_time_get
</UL>
<BR>[Called By]<UL><LI><a href="#[24b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetTimerElapsedTime
<LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetCalendarTime
<LI><a href="#[24c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetTimerValue
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcSetTimerContext
</UL>

<P><STRONG><a name="[2a0]"></a>RtcGetMinimumTimeout</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, rtc-board.o(.text.RtcGetMinimumTimeout))
<BR><BR>[Called By]<UL><LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetTimeout
</UL>

<P><STRONG><a name="[29f]"></a>RtcGetTimerContext</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, rtc-board.o(.text.RtcGetTimerContext))
<BR><BR>[Called By]<UL><LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerIrqHandler
</UL>

<P><STRONG><a name="[24b]"></a>RtcGetTimerElapsedTime</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, rtc-board.o(.text.RtcGetTimerElapsedTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = RtcGetTimerElapsedTime &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetCalendarValue
</UL>
<BR>[Called By]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerIrqHandler
<LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetTimeout
</UL>

<P><STRONG><a name="[24c]"></a>RtcGetTimerValue</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, rtc-board.o(.text.RtcGetTimerValue))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = RtcGetTimerValue &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetCalendarValue
</UL>
<BR>[Called By]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetElapsedTime
<LI><a href="#[142]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetCurrentTime
</UL>

<P><STRONG><a name="[ba]"></a>RtcInit</STRONG> (Thumb, 108 bytes, Stack size 64 bytes, rtc-board.o(.text.RtcInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = RtcInit &rArr; am_hal_rtc_time_set &rArr; time_input_validate
</UL>
<BR>[Calls]<UL><LI><a href="#[24d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_alarm_set
<LI><a href="#[251]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_time_set
<LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_int_enable
<LI><a href="#[250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_time_12hour
<LI><a href="#[24f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_osc_enable
<LI><a href="#[24e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_osc_select
<LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_enable
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_control
<LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_EnableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitMcu
</UL>

<P><STRONG><a name="[29b]"></a>RtcMs2Tick</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, rtc-board.o(.text.RtcMs2Tick))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RtcMs2Tick
</UL>
<BR>[Called By]<UL><LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetElapsedTime
</UL>

<P><STRONG><a name="[255]"></a>RtcSetAlarm</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, rtc-board.o(.text.RtcSetAlarm))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStartAlarm
</UL>
<BR>[Called By]<UL><LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetTimeout
</UL>

<P><STRONG><a name="[257]"></a>RtcSetTimerContext</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, rtc-board.o(.text.RtcSetTimerContext))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetCalendarValue
</UL>
<BR>[Called By]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerIrqHandler
<LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStartAlarm
</UL>

<P><STRONG><a name="[256]"></a>RtcStartAlarm</STRONG> (Thumb, 662 bytes, Stack size 72 bytes, rtc-board.o(.text.RtcStartAlarm))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[24d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_alarm_set
<LI><a href="#[252]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_int_enable
<LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_enable
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
<LI><a href="#[259]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStopAlarm
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcSetTimerContext
<LI><a href="#[254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_EnableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcSetAlarm
</UL>

<P><STRONG><a name="[259]"></a>RtcStopAlarm</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, rtc-board.o(.text.RtcStopAlarm))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = RtcStopAlarm &rArr; am_hal_rtc_int_clear
</UL>
<BR>[Calls]<UL><LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_int_clear
<LI><a href="#[25a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_int_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStartAlarm
</UL>

<P><STRONG><a name="[29a]"></a>RtcTick2Ms</STRONG> (Thumb, 16 bytes, Stack size 4 bytes, rtc-board.o(.text.RtcTick2Ms))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = RtcTick2Ms
</UL>
<BR>[Called By]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetElapsedTime
<LI><a href="#[142]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetCurrentTime
</UL>

<P><STRONG><a name="[25c]"></a>SHTC3_GetTempAndHumi</STRONG> (Thumb, 160 bytes, Stack size 56 bytes, shtc3.o(.text.SHTC3_GetTempAndHumi))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = SHTC3_GetTempAndHumi &rArr; SHTC3_ReadBytesAndCrc &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_CalcHumidity
<LI><a href="#[25f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_CalcTemperature
<LI><a href="#[25e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_ReadBytesAndCrc
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
<LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeTempMeasurement
</UL>

<P><STRONG><a name="[263]"></a>SX126xAntSwOff</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, sx126x-board.o(.text.SX126xAntSwOff))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = SX126xAntSwOff &rArr; gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
<LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetSleep
</UL>

<P><STRONG><a name="[264]"></a>SX126xAntSwOn</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, sx126x-board.o(.text.SX126xAntSwOn))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = SX126xAntSwOn &rArr; gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>

<P><STRONG><a name="[265]"></a>SX126xCalibrateImage</STRONG> (Thumb, 180 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xCalibrateImage))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xCalibrateImage &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[20b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRfFrequency
</UL>

<P><STRONG><a name="[267]"></a>SX126xCheckDeviceReady</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, sx126x.o(.text.SX126xCheckDeviceReady))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetOperatingMode
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xAntSwOn
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWakeup
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[26c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadBuffer
<LI><a href="#[27e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteBuffer
<LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegisters
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegisters
<LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadCommand
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>

<P><STRONG><a name="[1fd]"></a>SX126xClearIrqStatus</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xClearIrqStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xClearIrqStatus &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
</UL>

<P><STRONG><a name="[1f6]"></a>SX126xGetBoardTcxoWakeupTime</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, sx126x-board.o(.text.SX126xGetBoardTcxoWakeupTime))
<BR><BR>[Called By]<UL><LI><a href="#[87]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioGetWakeupTime
</UL>

<P><STRONG><a name="[19a]"></a>SX126xGetDeviceErrors</STRONG> (Thumb, 208 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xGetDeviceErrors))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = SX126xGetDeviceErrors &rArr; SX126xReadCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
</UL>

<P><STRONG><a name="[27f]"></a>SX126xGetDeviceId</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, sx126x-board.o(.text.SX126xGetDeviceId))
<BR><BR>[Called By]<UL><LI><a href="#[1fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxParams
</UL>

<P><STRONG><a name="[1fe]"></a>SX126xGetDio1PinState</STRONG> (Thumb, 10 bytes, Stack size 8 bytes, sx126x-board.o(.text.SX126xGetDio1PinState))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = SX126xGetDio1PinState &rArr; gpioRead &rArr; am_hal_gpio_state_read
</UL>
<BR>[Calls]<UL><LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioRead
</UL>
<BR>[Called By]<UL><LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
</UL>

<P><STRONG><a name="[1fc]"></a>SX126xGetIrqStatus</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xGetIrqStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = SX126xGetIrqStatus &rArr; SX126xReadCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
</UL>

<P><STRONG><a name="[1f5]"></a>SX126xGetOperatingMode</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, sx126x-board.o(.text.SX126xGetOperatingMode))
<BR><BR>[Called By]<UL><LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
<LI><a href="#[71]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioGetStatus
</UL>

<P><STRONG><a name="[203]"></a>SX126xGetPacketStatus</STRONG> (Thumb, 174 bytes, Stack size 24 bytes, sx126x.o(.text.SX126xGetPacketStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 400<LI>Call Chain = SX126xGetPacketStatus &rArr; SX126xReadCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadCommand
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPacketType
</UL>
<BR>[Called By]<UL><LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
</UL>

<P><STRONG><a name="[208]"></a>SX126xGetPacketType</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, sx126x.o(.text.SX126xGetPacketType))
<BR><BR>[Called By]<UL><LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetCrcPolynomial
<LI><a href="#[27b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetCrcSeed
<LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRxBufferStatus
<LI><a href="#[203]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPacketStatus
<LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSend
<LI><a href="#[211]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetWhiteningSeed
</UL>

<P><STRONG><a name="[202]"></a>SX126xGetPayload</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, sx126x.o(.text.SX126xGetPayload))
<BR><BR>[Stack]<UL><LI>Max Depth = 472<LI>Call Chain = SX126xGetPayload &rArr; SX126xGetRxBufferStatus &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[26c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadBuffer
<LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRxBufferStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
</UL>

<P><STRONG><a name="[204]"></a>SX126xGetRandom</STRONG> (Thumb, 134 bytes, Stack size 32 bytes, sx126x.o(.text.SX126xGetRandom))
<BR><BR>[Stack]<UL><LI>Max Depth = 456<LI>Call Chain = SX126xGetRandom &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetStandby
<LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegister
<LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegisters
<LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRx
</UL>
<BR>[Called By]<UL><LI><a href="#[75]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRandom
</UL>

<P><STRONG><a name="[205]"></a>SX126xGetRssiInst</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xGetRssiInst))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = SX126xGetRssiInst &rArr; SX126xReadCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRssi
</UL>

<P><STRONG><a name="[26b]"></a>SX126xGetRxBufferStatus</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, sx126x.o(.text.SX126xGetRxBufferStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 448<LI>Call Chain = SX126xGetRxBufferStatus &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegister
<LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadCommand
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPacketType
</UL>
<BR>[Called By]<UL><LI><a href="#[202]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPayload
</UL>

<P><STRONG><a name="[196]"></a>SX126xGetStatus</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xGetStatus))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = SX126xGetStatus &rArr; SX126xReadCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSend
</UL>

<P><STRONG><a name="[1f7]"></a>SX126xInit</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = SX126xInit &rArr; SX126xSetStandby &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetStandby
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWakeup
<LI><a href="#[26d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReset
<LI><a href="#[270]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoRfSwitchInit
<LI><a href="#[26f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoTcxoInit
<LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoIrqInit
</UL>
<BR>[Called By]<UL><LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
</UL>

<P><STRONG><a name="[26e]"></a>SX126xIoIrqInit</STRONG> (Thumb, 86 bytes, Stack size 40 bytes, sx126x-board.o(.text.SX126xIoIrqInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 152<LI>Call Chain = SX126xIoIrqInit &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_enable
<LI><a href="#[273]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_register
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_clear
<LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_enable
<LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_EnableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xInit
</UL>

<P><STRONG><a name="[270]"></a>SX126xIoRfSwitchInit</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, sx126x-board.o(.text.SX126xIoRfSwitchInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = SX126xIoRfSwitchInit &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
</UL>
<BR>[Called By]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xInit
</UL>

<P><STRONG><a name="[26f]"></a>SX126xIoTcxoInit</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, sx126x-board.o(.text.SX126xIoTcxoInit))
<BR><BR>[Called By]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xInit
</UL>

<P><STRONG><a name="[275]"></a>SX126xRXSwOff</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, sx126x-board.o(.text.SX126xRXSwOff))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = SX126xRXSwOff &rArr; gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>

<P><STRONG><a name="[276]"></a>SX126xRXSwOn</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, sx126x-board.o(.text.SX126xRXSwOn))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = SX126xRXSwOn &rArr; gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>

<P><STRONG><a name="[26c]"></a>SX126xReadBuffer</STRONG> (Thumb, 64 bytes, Stack size 32 bytes, sx126x-board.o(.text.SX126xReadBuffer))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = SX126xReadBuffer &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_read
<LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[202]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPayload
</UL>

<P><STRONG><a name="[269]"></a>SX126xReadCommand</STRONG> (Thumb, 140 bytes, Stack size 72 bytes, sx126x-board.o(.text.SX126xReadCommand))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = SX126xReadCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_read
<LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[19a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetDeviceErrors
<LI><a href="#[196]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetStatus
<LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRxBufferStatus
<LI><a href="#[203]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPacketStatus
<LI><a href="#[1fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetIrqStatus
<LI><a href="#[205]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRssiInst
</UL>

<P><STRONG><a name="[201]"></a>SX126xReadRegister</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, sx126x-board.o(.text.SX126xReadRegister))
<BR><BR>[Stack]<UL><LI>Max Depth = 424<LI>Call Chain = SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegisters
</UL>
<BR>[Called By]<UL><LI><a href="#[1fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxParams
<LI><a href="#[26b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRxBufferStatus
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
<LI><a href="#[82]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRead
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
<LI><a href="#[211]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetWhiteningSeed
<LI><a href="#[204]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRandom
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
</UL>

<P><STRONG><a name="[1f3]"></a>SX126xReadRegisters</STRONG> (Thumb, 116 bytes, Stack size 104 bytes, sx126x-board.o(.text.SX126xReadRegisters))
<BR><BR>[Stack]<UL><LI>Max Depth = 408<LI>Call Chain = SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_read
<LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegister
<LI><a href="#[84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioReadBuffer
<LI><a href="#[204]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRandom
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioAddRegisterToRetentionList
</UL>

<P><STRONG><a name="[26d]"></a>SX126xReset</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, sx126x-board.o(.text.SX126xReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = SX126xReset &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
<LI><a href="#[dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
</UL>
<BR>[Called By]<UL><LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xInit
</UL>

<P><STRONG><a name="[20a]"></a>SX126xSendPayload</STRONG> (Thumb, 32 bytes, Stack size 24 bytes, sx126x.o(.text.SX126xSendPayload))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = SX126xSendPayload &rArr; SX126xSetTx &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[279]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTx
<LI><a href="#[278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPayload
</UL>
<BR>[Called By]<UL><LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSend
</UL>

<P><STRONG><a name="[1f9]"></a>SX126xSetBufferBaseAddress</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetBufferBaseAddress))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetBufferBaseAddress &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
</UL>

<P><STRONG><a name="[217]"></a>SX126xSetCad</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, sx126x.o(.text.SX126xSetCad))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = SX126xSetCad &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>
<BR>[Called By]<UL><LI><a href="#[7e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioStartCad
</UL>

<P><STRONG><a name="[27a]"></a>SX126xSetCrcPolynomial</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetCrcPolynomial))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetCrcPolynomial &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegisters
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPacketType
</UL>
<BR>[Called By]<UL><LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketParams
</UL>

<P><STRONG><a name="[27b]"></a>SX126xSetCrcSeed</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetCrcSeed))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetCrcSeed &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegisters
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPacketType
</UL>
<BR>[Called By]<UL><LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketParams
</UL>

<P><STRONG><a name="[1fb]"></a>SX126xSetDioIrqParams</STRONG> (Thumb, 98 bytes, Stack size 24 bytes, sx126x.o(.text.SX126xSetDioIrqParams))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = SX126xSetDioIrqParams &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[89]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRxBoosted
<LI><a href="#[7e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioStartCad
<LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSend
<LI><a href="#[75]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRandom
<LI><a href="#[7d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRx
<LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
</UL>

<P><STRONG><a name="[212]"></a>SX126xSetLoRaSymbNumTimeout</STRONG> (Thumb, 158 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetLoRaSymbNumTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = SX126xSetLoRaSymbNumTimeout &rArr; SX126xWriteRegister &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
</UL>

<P><STRONG><a name="[20f]"></a>SX126xSetModulationParams</STRONG> (Thumb, 238 bytes, Stack size 32 bytes, sx126x.o(.text.SX126xSetModulationParams))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = SX126xSetModulationParams &rArr; SX126xSetPacketType &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xConvertFreqInHzToPllStep
<LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketType
</UL>
<BR>[Called By]<UL><LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
</UL>

<P><STRONG><a name="[1ff]"></a>SX126xSetOperatingMode</STRONG> (Thumb, 162 bytes, Stack size 24 bytes, sx126x-board.o(.text.SX126xSetOperatingMode))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = SX126xSetOperatingMode &rArr; SX126xAntSwOn &rArr; gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xAntSwOn
<LI><a href="#[275]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xRXSwOff
<LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xAntSwOff
<LI><a href="#[276]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xRXSwOn
</UL>
<BR>[Called By]<UL><LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetStandby
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWakeup
<LI><a href="#[279]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTx
<LI><a href="#[213]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRxDutyCycle
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRxBoosted
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
<LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxContinuousWave
<LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetCad
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRx
<LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetSleep
<LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xInit
</UL>

<P><STRONG><a name="[27d]"></a>SX126xSetPaConfig</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetPaConfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetPaConfig &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[1fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxParams
</UL>

<P><STRONG><a name="[209]"></a>SX126xSetPacketParams</STRONG> (Thumb, 326 bytes, Stack size 32 bytes, sx126x.o(.text.SX126xSetPacketParams))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = SX126xSetPacketParams &rArr; SX126xSetCrcPolynomial &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetCrcPolynomial
<LI><a href="#[27b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetCrcSeed
<LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketType
</UL>
<BR>[Called By]<UL><LI><a href="#[85]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetMaxPayloadLength
<LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSend
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
</UL>

<P><STRONG><a name="[20c]"></a>SX126xSetPacketType</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetPacketType))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetPacketType &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketParams
<LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetModulationParams
<LI><a href="#[72]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetModem
</UL>

<P><STRONG><a name="[278]"></a>SX126xSetPayload</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetPayload))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetPayload &rArr; SX126xWriteBuffer &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[27e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSendPayload
</UL>

<P><STRONG><a name="[1f8]"></a>SX126xSetRegulatorMode</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetRegulatorMode))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetRegulatorMode &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
</UL>

<P><STRONG><a name="[20b]"></a>SX126xSetRfFrequency</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, sx126x.o(.text.SX126xSetRfFrequency))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = SX126xSetRfFrequency &rArr; SX126xCalibrateImage &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCalibrateImage
<LI><a href="#[27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xConvertFreqInHzToPllStep
</UL>
<BR>[Called By]<UL><LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxContinuousWave
<LI><a href="#[73]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetChannel
</UL>

<P><STRONG><a name="[214]"></a>SX126xSetRfTxPower</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, sx126x-board.o(.text.SX126xSetRfTxPower))
<BR><BR>[Stack]<UL><LI>Max Depth = 456<LI>Call Chain = SX126xSetRfTxPower &rArr; SX126xSetTxParams &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxParams
</UL>
<BR>[Called By]<UL><LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxContinuousWave
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
</UL>

<P><STRONG><a name="[206]"></a>SX126xSetRx</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetRx))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = SX126xSetRx &rArr; SX126xWriteRegister &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>
<BR>[Called By]<UL><LI><a href="#[204]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRandom
<LI><a href="#[7d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRx
</UL>

<P><STRONG><a name="[207]"></a>SX126xSetRxBoosted</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetRxBoosted))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = SX126xSetRxBoosted &rArr; SX126xWriteRegister &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>
<BR>[Called By]<UL><LI><a href="#[89]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRxBoosted
</UL>

<P><STRONG><a name="[213]"></a>SX126xSetRxDutyCycle</STRONG> (Thumb, 76 bytes, Stack size 32 bytes, sx126x.o(.text.SX126xSetRxDutyCycle))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = SX126xSetRxDutyCycle &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>
<BR>[Called By]<UL><LI><a href="#[8a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxDutyCycle
</UL>

<P><STRONG><a name="[216]"></a>SX126xSetSleep</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, sx126x.o(.text.SX126xSetSleep))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = SX126xSetSleep &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xAntSwOff
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>
<BR>[Called By]<UL><LI><a href="#[7b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSleep
</UL>

<P><STRONG><a name="[194]"></a>SX126xSetStandby</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetStandby))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetStandby &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioStandby
<LI><a href="#[204]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRandom
<LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xInit
<LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
</UL>

<P><STRONG><a name="[20d]"></a>SX126xSetStopRxTimerOnPreambleDetect</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetStopRxTimerOnPreambleDetect))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetStopRxTimerOnPreambleDetect &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
</UL>
<BR>[Called By]<UL><LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
</UL>

<P><STRONG><a name="[210]"></a>SX126xSetSyncWord</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetSyncWord))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetSyncWord &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegisters
</UL>
<BR>[Called By]<UL><LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
</UL>

<P><STRONG><a name="[279]"></a>SX126xSetTx</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetTx))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xSetTx &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>
<BR>[Called By]<UL><LI><a href="#[20a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSendPayload
</UL>

<P><STRONG><a name="[215]"></a>SX126xSetTxContinuousWave</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, sx126x.o(.text.SX126xSetTxContinuousWave))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = SX126xSetTxContinuousWave &rArr; SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
</UL>
<BR>[Called By]<UL><LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxContinuousWave
</UL>

<P><STRONG><a name="[1fa]"></a>SX126xSetTxParams</STRONG> (Thumb, 208 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetTxParams))
<BR><BR>[Stack]<UL><LI>Max Depth = 440<LI>Call Chain = SX126xSetTxParams &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[27f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetDeviceId
<LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegister
<LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[27d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPaConfig
</UL>
<BR>[Called By]<UL><LI><a href="#[214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRfTxPower
<LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
</UL>

<P><STRONG><a name="[211]"></a>SX126xSetWhiteningSeed</STRONG> (Thumb, 90 bytes, Stack size 16 bytes, sx126x.o(.text.SX126xSetWhiteningSeed))
<BR><BR>[Stack]<UL><LI>Max Depth = 440<LI>Call Chain = SX126xSetWhiteningSeed &rArr; SX126xReadRegister &rArr; SX126xReadRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[201]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegister
<LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetPacketType
</UL>
<BR>[Called By]<UL><LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
</UL>

<P><STRONG><a name="[195]"></a>SX126xWaitOnBusy</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, sx126x-board.o(.text.SX126xWaitOnBusy))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = SX126xWaitOnBusy &rArr; DelayMs &rArr; am_util_delay_ms &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioRead
<LI><a href="#[dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[26c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadBuffer
<LI><a href="#[27e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteBuffer
<LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegisters
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegisters
<LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadCommand
<LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWakeup
<LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSend
</UL>

<P><STRONG><a name="[268]"></a>SX126xWakeup</STRONG> (Thumb, 54 bytes, Stack size 32 bytes, sx126x-board.o(.text.SX126xWakeup))
<BR><BR>[Stack]<UL><LI>Max Depth = 296<LI>Call Chain = SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_write
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[1f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xInit
</UL>

<P><STRONG><a name="[27e]"></a>SX126xWriteBuffer</STRONG> (Thumb, 60 bytes, Stack size 32 bytes, sx126x-board.o(.text.SX126xWriteBuffer))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = SX126xWriteBuffer &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_write
<LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPayload
</UL>

<P><STRONG><a name="[266]"></a>SX126xWriteCommand</STRONG> (Thumb, 62 bytes, Stack size 32 bytes, sx126x-board.o(.text.SX126xWriteCommand))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = SX126xWriteCommand &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_write
<LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetStandby
<LI><a href="#[1fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxParams
<LI><a href="#[27d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPaConfig
<LI><a href="#[265]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCalibrateImage
<LI><a href="#[279]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTx
<LI><a href="#[213]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRxDutyCycle
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRxBoosted
<LI><a href="#[1fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xClearIrqStatus
<LI><a href="#[215]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxContinuousWave
<LI><a href="#[217]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetCad
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRx
<LI><a href="#[216]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetSleep
<LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetLoRaSymbNumTimeout
<LI><a href="#[209]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketParams
<LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetModulationParams
<LI><a href="#[20d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetStopRxTimerOnPreambleDetect
<LI><a href="#[20b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRfFrequency
<LI><a href="#[20c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetPacketType
<LI><a href="#[1fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetDioIrqParams
<LI><a href="#[1f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetBufferBaseAddress
<LI><a href="#[1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRegulatorMode
</UL>

<P><STRONG><a name="[200]"></a>SX126xWriteRegister</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, sx126x-board.o(.text.SX126xWriteRegister))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SX126xWriteRegister &rArr; SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegisters
</UL>
<BR>[Called By]<UL><LI><a href="#[1fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetTxParams
<LI><a href="#[207]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRxBoosted
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
<LI><a href="#[81]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioWrite
<LI><a href="#[206]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRx
<LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
<LI><a href="#[212]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetLoRaSymbNumTimeout
<LI><a href="#[211]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetWhiteningSeed
<LI><a href="#[204]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetRandom
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
<LI><a href="#[86]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetPublicNetwork
</UL>

<P><STRONG><a name="[1f4]"></a>SX126xWriteRegisters</STRONG> (Thumb, 70 bytes, Stack size 32 bytes, sx126x-board.o(.text.SX126xWriteRegisters))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = SX126xWriteRegisters &rArr; SX126xCheckDeviceReady &rArr; SX126xWakeup &rArr; spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_write
<LI><a href="#[267]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xCheckDeviceReady
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegister
<LI><a href="#[27a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetCrcPolynomial
<LI><a href="#[27b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetCrcSeed
<LI><a href="#[83]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioWriteBuffer
<LI><a href="#[210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetSyncWord
<LI><a href="#[1f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioAddRegisterToRetentionList
</UL>

<P><STRONG><a name="[f9]"></a>SecureElementAesEncrypt</STRONG> (Thumb, 180 bytes, Stack size 280 bytes, soft-se.o(.text.SecureElementAesEncrypt))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
<LI><a href="#[d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetKeyByID
<LI><a href="#[a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_encrypt
<LI><a href="#[ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_set_key
</UL>
<BR>[Called By]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementProcessJoinAccept
<LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementDeriveAndStoreKey
<LI><a href="#[179]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetKey
<LI><a href="#[f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FOptsEncrypt
<LI><a href="#[176]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PayloadEncrypt
</UL>

<P><STRONG><a name="[d6]"></a>SecureElementComputeAesCmac</STRONG> (Thumb, 78 bytes, Stack size 32 bytes, soft-se.o(.text.SecureElementComputeAesCmac))
<BR><BR>[Stack]<UL><LI>Max Depth = 552<LI>Call Chain = SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmac
</UL>
<BR>[Called By]<UL><LI><a href="#[d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmacB0
<LI><a href="#[d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmacB1
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareReJoinType0or2
<LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareReJoinType1
<LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareJoinRequest
</UL>

<P><STRONG><a name="[e0]"></a>SecureElementDeriveAndStoreKey</STRONG> (Thumb, 158 bytes, Stack size 40 bytes, soft-se.o(.text.SecureElementDeriveAndStoreKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 464<LI>Call Chain = SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementAesEncrypt
<LI><a href="#[179]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[163]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoDeriveMcKEKey
<LI><a href="#[164]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoDeriveMcRootKey
<LI><a href="#[e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeriveSessionKey10x
<LI><a href="#[e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeriveSessionKey11x
<LI><a href="#[de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeriveLifeTimeSessionKey
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoDeriveMcSessionKeyPair
</UL>

<P><STRONG><a name="[19f]"></a>SecureElementGetDevEui</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, soft-se.o(.text.SecureElementGetDevEui))
<BR><BR>[Called By]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendReJoinReq
</UL>

<P><STRONG><a name="[1a0]"></a>SecureElementGetJoinEui</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, soft-se.o(.text.SecureElementGetJoinEui))
<BR><BR>[Called By]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendReJoinReq
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[1a1]"></a>SecureElementGetPin</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, soft-se.o(.text.SecureElementGetPin))
<BR><BR>[Called By]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
</UL>

<P><STRONG><a name="[197]"></a>SecureElementInit</STRONG> (Thumb, 78 bytes, Stack size 432 bytes, soft-se.o(.text.SecureElementInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 444<LI>Call Chain = SecureElementInit &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
<LI><a href="#[285]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
</UL>

<P><STRONG><a name="[169]"></a>SecureElementProcessJoinAccept</STRONG> (Thumb, 464 bytes, Stack size 104 bytes, soft-se.o(.text.SecureElementProcessJoinAccept))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = SecureElementProcessJoinAccept &rArr; SecureElementVerifyAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementVerifyAesCmac
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementAesEncrypt
<LI><a href="#[df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpyr
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
<LI><a href="#[168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
</UL>

<P><STRONG><a name="[1a6]"></a>SecureElementSetDevEui</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, soft-se.o(.text.SecureElementSetDevEui))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = SecureElementSetDevEui &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>

<P><STRONG><a name="[1a7]"></a>SecureElementSetJoinEui</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, soft-se.o(.text.SecureElementSetJoinEui))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = SecureElementSetJoinEui &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>

<P><STRONG><a name="[179]"></a>SecureElementSetKey</STRONG> (Thumb, 258 bytes, Stack size 48 bytes, soft-se.o(.text.SecureElementSetKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 424<LI>Call Chain = SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementAesEncrypt
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementDeriveAndStoreKey
<LI><a href="#[178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSetKey
</UL>

<P><STRONG><a name="[1a8]"></a>SecureElementSetPin</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, soft-se.o(.text.SecureElementSetPin))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = SecureElementSetPin &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>

<P><STRONG><a name="[286]"></a>SecureElementVerifyAesCmac</STRONG> (Thumb, 122 bytes, Stack size 40 bytes, soft-se.o(.text.SecureElementVerifyAesCmac))
<BR><BR>[Stack]<UL><LI>Max Depth = 560<LI>Call Chain = SecureElementVerifyAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmac
</UL>
<BR>[Called By]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementProcessJoinAccept
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyCmacB0
</UL>

<P><STRONG><a name="[19e]"></a>Send</STRONG> (Thumb, 478 bytes, Stack size 64 bytes, loramac.o(.text.Send))
<BR><BR>[Stack]<UL><LI>Max Depth = 896 + Unknown Stack Size
<LI>Call Chain = Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[158]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveNoneStickyCmds
<LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareFrame
<LI><a href="#[14c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacAdrCalcNext
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
</UL>
<BR>[Called By]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcpsRequest
</UL>

<P><STRONG><a name="[284]"></a>SendFrameOnChannel</STRONG> (Thumb, 350 bytes, Stack size 56 bytes, loramac.o(.text.SendFrameOnChannel))
<BR><BR>[Stack]<UL><LI>Max Depth = 768<LI>Call Chain = SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[28b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBHaltBeaconing
<LI><a href="#[28a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBStopRxSlots
<LI><a href="#[289]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsUplinkCollision
<LI><a href="#[288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsBeaconModeActive
<LI><a href="#[245]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionTxConfig
<LI><a href="#[287]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureFrame
</UL>
<BR>[Called By]<UL><LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
</UL>

<P><STRONG><a name="[1b0]"></a>SendReJoinReq</STRONG> (Thumb, 514 bytes, Stack size 48 bytes, loramac.o(.text.SendReJoinReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 880<LI>Call Chain = SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoGetRJcount
<LI><a href="#[19f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementGetDevEui
<LI><a href="#[1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementGetJoinEui
<LI><a href="#[1a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SwitchClass
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>

<P><STRONG><a name="[1b1]"></a>SetTxContinuousWave</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, loramac.o(.text.SetTxContinuousWave))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = SetTxContinuousWave
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>

<P><STRONG><a name="[1e6]"></a>SysTimeAdd</STRONG> (Thumb, 82 bytes, Stack size 28 bytes, systime.o(.text.SysTimeAdd))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = SysTimeAdd
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>

<P><STRONG><a name="[13f]"></a>SysTimeGet</STRONG> (Thumb, 82 bytes, Stack size 88 bytes, systime.o(.text.SysTimeGet))
<BR><BR>[Stack]<UL><LI>Max Depth = 416<LI>Call Chain = SysTimeGet &rArr; am_devices_am1805_get_time &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_get_time
<LI><a href="#[a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mktime
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
<LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncAppTimeReq
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[65]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRadioTxDone
<LI><a href="#[26]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupOnMcpsIndication
<LI><a href="#[19]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncOnMcpsIndication
</UL>

<P><STRONG><a name="[193]"></a>SysTimeGetMcuTime</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, systime.o(.text.SysTimeGetMcuTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 92<LI>Call Chain = SysTimeGetMcuTime &rArr; RtcGetCalendarTime &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetCalendarTime
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
</UL>

<P><STRONG><a name="[140]"></a>SysTimeSet</STRONG> (Thumb, 194 bytes, Stack size 72 bytes, systime.o(.text.SysTimeSet))
<BR><BR>[Stack]<UL><LI>Max Depth = 400 + Unknown Stack Size
<LI>Call Chain = SysTimeSet &rArr; am_devices_am1805_set_time &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_set_time
<LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_get_time
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSub
<LI><a href="#[298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcBkupWrite
<LI><a href="#[248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetCalendarTime
<LI><a href="#[9e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;localtime
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[19]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncOnMcpsIndication
</UL>

<P><STRONG><a name="[1e5]"></a>SysTimeSub</STRONG> (Thumb, 82 bytes, Stack size 28 bytes, systime.o(.text.SysTimeSub))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = SysTimeSub
</UL>
<BR>[Called By]<UL><LI><a href="#[140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSet
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
</UL>

<P><STRONG><a name="[142]"></a>TimerGetCurrentTime</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, timer.o(.text.TimerGetCurrentTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 84<LI>Call Chain = TimerGetCurrentTime &rArr; RtcGetTimerValue &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[24c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetTimerValue
<LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcTick2Ms
</UL>
<BR>[Called By]<UL><LI><a href="#[66]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRadioRxDone
<LI><a href="#[65]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRadioTxDone
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
<LI><a href="#[3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceProcess
<LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIsChannelFree
<LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonUpdateBandTimeOff
</UL>

<P><STRONG><a name="[119]"></a>TimerGetElapsedTime</STRONG> (Thumb, 52 bytes, Stack size 24 bytes, timer.o(.text.TimerGetElapsedTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 92<LI>Call Chain = TimerGetElapsedTime &rArr; RtcGetTimerValue &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[24c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetTimerValue
<LI><a href="#[29a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcTick2Ms
<LI><a href="#[29b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcMs2Tick
</UL>
<BR>[Called By]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleResponseTimeout
<LI><a href="#[74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIsChannelFree
<LI><a href="#[228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonIdentifyChannels
<LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonUpdateBandTimeOff
</UL>

<P><STRONG><a name="[af]"></a>TimerInit</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, timer.o(.text.TimerInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = TimerInit
</UL>
<BR>[Called By]<UL><LI><a href="#[294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StartTxProcess
<LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AbpJoinPendingStart
<LI><a href="#[22]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupInit
<LI><a href="#[1d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationInit
<LI><a href="#[70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
</UL>

<P><STRONG><a name="[29e]"></a>TimerIrqHandler</STRONG> (Thumb, 342 bytes, Stack size 40 bytes, timer.o(.text.TimerIrqHandler))
<BR><BR>[Stack]<UL><LI>Max Depth = 228<LI>Call Chain = TimerIrqHandler &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[24b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetTimerElapsedTime
<LI><a href="#[29f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetTimerContext
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcSetTimerContext
<LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetTimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_rtc_isr
</UL>

<P><STRONG><a name="[b1]"></a>TimerSetValue</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, timer.o(.text.TimerSetValue))
<BR><BR>[Stack]<UL><LI>Max Depth = 236<LI>Call Chain = TimerSetValue &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[29b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcMs2Tick
<LI><a href="#[2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetMinimumTimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[1a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxPeriodicityChanged
<LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxTimerEvent
<LI><a href="#[294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StartTxProcess
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AbpJoinPendingStart
<LI><a href="#[64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnForceRejoinReqCycleTimerEvent
<LI><a href="#[63]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin1CycleTimerEvent
<LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin0CycleTimerEvent
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
<LI><a href="#[26]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupOnMcpsIndication
<LI><a href="#[25]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupProcess
<LI><a href="#[20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationProcess
<LI><a href="#[89]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRxBoosted
<LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxContinuousWave
<LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSend
<LI><a href="#[7d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRx
</UL>

<P><STRONG><a name="[b2]"></a>TimerStart</STRONG> (Thumb, 152 bytes, Stack size 24 bytes, timer.o(.text.TimerStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 228<LI>Call Chain = TimerStart &rArr; TimerInsertNewHeadTimer &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[24b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetTimerElapsedTime
<LI><a href="#[257]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcSetTimerContext
<LI><a href="#[2a2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInsertTimer
<LI><a href="#[29c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInsertNewHeadTimer
<LI><a href="#[2a1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerExists
</UL>
<BR>[Called By]<UL><LI><a href="#[1a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxPeriodicityChanged
<LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxTimerEvent
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AbpJoinPendingStart
<LI><a href="#[64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnForceRejoinReqCycleTimerEvent
<LI><a href="#[63]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin1CycleTimerEvent
<LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin0CycleTimerEvent
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
<LI><a href="#[26]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupOnMcpsIndication
<LI><a href="#[25]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpRemoteMcastSetupProcess
<LI><a href="#[20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationProcess
<LI><a href="#[89]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRxBoosted
<LI><a href="#[7f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxContinuousWave
<LI><a href="#[7a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSend
<LI><a href="#[7d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioRx
</UL>

<P><STRONG><a name="[b0]"></a>TimerStop</STRONG> (Thumb, 286 bytes, Stack size 24 bytes, timer.o(.text.TimerStop))
<BR><BR>[Stack]<UL><LI>Max Depth = 212<LI>Call Chain = TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[259]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStopAlarm
<LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetTimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[1a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxPeriodicityChanged
<LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxTimerEvent
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AbpJoinPendingStart
<LI><a href="#[1c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RxWindowSetup
<LI><a href="#[64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnForceRejoinReqCycleTimerEvent
<LI><a href="#[63]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin1CycleTimerEvent
<LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin0CycleTimerEvent
<LI><a href="#[61]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRetransmitTimeoutTimerEvent
<LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxDelayedTimerEvent
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleMcpsRequest
<LI><a href="#[5d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnSessionStopTimer
<LI><a href="#[5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnSessionStartTimer
<LI><a href="#[5b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnFragmentTxDelay
<LI><a href="#[88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioIrqProcess
</UL>

<P><STRONG><a name="[2a5]"></a>adc_deconfig</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, adc.o(.text.adc_deconfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = adc_deconfig &rArr; am_hal_pwrctrl_periph_disable &rArr; pwrctrl_periph_disable_msk_check
</UL>
<BR>[Calls]<UL><LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_disable
<LI><a href="#[2a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_deinitialize
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
</UL>

<P><STRONG><a name="[2a9]"></a>adc_init_Cap</STRONG> (Thumb, 342 bytes, Stack size 48 bytes, adc.o(.text.adc_init_Cap))
<BR><BR>[Stack]<UL><LI>Max Depth = 160<LI>Call Chain = adc_init_Cap &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_power_control
<LI><a href="#[2ae]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_interrupt_enable
<LI><a href="#[2af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_enable
<LI><a href="#[2ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_configure_slot
<LI><a href="#[2ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_configure
<LI><a href="#[2aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_initialize
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
</UL>

<P><STRONG><a name="[a8]"></a>aes_encrypt</STRONG> (Thumb, 144 bytes, Stack size 56 bytes, aes.o(.text.aes_encrypt))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[2b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;shift_sub_rows
<LI><a href="#[2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_round_key
<LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mix_sub_columns
<LI><a href="#[2b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;copy_and_key
</UL>
<BR>[Called By]<UL><LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementAesEncrypt
<LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_Final
<LI><a href="#[ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_Update
</UL>

<P><STRONG><a name="[ac]"></a>aes_set_key</STRONG> (Thumb, 524 bytes, Stack size 40 bytes, aes.o(.text.aes_set_key))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = aes_set_key &rArr; copy_block_nn
</UL>
<BR>[Calls]<UL><LI><a href="#[2b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;copy_block_nn
</UL>
<BR>[Called By]<UL><LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementAesEncrypt
<LI><a href="#[ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_SetKey
</UL>

<P><STRONG><a name="[44]"></a>am_adc_isr</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, adc.o(.text.am_adc_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = am_adc_isr &rArr; am_hal_adc_interrupt_status
</UL>
<BR>[Calls]<UL><LI><a href="#[2b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_interrupt_clear
<LI><a href="#[2b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_interrupt_status
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[40]"></a>am_ctimer_isr</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, timing.o(.text.am_ctimer_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_ctimer_isr &rArr; am_hal_ctimer_int_clear
</UL>
<BR>[Calls]<UL><LI><a href="#[2b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_clear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[261]"></a>am_device_command_read</STRONG> (Thumb, 118 bytes, Stack size 80 bytes, i2c.o(.text.am_device_command_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
</UL>
<BR>[Called By]<UL><LI><a href="#[25e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_ReadBytesAndCrc
<LI><a href="#[f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_mb85rc64ta_blocking_read
<LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readCurrent
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readBusVoltage
<LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readRegister
<LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readShuntVoltage
<LI><a href="#[301]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_testCommunication
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_transmitMeasurementsFIFO
<LI><a href="#[300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_setInterruptMode
<LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_readRegister
<LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_set_time
<LI><a href="#[2ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_read_register
<LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_get_time
</UL>

<P><STRONG><a name="[25d]"></a>am_device_command_write</STRONG> (Thumb, 116 bytes, Stack size 80 bytes, i2c.o(.text.am_device_command_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
</UL>
<BR>[Called By]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_GetTempAndHumi
<LI><a href="#[f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_mb85rc64ta_blocking_write
<LI><a href="#[317]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_init
<LI><a href="#[2bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_dac63002_1_set_output
<LI><a href="#[293]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_stopMeasuring
<LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_setGain
<LI><a href="#[2fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_setIntegrationTime
<LI><a href="#[300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_setInterruptMode
<LI><a href="#[2ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_setWaitTime
<LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_startMeasurement
<LI><a href="#[290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_writeSMUXmapping
<LI><a href="#[2fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_clearInterrupt
<LI><a href="#[2fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_enable
<LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_set_time
<LI><a href="#[c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_config_init
</UL>

<P><STRONG><a name="[c2]"></a>am_devices_am1805_config_init</STRONG> (Thumb, 258 bytes, Stack size 56 bytes, am1805.o(.text.am_devices_am1805_config_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 376<LI>Call Chain = am_devices_am1805_config_init &rArr; am_devices_am1805_read_register &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_read_register
<LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitPeriph
</UL>

<P><STRONG><a name="[297]"></a>am_devices_am1805_get_time</STRONG> (Thumb, 170 bytes, Stack size 56 bytes, am1805.o(.text.am_devices_am1805_get_time))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = am_devices_am1805_get_time &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
<LI><a href="#[2bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bcd_to_dec
</UL>
<BR>[Called By]<UL><LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGet
<LI><a href="#[325]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtcRead
<LI><a href="#[140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSet
</UL>

<P><STRONG><a name="[2ba]"></a>am_devices_am1805_read_register</STRONG> (Thumb, 82 bytes, Stack size 48 bytes, am1805.o(.text.am_devices_am1805_read_register))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = am_devices_am1805_read_register &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
</UL>
<BR>[Called By]<UL><LI><a href="#[c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_config_init
</UL>

<P><STRONG><a name="[299]"></a>am_devices_am1805_set_time</STRONG> (Thumb, 260 bytes, Stack size 56 bytes, am1805.o(.text.am_devices_am1805_set_time))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = am_devices_am1805_set_time &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
<LI><a href="#[2bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dec_to_bcd
</UL>
<BR>[Called By]<UL><LI><a href="#[140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSet
</UL>

<P><STRONG><a name="[2bd]"></a>am_devices_dac63002_1_set_output</STRONG> (Thumb, 88 bytes, Stack size 48 bytes, dac63002.o(.text.am_devices_dac63002_1_set_output))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = am_devices_dac63002_1_set_output &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dataPrepare
<LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[4e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr5_isr
<LI><a href="#[49]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr0_isr
</UL>

<P><STRONG><a name="[f4]"></a>am_devices_mb85rc64ta_blocking_read</STRONG> (Thumb, 82 bytes, Stack size 48 bytes, mb85rc64ta.o(.text.am_devices_mb85rc64ta_blocking_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = am_devices_mb85rc64ta_blocking_read &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
</UL>
<BR>[Called By]<UL><LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuReadBuffer
</UL>

<P><STRONG><a name="[f7]"></a>am_devices_mb85rc64ta_blocking_write</STRONG> (Thumb, 82 bytes, Stack size 48 bytes, mb85rc64ta.o(.text.am_devices_mb85rc64ta_blocking_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = am_devices_mb85rc64ta_blocking_write &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuWriteBuffer
</UL>

<P><STRONG><a name="[3f]"></a>am_gpio_isr</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, gpio.o(.text.am_gpio_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = am_gpio_isr &rArr; am_hal_gpio_interrupt_service
</UL>
<BR>[Calls]<UL><LI><a href="#[2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_service
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_status_get
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_clear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[2ac]"></a>am_hal_adc_configure</STRONG> (Thumb, 206 bytes, Stack size 24 bytes, am_hal_adc.o(.text.am_hal_adc_configure))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_hal_adc_configure
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_init_Cap
</UL>

<P><STRONG><a name="[2ad]"></a>am_hal_adc_configure_slot</STRONG> (Thumb, 204 bytes, Stack size 32 bytes, am_hal_adc.o(.text.am_hal_adc_configure_slot))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = am_hal_adc_configure_slot
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_init_Cap
</UL>

<P><STRONG><a name="[2a8]"></a>am_hal_adc_deinitialize</STRONG> (Thumb, 104 bytes, Stack size 24 bytes, am_hal_adc.o(.text.am_hal_adc_deinitialize))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = am_hal_adc_deinitialize &rArr; am_hal_adc_disable
</UL>
<BR>[Calls]<UL><LI><a href="#[2a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_deconfig
</UL>

<P><STRONG><a name="[2a6]"></a>am_hal_adc_disable</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, am_hal_adc.o(.text.am_hal_adc_disable))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_adc_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[2a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_deinitialize
<LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_deconfig
</UL>

<P><STRONG><a name="[2af]"></a>am_hal_adc_enable</STRONG> (Thumb, 114 bytes, Stack size 16 bytes, am_hal_adc.o(.text.am_hal_adc_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_adc_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_init_Cap
</UL>

<P><STRONG><a name="[2aa]"></a>am_hal_adc_initialize</STRONG> (Thumb, 298 bytes, Stack size 24 bytes, am_hal_adc.o(.text.am_hal_adc_initialize))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = am_hal_adc_initialize &rArr; am_hal_flash_load_ui32
</UL>
<BR>[Calls]<UL><LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_load_ui32
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_init_Cap
</UL>

<P><STRONG><a name="[2b7]"></a>am_hal_adc_interrupt_clear</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, am_hal_adc.o(.text.am_hal_adc_interrupt_clear))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_adc_interrupt_clear
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_adc_isr
</UL>

<P><STRONG><a name="[2ae]"></a>am_hal_adc_interrupt_enable</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, am_hal_adc.o(.text.am_hal_adc_interrupt_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_adc_interrupt_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_init_Cap
</UL>

<P><STRONG><a name="[2b6]"></a>am_hal_adc_interrupt_status</STRONG> (Thumb, 132 bytes, Stack size 24 bytes, am_hal_adc.o(.text.am_hal_adc_interrupt_status))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = am_hal_adc_interrupt_status
</UL>
<BR>[Called By]<UL><LI><a href="#[44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_adc_isr
</UL>

<P><STRONG><a name="[2ab]"></a>am_hal_adc_power_control</STRONG> (Thumb, 484 bytes, Stack size 32 bytes, am_hal_adc.o(.text.am_hal_adc_power_control))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = am_hal_adc_power_control &rArr; am_hal_pwrctrl_periph_enable &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_init_Cap
</UL>

<P><STRONG><a name="[313]"></a>am_hal_adc_samples_read</STRONG> (Thumb, 298 bytes, Stack size 40 bytes, am_hal_adc.o(.text.am_hal_adc_samples_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = am_hal_adc_samples_read
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
</UL>

<P><STRONG><a name="[312]"></a>am_hal_adc_sw_trigger</STRONG> (Thumb, 78 bytes, Stack size 12 bytes, am_hal_adc.o(.text.am_hal_adc_sw_trigger))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = am_hal_adc_sw_trigger
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
</UL>

<P><STRONG><a name="[2c3]"></a>am_hal_cachectrl_control</STRONG> (Thumb, 672 bytes, Stack size 48 bytes, am_hal_cachectrl.o(.text.am_hal_cachectrl_control))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = am_hal_cachectrl_control &rArr; set_RDWAIT &rArr; am_hal_flash_store_ui32
</UL>
<BR>[Calls]<UL><LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_RDWAIT
<LI><a href="#[2c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_SEDELAY
<LI><a href="#[2c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_LPMMODE
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[b7]"></a>am_hal_clkgen_control</STRONG> (Thumb, 404 bytes, Stack size 32 bytes, am_hal_clkgen.o(.text.am_hal_clkgen_control))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = am_hal_clkgen_control &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[96]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitMcu
<LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>

<P><STRONG><a name="[2e9]"></a>am_hal_clkgen_status_get</STRONG> (Thumb, 98 bytes, Stack size 12 bytes, am_hal_clkgen.o(.text.am_hal_clkgen_status_get))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = am_hal_clkgen_status_get
</UL>
<BR>[Called By]<UL><LI><a href="#[2ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_us
<LI><a href="#[dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_tpiu_enable
</UL>

<P><STRONG><a name="[2ce]"></a>am_hal_cmdq_disable</STRONG> (Thumb, 108 bytes, Stack size 12 bytes, am_hal_cmdq.o(.text.am_hal_cmdq_disable))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = am_hal_cmdq_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_CQDisable
</UL>

<P><STRONG><a name="[2d0]"></a>am_hal_cmdq_enable</STRONG> (Thumb, 108 bytes, Stack size 12 bytes, am_hal_cmdq.o(.text.am_hal_cmdq_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = am_hal_cmdq_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_CQEnable
</UL>

<P><STRONG><a name="[2d2]"></a>am_hal_cmdq_init</STRONG> (Thumb, 306 bytes, Stack size 20 bytes, am_hal_cmdq.o(.text.am_hal_cmdq_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = am_hal_cmdq_init
</UL>
<BR>[Called By]<UL><LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_CQInit
</UL>

<P><STRONG><a name="[2b8]"></a>am_hal_ctimer_int_clear</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, am_hal_ctimer.o(.text.am_hal_ctimer_int_clear))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_ctimer_int_clear
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_ctimer_isr
</UL>

<P><STRONG><a name="[2c9]"></a>am_hal_flash_delay</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, am_hal_flash.o(.text.am_hal_flash_delay))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
<LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;internal_iom_reset_on_error
<LI><a href="#[2ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay_status_check
<LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_control
<LI><a href="#[2ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_us
<LI><a href="#[dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_tpiu_enable
<LI><a href="#[c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_sleep
</UL>

<P><STRONG><a name="[2ca]"></a>am_hal_flash_delay_status_check</STRONG> (Thumb, 116 bytes, Stack size 32 bytes, am_hal_flash.o(.text.am_hal_flash_delay_status_check))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = am_hal_flash_delay_status_check &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
<LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[2c1]"></a>am_hal_flash_load_ui32</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, am_hal_flash.o(.text.am_hal_flash_load_ui32))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_flash_load_ui32
</UL>
<BR>[Called By]<UL><LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_RDWAIT
<LI><a href="#[2c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_SEDELAY
<LI><a href="#[2c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_LPMMODE
<LI><a href="#[2aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_initialize
</UL>

<P><STRONG><a name="[328]"></a>am_hal_flash_store_ui32</STRONG> (Thumb, 60 bytes, Stack size 40 bytes, am_hal_flash.o(.text.am_hal_flash_store_ui32))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = am_hal_flash_store_ui32
</UL>
<BR>[Called By]<UL><LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_RDWAIT
<LI><a href="#[2c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_SEDELAY
<LI><a href="#[2c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_LPMMODE
</UL>

<P><STRONG><a name="[271]"></a>am_hal_gpio_interrupt_clear</STRONG> (Thumb, 72 bytes, Stack size 32 bytes, am_hal_gpio.o(.text.am_hal_gpio_interrupt_clear))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = am_hal_gpio_interrupt_clear
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[3f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_gpio_isr
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initSpecMeasurement
<LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoIrqInit
</UL>

<P><STRONG><a name="[272]"></a>am_hal_gpio_interrupt_enable</STRONG> (Thumb, 80 bytes, Stack size 32 bytes, am_hal_gpio.o(.text.am_hal_gpio_interrupt_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = am_hal_gpio_interrupt_enable
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initSpecMeasurement
<LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoIrqInit
</UL>

<P><STRONG><a name="[273]"></a>am_hal_gpio_interrupt_register</STRONG> (Thumb, 60 bytes, Stack size 12 bytes, am_hal_gpio.o(.text.am_hal_gpio_interrupt_register))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = am_hal_gpio_interrupt_register
</UL>
<BR>[Called By]<UL><LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initSpecMeasurement
<LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoIrqInit
</UL>

<P><STRONG><a name="[2c0]"></a>am_hal_gpio_interrupt_service</STRONG> (Thumb, 238 bytes, Stack size 56 bytes, am_hal_gpio.o(.text.am_hal_gpio_interrupt_service))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = am_hal_gpio_interrupt_service
</UL>
<BR>[Called By]<UL><LI><a href="#[3f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_gpio_isr
</UL>

<P><STRONG><a name="[2bf]"></a>am_hal_gpio_interrupt_status_get</STRONG> (Thumb, 156 bytes, Stack size 48 bytes, am_hal_gpio.o(.text.am_hal_gpio_interrupt_status_get))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = am_hal_gpio_interrupt_status_get
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[3f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_gpio_isr
</UL>

<P><STRONG><a name="[315]"></a>am_hal_gpio_isinput</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, am_hal_gpio.o(.text.am_hal_gpio_isinput))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_gpio_isinput
</UL>
<BR>[Called By]<UL><LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioRead
</UL>

<P><STRONG><a name="[bd]"></a>am_hal_gpio_pinconfig</STRONG> (Thumb, 964 bytes, Stack size 96 bytes, am_hal_gpio.o(.text.am_hal_gpio_pinconfig))
<BR><BR>[Stack]<UL><LI>Max Depth = 112<LI>Call Chain = am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[2cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pincfg_equ
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enable_printf
<LI><a href="#[bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnLoRa
<LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnPWRSensor
<LI><a href="#[f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnFram
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnTemp
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnPARLAI
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initSpecMeasurement
<LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_init
<LI><a href="#[302]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnI2C
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_I2C_init
<LI><a href="#[30f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnVDiv
<LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_init_Cap
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitPeriph
<LI><a href="#[26d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReset
<LI><a href="#[270]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoRfSwitchInit
<LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoIrqInit
</UL>

<P><STRONG><a name="[316]"></a>am_hal_gpio_state_read</STRONG> (Thumb, 196 bytes, Stack size 32 bytes, am_hal_gpio.o(.text.am_hal_gpio_state_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = am_hal_gpio_state_read
</UL>
<BR>[Called By]<UL><LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioRead
</UL>

<P><STRONG><a name="[2cc]"></a>am_hal_gpio_state_write</STRONG> (Thumb, 212 bytes, Stack size 40 bytes, am_hal_gpio.o(.text.am_hal_gpio_state_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>

<P><STRONG><a name="[2c4]"></a>am_hal_interrupt_master_disable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, am_hal_interrupt.o(.text.am_hal_interrupt_master_disable))
<BR><BR>[Called By]<UL><LI><a href="#[2e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_blebuck_trim
<LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_mcuctrl_control
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_status_get
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_clear
<LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_enable
<LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_state_write
<LI><a href="#[2b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_clear
<LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
<LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_RDWAIT
<LI><a href="#[2c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_SEDELAY
<LI><a href="#[2c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_LPMMODE
<LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
<LI><a href="#[c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_sleep
<LI><a href="#[2e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_compare_delta_set
</UL>

<P><STRONG><a name="[253]"></a>am_hal_interrupt_master_enable</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, am_hal_interrupt.o(.text.am_hal_interrupt_master_enable))
<BR><BR>[Called By]<UL><LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initSpecMeasurement
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
<LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoIrqInit
<LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStartAlarm
<LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>

<P><STRONG><a name="[2c5]"></a>am_hal_interrupt_master_set</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, am_hal_interrupt.o(.text.am_hal_interrupt_master_set))
<BR><BR>[Called By]<UL><LI><a href="#[2e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_blebuck_trim
<LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_mcuctrl_control
<LI><a href="#[2bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_status_get
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_clear
<LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_enable
<LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_state_write
<LI><a href="#[2b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_ctimer_int_clear
<LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
<LI><a href="#[2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_RDWAIT
<LI><a href="#[2c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_SEDELAY
<LI><a href="#[2c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_LPMMODE
<LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
<LI><a href="#[c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_sleep
<LI><a href="#[2e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_compare_delta_set
</UL>

<P><STRONG><a name="[2cd]"></a>am_hal_iom_CQDisable</STRONG> (Thumb, 24 bytes, Stack size 16 bytes, am_hal_iom.o(.text.am_hal_iom_CQDisable))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = am_hal_iom_CQDisable &rArr; am_hal_cmdq_disable
</UL>
<BR>[Calls]<UL><LI><a href="#[2ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cmdq_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_power_ctrl
</UL>

<P><STRONG><a name="[2cf]"></a>am_hal_iom_CQEnable</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, am_hal_iom.o(.text.am_hal_iom_CQEnable))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = am_hal_iom_CQEnable &rArr; am_hal_cmdq_enable
</UL>
<BR>[Calls]<UL><LI><a href="#[2d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cmdq_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_power_ctrl
</UL>

<P><STRONG><a name="[2d1]"></a>am_hal_iom_CQInit</STRONG> (Thumb, 96 bytes, Stack size 48 bytes, am_hal_iom.o(.text.am_hal_iom_CQInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = am_hal_iom_CQInit &rArr; am_hal_cmdq_init
</UL>
<BR>[Calls]<UL><LI><a href="#[2d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cmdq_init
</UL>
<BR>[Called By]<UL><LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_enable
</UL>

<P><STRONG><a name="[2b9]"></a>am_hal_iom_blocking_transfer</STRONG> (Thumb, 1290 bytes, Stack size 120 bytes, am_hal_iom.o(.text.am_hal_iom_blocking_transfer))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;validate_transaction
<LI><a href="#[2d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;internal_iom_get_int_err
<LI><a href="#[2d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;internal_iom_reset_on_error
<LI><a href="#[2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;build_cmd
<LI><a href="#[2ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay_status_check
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_read
<LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_write
<LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
</UL>

<P><STRONG><a name="[2d7]"></a>am_hal_iom_configure</STRONG> (Thumb, 594 bytes, Stack size 48 bytes, am_hal_iom.o(.text.am_hal_iom_configure))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = am_hal_iom_configure &rArr; iom_get_interface_clock_cfg &rArr; compute_freq
</UL>
<BR>[Calls]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;iom_get_interface_clock_cfg
</UL>
<BR>[Called By]<UL><LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_init
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_I2C_init
</UL>

<P><STRONG><a name="[2d9]"></a>am_hal_iom_enable</STRONG> (Thumb, 248 bytes, Stack size 32 bytes, am_hal_iom.o(.text.am_hal_iom_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 100<LI>Call Chain = am_hal_iom_enable &rArr; am_hal_iom_CQInit &rArr; am_hal_cmdq_init
</UL>
<BR>[Calls]<UL><LI><a href="#[2d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_CQInit
<LI><a href="#[2da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enable_submodule
</UL>
<BR>[Called By]<UL><LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_init
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_I2C_init
</UL>

<P><STRONG><a name="[303]"></a>am_hal_iom_initialize</STRONG> (Thumb, 158 bytes, Stack size 16 bytes, am_hal_iom.o(.text.am_hal_iom_initialize))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_iom_initialize
</UL>
<BR>[Called By]<UL><LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_init
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_I2C_init
</UL>

<P><STRONG><a name="[2db]"></a>am_hal_iom_power_ctrl</STRONG> (Thumb, 874 bytes, Stack size 32 bytes, am_hal_iom.o(.text.am_hal_iom_power_ctrl))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = am_hal_iom_power_ctrl &rArr; am_hal_pwrctrl_periph_enable &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_CQDisable
<LI><a href="#[2cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_CQEnable
<LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
<LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_init
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_I2C_init
</UL>

<P><STRONG><a name="[304]"></a>am_hal_itm_enable</STRONG> (Thumb, 102 bytes, Stack size 0 bytes, am_hal_itm.o(.text.am_hal_itm_enable))
<BR><BR>[Called By]<UL><LI><a href="#[c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enable_printf
</UL>

<P><STRONG><a name="[6e]"></a>am_hal_itm_print</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, am_hal_itm.o(.text.am_hal_itm_print))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = am_hal_itm_print &rArr; am_hal_itm_stimulus_reg_byte_write
</UL>
<BR>[Calls]<UL><LI><a href="#[2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_itm_stimulus_reg_byte_write
</UL>
<BR>[Address Reference Count : 1]<UL><LI> gpio.o(.text.enable_printf)
</UL>
<P><STRONG><a name="[2dc]"></a>am_hal_itm_stimulus_reg_byte_write</STRONG> (Thumb, 44 bytes, Stack size 12 bytes, am_hal_itm.o(.text.am_hal_itm_stimulus_reg_byte_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = am_hal_itm_stimulus_reg_byte_write
</UL>
<BR>[Called By]<UL><LI><a href="#[6e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_itm_print
</UL>

<P><STRONG><a name="[2dd]"></a>am_hal_mcuctrl_control</STRONG> (Thumb, 596 bytes, Stack size 56 bytes, am_hal_mcuctrl.o(.text.am_hal_mcuctrl_control))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = am_hal_mcuctrl_control
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_init
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_I2C_init
</UL>

<P><STRONG><a name="[2de]"></a>am_hal_mcuctrl_info_get</STRONG> (Thumb, 174 bytes, Stack size 32 bytes, am_hal_mcuctrl.o(.text.am_hal_mcuctrl_info_get))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = am_hal_mcuctrl_info_get &rArr; mcuctrl_fault_status
</UL>
<BR>[Calls]<UL><LI><a href="#[2e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mcuctrl_fault_status
<LI><a href="#[2df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_info_get
</UL>
<BR>[Called By]<UL><LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_faultisr_collect_data
</UL>

<P><STRONG><a name="[2e1]"></a>am_hal_pwrctrl_blebuck_trim</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, am_hal_pwrctrl.o(.text.am_hal_pwrctrl_blebuck_trim))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = am_hal_pwrctrl_blebuck_trim
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[b8]"></a>am_hal_pwrctrl_low_power_init</STRONG> (Thumb, 282 bytes, Stack size 24 bytes, am_hal_pwrctrl.o(.text.am_hal_pwrctrl_low_power_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = am_hal_pwrctrl_low_power_init &rArr; am_hal_cachectrl_control &rArr; set_RDWAIT &rArr; am_hal_flash_store_ui32
</UL>
<BR>[Calls]<UL><LI><a href="#[2e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_blebuck_trim
<LI><a href="#[2e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;simobuck_updates
<LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
<LI><a href="#[2ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay_status_check
<LI><a href="#[2c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[96]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitMcu
</UL>

<P><STRONG><a name="[2a7]"></a>am_hal_pwrctrl_periph_disable</STRONG> (Thumb, 186 bytes, Stack size 24 bytes, am_hal_pwrctrl.o(.text.am_hal_pwrctrl_periph_disable))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = am_hal_pwrctrl_periph_disable &rArr; pwrctrl_periph_disable_msk_check
</UL>
<BR>[Calls]<UL><LI><a href="#[2e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pwrctrl_periph_disable_msk_check
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_power_ctrl
<LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_power_control
<LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_deconfig
</UL>

<P><STRONG><a name="[2c2]"></a>am_hal_pwrctrl_periph_enable</STRONG> (Thumb, 226 bytes, Stack size 32 bytes, am_hal_pwrctrl.o(.text.am_hal_pwrctrl_periph_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = am_hal_pwrctrl_periph_enable &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_power_ctrl
<LI><a href="#[2ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_power_control
<LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[24d]"></a>am_hal_rtc_alarm_set</STRONG> (Thumb, 246 bytes, Stack size 48 bytes, am_hal_rtc.o(.text.am_hal_rtc_alarm_set))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = am_hal_rtc_alarm_set &rArr; dec_to_bcd
</UL>
<BR>[Calls]<UL><LI><a href="#[2e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dec_to_bcd
</UL>
<BR>[Called By]<UL><LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStartAlarm
<LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>

<P><STRONG><a name="[25b]"></a>am_hal_rtc_int_clear</STRONG> (Thumb, 20 bytes, Stack size 4 bytes, am_hal_rtc.o(.text.am_hal_rtc_int_clear))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_hal_rtc_int_clear
</UL>
<BR>[Called By]<UL><LI><a href="#[34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_rtc_isr
<LI><a href="#[259]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStopAlarm
</UL>

<P><STRONG><a name="[25a]"></a>am_hal_rtc_int_disable</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, am_hal_rtc.o(.text.am_hal_rtc_int_disable))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_hal_rtc_int_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[259]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStopAlarm
</UL>

<P><STRONG><a name="[252]"></a>am_hal_rtc_int_enable</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, am_hal_rtc.o(.text.am_hal_rtc_int_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_hal_rtc_int_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStartAlarm
<LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>

<P><STRONG><a name="[2ea]"></a>am_hal_rtc_int_status_get</STRONG> (Thumb, 78 bytes, Stack size 12 bytes, am_hal_rtc.o(.text.am_hal_rtc_int_status_get))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = am_hal_rtc_int_status_get
</UL>
<BR>[Called By]<UL><LI><a href="#[34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_rtc_isr
</UL>

<P><STRONG><a name="[b9]"></a>am_hal_rtc_osc_disable</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, am_hal_rtc.o(.text.am_hal_rtc_osc_disable))
<BR><BR>[Called By]<UL><LI><a href="#[96]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitMcu
</UL>

<P><STRONG><a name="[24f]"></a>am_hal_rtc_osc_enable</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, am_hal_rtc.o(.text.am_hal_rtc_osc_enable))
<BR><BR>[Called By]<UL><LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>

<P><STRONG><a name="[24e]"></a>am_hal_rtc_osc_select</STRONG> (Thumb, 32 bytes, Stack size 4 bytes, am_hal_rtc.o(.text.am_hal_rtc_osc_select))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_hal_rtc_osc_select
</UL>
<BR>[Called By]<UL><LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>

<P><STRONG><a name="[250]"></a>am_hal_rtc_time_12hour</STRONG> (Thumb, 38 bytes, Stack size 4 bytes, am_hal_rtc.o(.text.am_hal_rtc_time_12hour))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_hal_rtc_time_12hour
</UL>
<BR>[Called By]<UL><LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>

<P><STRONG><a name="[24a]"></a>am_hal_rtc_time_get</STRONG> (Thumb, 240 bytes, Stack size 32 bytes, am_hal_rtc.o(.text.am_hal_rtc_time_get))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[2e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;bcd_to_dec
</UL>
<BR>[Called By]<UL><LI><a href="#[249]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetCalendarValue
</UL>

<P><STRONG><a name="[251]"></a>am_hal_rtc_time_set</STRONG> (Thumb, 248 bytes, Stack size 48 bytes, am_hal_rtc.o(.text.am_hal_rtc_time_set))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = am_hal_rtc_time_set &rArr; time_input_validate
</UL>
<BR>[Calls]<UL><LI><a href="#[2e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dec_to_bcd
<LI><a href="#[2e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;time_input_validate
</UL>
<BR>[Called By]<UL><LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>

<P><STRONG><a name="[2e7]"></a>am_hal_stimer_compare_delta_set</STRONG> (Thumb, 184 bytes, Stack size 40 bytes, am_hal_stimer.o(.text.am_hal_stimer_compare_delta_set))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = am_hal_stimer_compare_delta_set
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[49]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr0_isr
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
</UL>

<P><STRONG><a name="[32a]"></a>am_hal_stimer_config</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, am_hal_stimer.o(.text.am_hal_stimer_config))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = am_hal_stimer_config
</UL>
<BR>[Called By]<UL><LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
</UL>

<P><STRONG><a name="[2eb]"></a>am_hal_stimer_int_clear</STRONG> (Thumb, 20 bytes, Stack size 4 bytes, am_hal_stimer.o(.text.am_hal_stimer_int_clear))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_hal_stimer_int_clear
</UL>
<BR>[Called By]<UL><LI><a href="#[4e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr5_isr
<LI><a href="#[4d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr4_isr
<LI><a href="#[49]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr0_isr
</UL>

<P><STRONG><a name="[2ed]"></a>am_hal_stimer_int_disable</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, am_hal_stimer.o(.text.am_hal_stimer_int_disable))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_hal_stimer_int_disable
</UL>
<BR>[Called By]<UL><LI><a href="#[4e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr5_isr
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
</UL>

<P><STRONG><a name="[329]"></a>am_hal_stimer_int_enable</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, am_hal_stimer.o(.text.am_hal_stimer_int_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_hal_stimer_int_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
</UL>

<P><STRONG><a name="[c4]"></a>am_hal_sysctrl_sleep</STRONG> (Thumb, 324 bytes, Stack size 48 bytes, am_hal_sysctrl.o(.text.am_hal_sysctrl_sleep))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = am_hal_sysctrl_sleep &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpectrometerMeasurement
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
<LI><a href="#[c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardLowPowerHandler
</UL>

<P><STRONG><a name="[2e8]"></a>am_hal_tpiu_enable</STRONG> (Thumb, 252 bytes, Stack size 40 bytes, am_hal_tpiu.o(.text.am_hal_tpiu_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = am_hal_tpiu_enable &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_status_get
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enable_printf
</UL>

<P><STRONG><a name="[34]"></a>am_rtc_isr</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, rtc-board.o(.text.am_rtc_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 236<LI>Call Chain = am_rtc_isr &rArr; TimerIrqHandler &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[2ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_int_status_get
<LI><a href="#[25b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_int_clear
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerIrqHandler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[49]"></a>am_stimer_cmpr0_isr</STRONG> (Thumb, 86 bytes, Stack size 8 bytes, timing.o(.text.am_stimer_cmpr0_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = am_stimer_cmpr0_isr &rArr; am_devices_dac63002_1_set_output &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_dac63002_1_set_output
<LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_clear
<LI><a href="#[2e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_compare_delta_set
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[4d]"></a>am_stimer_cmpr4_isr</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, timing.o(.text.am_stimer_cmpr4_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = am_stimer_cmpr4_isr &rArr; am_hal_stimer_int_clear
</UL>
<BR>[Calls]<UL><LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_clear
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[4e]"></a>am_stimer_cmpr5_isr</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, timing.o(.text.am_stimer_cmpr5_isr))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = am_stimer_cmpr5_isr &rArr; am_devices_dac63002_1_set_output &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_DisableIRQ
<LI><a href="#[2bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_dac63002_1_set_output
<LI><a href="#[2eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_clear
<LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_disable
</UL>
<BR>[Address Reference Count : 1]<UL><LI> startup_apollo3.o(RESET)
</UL>
<P><STRONG><a name="[dd]"></a>am_util_delay_ms</STRONG> (Thumb, 48 bytes, Stack size 32 bytes, am_util_delay.o(.text.am_util_delay_ms))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = am_util_delay_ms &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_status_get
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
<LI><a href="#[277]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_read
<LI><a href="#[280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;spi_command_write
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
<LI><a href="#[dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
</UL>

<P><STRONG><a name="[2ee]"></a>am_util_delay_us</STRONG> (Thumb, 48 bytes, Stack size 32 bytes, am_util_delay.o(.text.am_util_delay_us))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = am_util_delay_us &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_status_get
<LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
</UL>

<P><STRONG><a name="[11b]"></a>am_util_faultisr_collect_data</STRONG> (Thumb, 210 bytes, Stack size 104 bytes, am_util_faultisr.o(.text.am_util_faultisr_collect_data))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = am_util_faultisr_collect_data &rArr; am_hal_mcuctrl_info_get &rArr; mcuctrl_fault_status
</UL>
<BR>[Calls]<UL><LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_mcuctrl_info_get
<LI><a href="#[2ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getStackedReg
</UL>
<BR>[Called By]<UL><LI><a href="#[29]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HardFault_Handler
</UL>

<P><STRONG><a name="[e4]"></a>am_util_stdio_printf</STRONG> (Thumb, 92 bytes, Stack size 40 bytes, am_util_stdio.o(.text.am_util_stdio_printf))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
<LI><a href="#[96]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
<LI><a href="#[e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayBeaconUpdate
<LI><a href="#[e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayClassUpdate
<LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayRxUpdate
<LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayTxUpdate
<LI><a href="#[e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayJoinRequestUpdate
<LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayMacMlmeRequestUpdate
<LI><a href="#[e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayMacMcpsRequestUpdate
<LI><a href="#[eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNetworkParametersUpdate
<LI><a href="#[ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNvmDataChange
<LI><a href="#[e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayAppInfo
<LI><a href="#[e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrintHexBuffer
</UL>

<P><STRONG><a name="[305]"></a>am_util_stdio_printf_init</STRONG> (Thumb, 20 bytes, Stack size 4 bytes, am_util_stdio.o(.text.am_util_stdio_printf_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = am_util_stdio_printf_init
</UL>
<BR>[Called By]<UL><LI><a href="#[c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enable_printf
</UL>

<P><STRONG><a name="[2f0]"></a>am_util_stdio_vsprintf</STRONG> (Thumb, 1620 bytes, Stack size 128 bytes, am_util_stdio.o(.text.am_util_stdio_vsprintf))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[2f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ftoa
<LI><a href="#[2f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_i64
<LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uint64_to_str
<LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_u64
<LI><a href="#[2f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uint64_to_hexstr
<LI><a href="#[2f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_hex
<LI><a href="#[2f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;padbuffer
<LI><a href="#[2f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;simple_strlen
<LI><a href="#[2f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;decstr_to_int
<LI><a href="#[1cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f
</UL>
<BR>[Called By]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
</UL>

<P><STRONG><a name="[6f]"></a>as7341IRQ</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, as7341.o(.text.as7341IRQ))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = as7341IRQ &rArr; as7341_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[293]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_stopMeasuring
<LI><a href="#[2fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_clearInterrupt
<LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_readRegister
</UL>
<BR>[Address Reference Count : 1]<UL><LI> taskhandler.o(.text.initSpecMeasurement)
</UL>
<P><STRONG><a name="[2fb]"></a>as7341_clearInterrupt</STRONG> (Thumb, 84 bytes, Stack size 40 bytes, as7341.o(.text.as7341_clearInterrupt))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = as7341_clearInterrupt &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341IRQ
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_transmitMeasurementsFIFO
</UL>

<P><STRONG><a name="[2fc]"></a>as7341_config</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, as7341.o(.text.as7341_config))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = as7341_config &rArr; as7341_setInterruptMode &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
<LI><a href="#[2fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_setIntegrationTime
<LI><a href="#[300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_setInterruptMode
<LI><a href="#[2ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_setWaitTime
<LI><a href="#[2fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeSpecMeasurement
</UL>

<P><STRONG><a name="[2fd]"></a>as7341_enable</STRONG> (Thumb, 82 bytes, Stack size 40 bytes, as7341.o(.text.as7341_enable))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = as7341_enable &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_config
</UL>

<P><STRONG><a name="[309]"></a>as7341_getSpectralGain</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, as7341.o(.text.as7341_getSpectralGain))
<BR><BR>[Called By]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeSpecMeasurement
</UL>

<P><STRONG><a name="[2fa]"></a>as7341_readRegister</STRONG> (Thumb, 90 bytes, Stack size 48 bytes, as7341.o(.text.as7341_readRegister))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = as7341_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
</UL>
<BR>[Called By]<UL><LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341IRQ
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_transmitMeasurementsFIFO
</UL>

<P><STRONG><a name="[28f]"></a>as7341_setGain</STRONG> (Thumb, 312 bytes, Stack size 48 bytes, as7341.o(.text.as7341_setGain))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = as7341_setGain &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpectrometerMeasurement
</UL>

<P><STRONG><a name="[2fe]"></a>as7341_setIntegrationTime</STRONG> (Thumb, 184 bytes, Stack size 40 bytes, as7341.o(.text.as7341_setIntegrationTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = as7341_setIntegrationTime &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_config
</UL>

<P><STRONG><a name="[300]"></a>as7341_setInterruptMode</STRONG> (Thumb, 608 bytes, Stack size 56 bytes, as7341.o(.text.as7341_setInterruptMode))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = as7341_setInterruptMode &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
</UL>
<BR>[Called By]<UL><LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_config
</UL>

<P><STRONG><a name="[2ff]"></a>as7341_setWaitTime</STRONG> (Thumb, 106 bytes, Stack size 40 bytes, as7341.o(.text.as7341_setWaitTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = as7341_setWaitTime &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_config
</UL>

<P><STRONG><a name="[291]"></a>as7341_startMeasurement</STRONG> (Thumb, 148 bytes, Stack size 48 bytes, as7341.o(.text.as7341_startMeasurement))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = as7341_startMeasurement &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpectrometerMeasurement
</UL>

<P><STRONG><a name="[293]"></a>as7341_stopMeasuring</STRONG> (Thumb, 88 bytes, Stack size 40 bytes, as7341.o(.text.as7341_stopMeasuring))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = as7341_stopMeasuring &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpectrometerMeasurement
<LI><a href="#[6f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341IRQ
</UL>

<P><STRONG><a name="[301]"></a>as7341_testCommunication</STRONG> (Thumb, 110 bytes, Stack size 56 bytes, as7341.o(.text.as7341_testCommunication))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = as7341_testCommunication &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
</UL>
<BR>[Called By]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeSpecMeasurement
</UL>

<P><STRONG><a name="[292]"></a>as7341_transmitMeasurementsFIFO</STRONG> (Thumb, 142 bytes, Stack size 104 bytes, as7341.o(.text.as7341_transmitMeasurementsFIFO))
<BR><BR>[Stack]<UL><LI>Max Depth = 424<LI>Call Chain = as7341_transmitMeasurementsFIFO &rArr; as7341_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2fb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_clearInterrupt
<LI><a href="#[2fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_readRegister
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
</UL>
<BR>[Called By]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpectrometerMeasurement
</UL>

<P><STRONG><a name="[290]"></a>as7341_writeSMUXmapping</STRONG> (Thumb, 1030 bytes, Stack size 144 bytes, as7341.o(.text.as7341_writeSMUXmapping))
<BR><BR>[Stack]<UL><LI>Max Depth = 416<LI>Call Chain = as7341_writeSMUXmapping &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpectrometerMeasurement
</UL>

<P><STRONG><a name="[2be]"></a>dataPrepare</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dac63002.o(.text.dataPrepare))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = dataPrepare
</UL>
<BR>[Called By]<UL><LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readCurrent
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readBusVoltage
<LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readRegister
<LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readShuntVoltage
<LI><a href="#[317]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_init
<LI><a href="#[2bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_dac63002_1_set_output
</UL>

<P><STRONG><a name="[bf]"></a>device_I2C_init</STRONG> (Thumb, 370 bytes, Stack size 64 bytes, i2c.o(.text.device_I2C_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 232<LI>Call Chain = device_I2C_init &rArr; am_hal_iom_configure &rArr; iom_get_interface_clock_cfg &rArr; compute_freq
</UL>
<BR>[Calls]<UL><LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_mcuctrl_control
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_configure
<LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_power_ctrl
<LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_enable
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_initialize
<LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[302]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnI2C
</UL>
<BR>[Called By]<UL><LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initSpecMeasurement
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitPeriph
</UL>

<P><STRONG><a name="[c0]"></a>enable_printf</STRONG> (Thumb, 56 bytes, Stack size 32 bytes, gpio.o(.text.enable_printf))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = enable_printf &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_itm_enable
<LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[305]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf_init
<LI><a href="#[2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_tpiu_enable
</UL>
<BR>[Called By]<UL><LI><a href="#[96]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitPeriph
</UL>

<P><STRONG><a name="[306]"></a>executeSpecMeasurement</STRONG> (Thumb, 272 bytes, Stack size 32 bytes, taskhandler.o(.text.executeSpecMeasurement))
<BR><BR>[Stack]<UL><LI>Max Depth = 480<LI>Call Chain = executeSpecMeasurement &rArr; SpectrometerMeasurement &rArr; as7341_transmitMeasurementsFIFO &rArr; as7341_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOffPARLAI
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnPARLAI
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initSpecMeasurement
<LI><a href="#[28e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpectrometerMeasurement
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
<LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_config
<LI><a href="#[301]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_testCommunication
<LI><a href="#[309]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_getSpectralGain
</UL>
<BR>[Called By]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[30b]"></a>executeTempMeasurement</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, taskhandler.o(.text.executeTempMeasurement))
<BR><BR>[Stack]<UL><LI>Max Depth = 416<LI>Call Chain = executeTempMeasurement &rArr; SHTC3_GetTempAndHumi &rArr; SHTC3_ReadBytesAndCrc &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOffTemp
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnTemp
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_GetTempAndHumi
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
</UL>
<BR>[Called By]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[30e]"></a>getAdcSample</STRONG> (Thumb, 160 bytes, Stack size 32 bytes, adc.o(.text.getAdcSample))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = getAdcSample &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_enable
<LI><a href="#[312]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_sw_trigger
<LI><a href="#[313]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_adc_samples_read
<LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOffVDiv
<LI><a href="#[30f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnVDiv
<LI><a href="#[2ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_us
<LI><a href="#[2a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_deconfig
<LI><a href="#[2a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;adc_init_Cap
<LI><a href="#[311]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_SetPriority
<LI><a href="#[310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_EnableIRQ
<LI><a href="#[dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
</UL>
<BR>[Called By]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[2ef]"></a>getStackedReg</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, am_util_faultisr.o(.text.getStackedReg))
<BR><BR>[Called By]<UL><LI><a href="#[11b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_faultisr_collect_data
</UL>

<P><STRONG><a name="[26a]"></a>gpioRead</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, gpio.o(.text.gpioRead))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = gpioRead &rArr; am_hal_gpio_state_read
</UL>
<BR>[Calls]<UL><LI><a href="#[315]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_isinput
<LI><a href="#[316]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_state_read
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
<LI><a href="#[1fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xGetDio1PinState
<LI><a href="#[195]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWaitOnBusy
</UL>

<P><STRONG><a name="[258]"></a>gpioWrite</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, gpio.o(.text.gpioWrite))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[2cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_state_write
</UL>
<BR>[Called By]<UL><LI><a href="#[bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnLoRa
<LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnPWRSensor
<LI><a href="#[f5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOffFram
<LI><a href="#[f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnFram
<LI><a href="#[30d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOffTemp
<LI><a href="#[30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnTemp
<LI><a href="#[30a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOffPARLAI
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnPARLAI
<LI><a href="#[302]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnI2C
<LI><a href="#[c2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_config_init
<LI><a href="#[314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOffVDiv
<LI><a href="#[30f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnVDiv
<LI><a href="#[264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xAntSwOn
<LI><a href="#[275]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xRXSwOff
<LI><a href="#[263]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xAntSwOff
<LI><a href="#[276]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xRXSwOn
<LI><a href="#[1ff]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetOperatingMode
<LI><a href="#[26d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReset
<LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStartAlarm
</UL>

<P><STRONG><a name="[317]"></a>ina232_init</STRONG> (Thumb, 224 bytes, Stack size 40 bytes, ina232.o(.text.ina232_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 312<LI>Call Chain = ina232_init &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dataPrepare
<LI><a href="#[25d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_write
</UL>
<BR>[Called By]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prepareSensing
</UL>

<P><STRONG><a name="[318]"></a>ina232_readBusVoltage</STRONG> (Thumb, 152 bytes, Stack size 48 bytes, ina232.o(.text.ina232_readBusVoltage))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = ina232_readBusVoltage &rArr; ina232_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readRegister
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dataPrepare
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
<LI><a href="#[1cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2d
<LI><a href="#[1cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f
</UL>
<BR>[Called By]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[31b]"></a>ina232_readCurrent</STRONG> (Thumb, 184 bytes, Stack size 48 bytes, ina232.o(.text.ina232_readCurrent))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = ina232_readCurrent &rArr; ina232_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readRegister
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dataPrepare
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
<LI><a href="#[1cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2d
<LI><a href="#[1cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f
</UL>
<BR>[Called By]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[319]"></a>ina232_readRegister</STRONG> (Thumb, 90 bytes, Stack size 48 bytes, ina232.o(.text.ina232_readRegister))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = ina232_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dataPrepare
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
</UL>
<BR>[Called By]<UL><LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readCurrent
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readBusVoltage
<LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readShuntVoltage
</UL>

<P><STRONG><a name="[31c]"></a>ina232_readShuntVoltage</STRONG> (Thumb, 264 bytes, Stack size 48 bytes, ina232.o(.text.ina232_readShuntVoltage))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = ina232_readShuntVoltage &rArr; ina232_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[319]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readRegister
<LI><a href="#[2be]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;dataPrepare
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
<LI><a href="#[1cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[31a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2d
<LI><a href="#[1cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f
</UL>
<BR>[Called By]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[308]"></a>initSpecMeasurement</STRONG> (Thumb, 150 bytes, Stack size 40 bytes, taskhandler.o(.text.initSpecMeasurement))
<BR><BR>[Stack]<UL><LI>Max Depth = 272<LI>Call Chain = initSpecMeasurement &rArr; device_I2C_init &rArr; am_hal_iom_configure &rArr; iom_get_interface_clock_cfg &rArr; compute_freq
</UL>
<BR>[Calls]<UL><LI><a href="#[253]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_enable
<LI><a href="#[273]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_register
<LI><a href="#[271]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_clear
<LI><a href="#[272]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_interrupt_enable
<LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[31d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_EnableIRQ
<LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_I2C_init
</UL>
<BR>[Called By]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prepareSensing
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeSpecMeasurement
</UL>

<P><STRONG><a name="[2d5]"></a>internal_iom_get_int_err</STRONG> (Thumb, 124 bytes, Stack size 12 bytes, am_hal_iom.o(.text.internal_iom_get_int_err))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = internal_iom_get_int_err
</UL>
<BR>[Called By]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
</UL>

<P><STRONG><a name="[96]"></a>main</STRONG> (Thumb, 60 bytes, Stack size 32 bytes, main.o(.text.main))
<BR><BR>[Stack]<UL><LI>Max Depth = 1440 + Unknown Stack Size
<LI>Call Chain = main &rArr; periodicUplink &rArr; UplinkProcess &rArr; PrepareTxFrame &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
<LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;enable_printf
<LI><a href="#[b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_osc_disable
<LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
<LI><a href="#[b7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_clkgen_control
</UL>
<BR>[Called By]<UL><LI><a href="#[95]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry_main
</UL>

<P><STRONG><a name="[1d2]"></a>measurementProcess</STRONG> (Thumb, 136 bytes, Stack size 48 bytes, taskhandler.o(.text.measurementProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 528<LI>Call Chain = measurementProcess &rArr; executeSpecMeasurement &rArr; SpectrometerMeasurement &rArr; as7341_transmitMeasurementsFIFO &rArr; as7341_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prepareSensing
<LI><a href="#[1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PARCalc
<LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeTempMeasurement
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeSpecMeasurement
<LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readCurrent
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readBusVoltage
<LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readShuntVoltage
<LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
<LI><a href="#[1ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d
<LI><a href="#[1cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[322]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv
<LI><a href="#[1cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f
</UL>
<BR>[Called By]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
</UL>

<P><STRONG><a name="[a9]"></a>memcpy1</STRONG> (Thumb, 48 bytes, Stack size 12 bytes, utilities.o(.text.memcpy1))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppCopy
<LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerInit
<LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChannelAdd
<LI><a href="#[239]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868InitDefaults
<LI><a href="#[16a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacParserJoinAccept
<LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementProcessJoinAccept
<LI><a href="#[179]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetKey
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyCmacB0
<LI><a href="#[177]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerData
<LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerReJoinType0or2
<LI><a href="#[17b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacParserData
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
<LI><a href="#[1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetPin
<LI><a href="#[1a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetJoinEui
<LI><a href="#[1a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementSetDevEui
<LI><a href="#[197]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementInit
<LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsAddCmd
<LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendReJoinReq
<LI><a href="#[15a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsSerializeCmds
<LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareFrame
<LI><a href="#[1ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RestoreNvmData
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
<LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_Final
<LI><a href="#[ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_Update
</UL>

<P><STRONG><a name="[df]"></a>memcpyr</STRONG> (Thumb, 60 bytes, Stack size 12 bytes, utilities.o(.text.memcpyr))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = memcpyr
</UL>
<BR>[Called By]<UL><LI><a href="#[169]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementProcessJoinAccept
<LI><a href="#[e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeriveSessionKey11x
<LI><a href="#[de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeriveLifeTimeSessionKey
<LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerReJoinType0or2
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerReJoinType1
<LI><a href="#[170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerJoinRequest
</UL>

<P><STRONG><a name="[a7]"></a>memset1</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, utilities.o(.text.memset1))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[23a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868LinkAdrReq
<LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementAesEncrypt
<LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyCmacB0
<LI><a href="#[107]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FreeMacCommandSlot
<LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcpsRequest
<LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcChannelDelete
<LI><a href="#[155]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsInit
<LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoInit
<LI><a href="#[160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueInit
<LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
<LI><a href="#[15e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueHandleCb
<LI><a href="#[d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ClassBStatusReset
<LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
<LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeIndication
<LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_Final
<LI><a href="#[aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_Init
</UL>

<P><STRONG><a name="[320]"></a>periodicUplink</STRONG> (Thumb, 246 bytes, Stack size 24 bytes, periodicuplink.o(.text.periodicUplink))
<BR><BR>[Stack]<UL><LI>Max Depth = 1408 + Unknown Stack Size
<LI>Call Chain = periodicUplink &rArr; UplinkProcess &rArr; PrepareTxFrame &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_printf
<LI><a href="#[dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
<LI><a href="#[1bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;NvmDataMgmtFactoryReset
<LI><a href="#[26a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioRead
<LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UplinkProcess
<LI><a href="#[294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StartTxProcess
<LI><a href="#[325]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rtcRead
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardLowPowerHandler
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerProcess
<LI><a href="#[12b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerJoin
<LI><a href="#[12d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackageRegister
<LI><a href="#[13d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSetSystemMaxRxError
<LI><a href="#[122]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerInit
<LI><a href="#[e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayAppInfo
<LI><a href="#[147]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randr
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitPeriph
<LI><a href="#[b6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitMcu
</UL>
<BR>[Called By]<UL><LI><a href="#[96]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[321]"></a>prepareSensing</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, device.o(.text.prepareSensing))
<BR><BR>[Stack]<UL><LI>Max Depth = 328<LI>Call Chain = prepareSensing &rArr; ina232_init &rArr; am_device_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[326]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnPWRSensor
<LI><a href="#[f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnFram
<LI><a href="#[307]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;turnOnPARLAI
<LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initSpecMeasurement
<LI><a href="#[317]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_init
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
</UL>
<BR>[Called By]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[327]"></a>rand1</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, utilities.o(.text.rand1))
<BR><BR>[Called By]<UL><LI><a href="#[147]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randr
</UL>

<P><STRONG><a name="[147]"></a>randr</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, utilities.o(.text.randr))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = randr
</UL>
<BR>[Calls]<UL><LI><a href="#[327]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rand1
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
<LI><a href="#[1a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxPeriodicityChanged
<LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868NextChannel
<LI><a href="#[238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868GetPhyParam
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[21]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpFragmentationOnMcpsIndication
</UL>

<P><STRONG><a name="[277]"></a>spi_command_read</STRONG> (Thumb, 114 bytes, Stack size 72 bytes, spi.o(.text.spi_command_read))
<BR><BR>[Stack]<UL><LI>Max Depth = 264<LI>Call Chain = spi_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
<LI><a href="#[dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
</UL>
<BR>[Called By]<UL><LI><a href="#[26c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadBuffer
<LI><a href="#[1f3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadRegisters
<LI><a href="#[269]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xReadCommand
</UL>

<P><STRONG><a name="[280]"></a>spi_command_write</STRONG> (Thumb, 112 bytes, Stack size 72 bytes, spi.o(.text.spi_command_write))
<BR><BR>[Stack]<UL><LI>Max Depth = 264<LI>Call Chain = spi_command_write &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
<LI><a href="#[dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_delay_ms
</UL>
<BR>[Called By]<UL><LI><a href="#[27e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteBuffer
<LI><a href="#[1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteRegisters
<LI><a href="#[266]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWriteCommand
<LI><a href="#[268]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xWakeup
</UL>

<P><STRONG><a name="[be]"></a>spi_init</STRONG> (Thumb, 432 bytes, Stack size 88 bytes, spi.o(.text.spi_init))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = spi_init &rArr; am_hal_iom_configure &rArr; iom_get_interface_clock_cfg &rArr; compute_freq
</UL>
<BR>[Calls]<UL><LI><a href="#[2dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_mcuctrl_control
<LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_configure
<LI><a href="#[2db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_power_ctrl
<LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_enable
<LI><a href="#[303]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_initialize
<LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
</UL>
<BR>[Called By]<UL><LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitPeriph
</UL>

<P><STRONG><a name="[199]"></a>srand1</STRONG> (Thumb, 20 bytes, Stack size 4 bytes, utilities.o(.text.srand1))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = srand1
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
</UL>

<P><STRONG><a name="[c1]"></a>timerDelay</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, timing.o(.text.timerDelay))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = timerDelay &rArr; am_hal_sysctrl_sleep &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_DisableIRQ
<LI><a href="#[32b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__NVIC_EnableIRQ
<LI><a href="#[c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_sleep
<LI><a href="#[2ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_disable
<LI><a href="#[329]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_int_enable
<LI><a href="#[2e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_compare_delta_set
<LI><a href="#[32a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_stimer_config
</UL>
<BR>[Called By]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prepareSensing
<LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeTempMeasurement
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeSpecMeasurement
<LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_GetTempAndHumi
<LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readCurrent
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readBusVoltage
<LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readShuntVoltage
<LI><a href="#[2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_config
<LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitPeriph
</UL>

<P><STRONG><a name="[f5]"></a>turnOffFram</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, device.o(.text.turnOffFram))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = turnOffFram &rArr; gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuReadBuffer
<LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuWriteBuffer
</UL>

<P><STRONG><a name="[30a]"></a>turnOffPARLAI</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, device.o(.text.turnOffPARLAI))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = turnOffPARLAI &rArr; gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeSpecMeasurement
</UL>

<P><STRONG><a name="[30d]"></a>turnOffTemp</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, device.o(.text.turnOffTemp))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = turnOffTemp &rArr; gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeTempMeasurement
</UL>

<P><STRONG><a name="[314]"></a>turnOffVDiv</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, device.o(.text.turnOffVDiv))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = turnOffVDiv &rArr; gpioWrite &rArr; am_hal_gpio_state_write
</UL>
<BR>[Calls]<UL><LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
</UL>

<P><STRONG><a name="[f3]"></a>turnOnFram</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, device.o(.text.turnOnFram))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = turnOnFram &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prepareSensing
<LI><a href="#[f2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuReadBuffer
<LI><a href="#[f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromMcuWriteBuffer
</UL>

<P><STRONG><a name="[302]"></a>turnOnI2C</STRONG> (Thumb, 96 bytes, Stack size 32 bytes, device.o(.text.turnOnI2C))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = turnOnI2C &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[bf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;device_I2C_init
</UL>

<P><STRONG><a name="[bc]"></a>turnOnLoRa</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, device.o(.text.turnOnLoRa))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = turnOnLoRa &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardInitPeriph
</UL>

<P><STRONG><a name="[307]"></a>turnOnPARLAI</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, device.o(.text.turnOnPARLAI))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = turnOnPARLAI &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prepareSensing
<LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeSpecMeasurement
</UL>

<P><STRONG><a name="[326]"></a>turnOnPWRSensor</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, device.o(.text.turnOnPWRSensor))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = turnOnPWRSensor &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[321]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;prepareSensing
</UL>

<P><STRONG><a name="[30c]"></a>turnOnTemp</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, device.o(.text.turnOnTemp))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = turnOnTemp &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[30b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeTempMeasurement
</UL>

<P><STRONG><a name="[30f]"></a>turnOnVDiv</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, device.o(.text.turnOnVDiv))
<BR><BR>[Stack]<UL><LI>Max Depth = 128<LI>Call Chain = turnOnVDiv &rArr; am_hal_gpio_pinconfig &rArr; pincfg_equ
</UL>
<BR>[Calls]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
<LI><a href="#[258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;gpioWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
</UL>

<P><STRONG><a name="[2d3]"></a>validate_transaction</STRONG> (Thumb, 222 bytes, Stack size 32 bytes, am_hal_iom.o(.text.validate_transaction))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = validate_transaction
</UL>
<BR>[Called By]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
</UL>

<P><STRONG><a name="[222]"></a>__hardfp_floor</STRONG> (Thumb, 252 bytes, Stack size 40 bytes, floor.o(i.__hardfp_floor))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = __hardfp_floor &rArr; __aeabi_cdrcmple
</UL>
<BR>[Calls]<UL><LI><a href="#[32c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple
<LI><a href="#[32d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_drsub
<LI><a href="#[1cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dadd
</UL>
<BR>[Called By]<UL><LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonComputeTxPower
</UL>

<P><STRONG><a name="[1cd]"></a>__aeabi_d2f</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, d2f.o(x$fpl$d2f))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __aeabi_d2f
</UL>
<BR>[Called By]<UL><LI><a href="#[1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PARCalc
<LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readCurrent
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readBusVoltage
<LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readShuntVoltage
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
<LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[32e]"></a>_d2f</STRONG> (Thumb, 98 bytes, Stack size 32 bytes, d2f.o(x$fpl$d2f), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[32f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fretinf
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dnaninf
</UL>

<P><STRONG><a name="[1cc]"></a>__aeabi_dadd</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, daddsub_clz.o(x$fpl$dadd))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __aeabi_dadd
</UL>
<BR>[Called By]<UL><LI><a href="#[1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PARCalc
<LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__hardfp_floor
</UL>

<P><STRONG><a name="[331]"></a>_dadd</STRONG> (Thumb, 332 bytes, Stack size 16 bytes, daddsub_clz.o(x$fpl$dadd), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dretinf
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dnaninf
<LI><a href="#[332]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub1
</UL>

<P><STRONG><a name="[337]"></a>__fpl_dcmp_Inf</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, dcmpi.o(x$fpl$dcmpinf), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[336]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dcmple
</UL>

<P><STRONG><a name="[322]"></a>__aeabi_ddiv</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, ddiv.o(x$fpl$ddiv))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __aeabi_ddiv
</UL>
<BR>[Called By]<UL><LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[334]"></a>_ddiv</STRONG> (Thumb, 560 bytes, Stack size 32 bytes, ddiv.o(x$fpl$ddiv), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dretinf
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dnaninf
</UL>

<P><STRONG><a name="[223]"></a>__aeabi_d2iz</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, dfix.o(x$fpl$dfix))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __aeabi_d2iz
</UL>
<BR>[Called By]<UL><LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonComputeTxPower
</UL>

<P><STRONG><a name="[335]"></a>_dfix</STRONG> (Thumb, 94 bytes, Stack size 32 bytes, dfix.o(x$fpl$dfix), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dnaninf
</UL>

<P><STRONG><a name="[1c9]"></a>__aeabi_i2d</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, dflt_clz.o(x$fpl$dflt))
<BR><BR>[Called By]<UL><LI><a href="#[1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PARCalc
</UL>

<P><STRONG><a name="[375]"></a>_dflt</STRONG> (Thumb, 46 bytes, Stack size 0 bytes, dflt_clz.o(x$fpl$dflt), UNUSED)

<P><STRONG><a name="[31a]"></a>__aeabi_ui2d</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, dflt_clz.o(x$fpl$dfltu))
<BR><BR>[Called By]<UL><LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readCurrent
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readBusVoltage
<LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readShuntVoltage
</UL>

<P><STRONG><a name="[376]"></a>_dfltu</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, dflt_clz.o(x$fpl$dfltu), UNUSED)

<P><STRONG><a name="[377]"></a>__aeabi_cdcmple</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, dleqf.o(x$fpl$dleqf), UNUSED)

<P><STRONG><a name="[336]"></a>_dcmple</STRONG> (Thumb, 120 bytes, Stack size 32 bytes, dleqf.o(x$fpl$dleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[337]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_Inf
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dnaninf
</UL>

<P><STRONG><a name="[33a]"></a>__fpl_dcmple_InfNaN</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, dleqf.o(x$fpl$dleqf), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[339]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_drcmple
</UL>

<P><STRONG><a name="[1cb]"></a>__aeabi_dmul</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, dmul.o(x$fpl$dmul))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = __aeabi_dmul
</UL>
<BR>[Called By]<UL><LI><a href="#[1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PARCalc
<LI><a href="#[31b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readCurrent
<LI><a href="#[318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readBusVoltage
<LI><a href="#[31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ina232_readShuntVoltage
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
</UL>

<P><STRONG><a name="[338]"></a>_dmul</STRONG> (Thumb, 332 bytes, Stack size 32 bytes, dmul.o(x$fpl$dmul), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dretinf
<LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dnaninf
</UL>

<P><STRONG><a name="[330]"></a>__fpl_dnaninf</STRONG> (Thumb, 156 bytes, Stack size 16 bytes, dnaninf.o(x$fpl$dnaninf), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[336]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dcmple
<LI><a href="#[338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dmul
<LI><a href="#[335]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dfix
<LI><a href="#[334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ddiv
<LI><a href="#[33d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd
<LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2f
</UL>

<P><STRONG><a name="[333]"></a>__fpl_dretinf</STRONG> (Thumb, 12 bytes, Stack size 0 bytes, dretinf.o(x$fpl$dretinf), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_f2d
<LI><a href="#[338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dmul
<LI><a href="#[334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ddiv
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd
</UL>

<P><STRONG><a name="[32c]"></a>__aeabi_cdrcmple</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, drleqf.o(x$fpl$drleqf))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __aeabi_cdrcmple
</UL>
<BR>[Called By]<UL><LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__hardfp_floor
</UL>

<P><STRONG><a name="[339]"></a>_drcmple</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, drleqf.o(x$fpl$drleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[33a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmple_InfNaN
</UL>

<P><STRONG><a name="[32d]"></a>__aeabi_drsub</STRONG> (Thumb, 0 bytes, Stack size 8 bytes, daddsub_clz.o(x$fpl$drsb))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_drsub
</UL>
<BR>[Called By]<UL><LI><a href="#[222]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__hardfp_floor
</UL>

<P><STRONG><a name="[33b]"></a>_drsb</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, daddsub_clz.o(x$fpl$drsb), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[332]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub1
<LI><a href="#[33c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd1
</UL>

<P><STRONG><a name="[378]"></a>__aeabi_dsub</STRONG> (Thumb, 0 bytes, Stack size 32 bytes, daddsub_clz.o(x$fpl$dsub), UNUSED)

<P><STRONG><a name="[33d]"></a>_dsub</STRONG> (Thumb, 472 bytes, Stack size 32 bytes, daddsub_clz.o(x$fpl$dsub), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dnaninf
<LI><a href="#[33c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd1
</UL>

<P><STRONG><a name="[1ca]"></a>__aeabi_f2d</STRONG> (Thumb, 0 bytes, Stack size 16 bytes, f2d.o(x$fpl$f2d))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __aeabi_f2d
</UL>
<BR>[Called By]<UL><LI><a href="#[1c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PARCalc
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
<LI><a href="#[221]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonComputeTxPower
</UL>

<P><STRONG><a name="[33e]"></a>_f2d</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, f2d.o(x$fpl$f2d), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[33f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fnaninf
<LI><a href="#[333]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dretinf
</UL>

<P><STRONG><a name="[33f]"></a>__fpl_fnaninf</STRONG> (Thumb, 140 bytes, Stack size 8 bytes, fnaninf.o(x$fpl$fnaninf), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[33e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_f2d
</UL>

<P><STRONG><a name="[90]"></a>_fp_init</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, fpinit.o(x$fpl$fpinit))
<BR><BR>[Called By]<UL><LI><a href="#[8f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init_fp_1
</UL>

<P><STRONG><a name="[379]"></a>__fplib_config_fpu_vfp</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, fpinit.o(x$fpl$fpinit), UNUSED)

<P><STRONG><a name="[37a]"></a>__fplib_config_pureend_doubles</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, fpinit.o(x$fpl$fpinit), UNUSED)

<P><STRONG><a name="[32f]"></a>__fpl_fretinf</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, fretinf.o(x$fpl$fretinf), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[32e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2f
</UL>
<P>
<H3>
Local Symbols
</H3>
<P><STRONG><a name="[2c6]"></a>set_LPMMODE</STRONG> (Thumb, 102 bytes, Stack size 32 bytes, am_hal_cachectrl.o(.text.set_LPMMODE))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = set_LPMMODE &rArr; am_hal_flash_store_ui32
</UL>
<BR>[Calls]<UL><LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_store_ui32
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_load_ui32
</UL>
<BR>[Called By]<UL><LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
</UL>

<P><STRONG><a name="[2c7]"></a>set_SEDELAY</STRONG> (Thumb, 102 bytes, Stack size 32 bytes, am_hal_cachectrl.o(.text.set_SEDELAY))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = set_SEDELAY &rArr; am_hal_flash_store_ui32
</UL>
<BR>[Calls]<UL><LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_store_ui32
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_load_ui32
</UL>
<BR>[Called By]<UL><LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
</UL>

<P><STRONG><a name="[2c8]"></a>set_RDWAIT</STRONG> (Thumb, 102 bytes, Stack size 32 bytes, am_hal_cachectrl.o(.text.set_RDWAIT))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = set_RDWAIT &rArr; am_hal_flash_store_ui32
</UL>
<BR>[Calls]<UL><LI><a href="#[328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_store_ui32
<LI><a href="#[2c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_set
<LI><a href="#[2c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_interrupt_master_disable
<LI><a href="#[2c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_load_ui32
</UL>
<BR>[Called By]<UL><LI><a href="#[2c3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_cachectrl_control
</UL>

<P><STRONG><a name="[2cb]"></a>pincfg_equ</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, am_hal_gpio.o(.text.pincfg_equ))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = pincfg_equ
</UL>
<BR>[Called By]<UL><LI><a href="#[bd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_gpio_pinconfig
</UL>

<P><STRONG><a name="[2d4]"></a>build_cmd</STRONG> (Thumb, 126 bytes, Stack size 20 bytes, am_hal_iom.o(.text.build_cmd))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = build_cmd
</UL>
<BR>[Called By]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
</UL>

<P><STRONG><a name="[2da]"></a>enable_submodule</STRONG> (Thumb, 72 bytes, Stack size 8 bytes, am_hal_iom.o(.text.enable_submodule))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = enable_submodule
</UL>
<BR>[Called By]<UL><LI><a href="#[2d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_enable
</UL>

<P><STRONG><a name="[2d6]"></a>internal_iom_reset_on_error</STRONG> (Thumb, 590 bytes, Stack size 56 bytes, am_hal_iom.o(.text.internal_iom_reset_on_error))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[2c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_flash_delay
</UL>
<BR>[Called By]<UL><LI><a href="#[2b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_blocking_transfer
</UL>

<P><STRONG><a name="[2d8]"></a>iom_get_interface_clock_cfg</STRONG> (Thumb, 602 bytes, Stack size 96 bytes, am_hal_iom.o(.text.iom_get_interface_clock_cfg))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = iom_get_interface_clock_cfg &rArr; compute_freq
</UL>
<BR>[Calls]<UL><LI><a href="#[31f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;onebit
<LI><a href="#[31e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;compute_freq
</UL>
<BR>[Called By]<UL><LI><a href="#[2d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_iom_configure
</UL>

<P><STRONG><a name="[31e]"></a>compute_freq</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, am_hal_iom.o(.text.compute_freq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = compute_freq
</UL>
<BR>[Called By]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;iom_get_interface_clock_cfg
</UL>

<P><STRONG><a name="[31f]"></a>onebit</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, am_hal_iom.o(.text.onebit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = onebit
</UL>
<BR>[Called By]<UL><LI><a href="#[2d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;iom_get_interface_clock_cfg
</UL>

<P><STRONG><a name="[2df]"></a>device_info_get</STRONG> (Thumb, 316 bytes, Stack size 4 bytes, am_hal_mcuctrl.o(.text.device_info_get))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = device_info_get
</UL>
<BR>[Called By]<UL><LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_mcuctrl_info_get
</UL>

<P><STRONG><a name="[2e0]"></a>mcuctrl_fault_status</STRONG> (Thumb, 102 bytes, Stack size 8 bytes, am_hal_mcuctrl.o(.text.mcuctrl_fault_status))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = mcuctrl_fault_status
</UL>
<BR>[Called By]<UL><LI><a href="#[2de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_mcuctrl_info_get
</UL>

<P><STRONG><a name="[2e3]"></a>pwrctrl_periph_disable_msk_check</STRONG> (Thumb, 222 bytes, Stack size 16 bytes, am_hal_pwrctrl.o(.text.pwrctrl_periph_disable_msk_check))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = pwrctrl_periph_disable_msk_check
</UL>
<BR>[Called By]<UL><LI><a href="#[2a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_periph_disable
</UL>

<P><STRONG><a name="[2e2]"></a>simobuck_updates</STRONG> (Thumb, 160 bytes, Stack size 4 bytes, am_hal_pwrctrl.o(.text.simobuck_updates))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = simobuck_updates
</UL>
<BR>[Called By]<UL><LI><a href="#[b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_pwrctrl_low_power_init
</UL>

<P><STRONG><a name="[2e6]"></a>time_input_validate</STRONG> (Thumb, 296 bytes, Stack size 12 bytes, am_hal_rtc.o(.text.time_input_validate))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = time_input_validate
</UL>
<BR>[Called By]<UL><LI><a href="#[251]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_time_set
</UL>

<P><STRONG><a name="[2e4]"></a>dec_to_bcd</STRONG> (Thumb, 40 bytes, Stack size 4 bytes, am_hal_rtc.o(.text.dec_to_bcd))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = dec_to_bcd
</UL>
<BR>[Called By]<UL><LI><a href="#[24d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_alarm_set
<LI><a href="#[251]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_time_set
</UL>

<P><STRONG><a name="[2e5]"></a>bcd_to_dec</STRONG> (Thumb, 30 bytes, Stack size 4 bytes, am_hal_rtc.o(.text.bcd_to_dec))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = bcd_to_dec
</UL>
<BR>[Called By]<UL><LI><a href="#[24a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_rtc_time_get
</UL>

<P><STRONG><a name="[325]"></a>rtcRead</STRONG> (Thumb, 44 bytes, Stack size 24 bytes, periodicuplink.o(.text.rtcRead))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = rtcRead &rArr; am_devices_am1805_get_time &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_get_time
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[294]"></a>StartTxProcess</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, periodicuplink.o(.text.StartTxProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 276<LI>Call Chain = StartTxProcess &rArr; OnTxTimerEvent &rArr; TimerSetValue &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[6d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxTimerEvent
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInit
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[2a3]"></a>UplinkProcess</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, periodicuplink.o(.text.UplinkProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 1384 + Unknown Stack Size
<LI>Call Chain = UplinkProcess &rArr; PrepareTxFrame &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[1d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareTxFrame
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
</UL>
<BR>[Called By]<UL><LI><a href="#[320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;periodicUplink
</UL>

<P><STRONG><a name="[6d]"></a>OnTxTimerEvent</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, periodicuplink.o(.text.OnTxTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 252<LI>Call Chain = OnTxTimerEvent &rArr; TimerSetValue &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
</UL>
<BR>[Called By]<UL><LI><a href="#[294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StartTxProcess
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.text.StartTxProcess)
</UL>
<P><STRONG><a name="[1d1]"></a>PrepareTxFrame</STRONG> (Thumb, 238 bytes, Stack size 328 bytes, periodicuplink.o(.text.PrepareTxFrame))
<BR><BR>[Stack]<UL><LI>Max Depth = 1360 + Unknown Stack Size
<LI>Call Chain = PrepareTxFrame &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppGetSize
<LI><a href="#[11c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppCopy
<LI><a href="#[1db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppAddTimestamp
<LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGet
<LI><a href="#[1da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppAddCapVoltage
<LI><a href="#[1d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppAddCurrent
<LI><a href="#[1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppAddBusVoltage
<LI><a href="#[1d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppAddShuntVoltage
<LI><a href="#[1d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppAddRelativeHumidity
<LI><a href="#[1d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppAddTemperature
<LI><a href="#[1d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppAddPAR
<LI><a href="#[1d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;JalapenosLppReset
<LI><a href="#[1d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;measurementProcess
<LI><a href="#[5a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerDeviceTimeReq
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
<LI><a href="#[128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerIsBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[2a3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UplinkProcess
</UL>

<P><STRONG><a name="[9]"></a>OnMacProcessNotify</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, periodicuplink.o(.text.OnMacProcessNotify))
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[a]"></a>OnNvmDataChange</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, periodicuplink.o(.text.OnNvmDataChange))
<BR><BR>[Stack]<UL><LI>Max Depth = 392<LI>Call Chain = OnNvmDataChange &rArr; DisplayNvmDataChange &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNvmDataChange
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[b]"></a>OnNetworkParametersChange</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, periodicuplink.o(.text.OnNetworkParametersChange))
<BR><BR>[Stack]<UL><LI>Max Depth = 400<LI>Call Chain = OnNetworkParametersChange &rArr; DisplayNetworkParametersUpdate &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNetworkParametersUpdate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[c]"></a>OnMacMcpsRequest</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, periodicuplink.o(.text.OnMacMcpsRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 408<LI>Call Chain = OnMacMcpsRequest &rArr; DisplayMacMcpsRequestUpdate &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayMacMcpsRequestUpdate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[d]"></a>OnMacMlmeRequest</STRONG> (Thumb, 28 bytes, Stack size 24 bytes, periodicuplink.o(.text.OnMacMlmeRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 408<LI>Call Chain = OnMacMlmeRequest &rArr; DisplayMacMlmeRequestUpdate &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayMacMlmeRequestUpdate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[e]"></a>OnJoinRequest</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, periodicuplink.o(.text.OnJoinRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 1064 + Unknown Stack Size
<LI>Call Chain = OnJoinRequest &rArr; LmHandlerRequestClass &rArr; LmHandlerDeviceTimeReq &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerRequestClass
<LI><a href="#[e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayJoinRequestUpdate
<LI><a href="#[12b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerJoin
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[f]"></a>OnTxData</STRONG> (Thumb, 16 bytes, Stack size 16 bytes, periodicuplink.o(.text.OnTxData))
<BR><BR>[Stack]<UL><LI>Max Depth = 456<LI>Call Chain = OnTxData &rArr; DisplayTxUpdate &rArr; PrintHexBuffer &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayTxUpdate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[10]"></a>OnRxData</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, periodicuplink.o(.text.OnRxData))
<BR><BR>[Stack]<UL><LI>Max Depth = 440<LI>Call Chain = OnRxData &rArr; DisplayRxUpdate &rArr; PrintHexBuffer &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayRxUpdate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[11]"></a>OnClassChange</STRONG> (Thumb, 32 bytes, Stack size 24 bytes, periodicuplink.o(.text.OnClassChange))
<BR><BR>[Stack]<UL><LI>Max Depth = 1056 + Unknown Stack Size
<LI>Call Chain = OnClassChange &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayClassUpdate
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[12]"></a>OnBeaconStatusChange</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, periodicuplink.o(.text.OnBeaconStatusChange))
<BR><BR>[Stack]<UL><LI>Max Depth = 416<LI>Call Chain = OnBeaconStatusChange &rArr; DisplayBeaconUpdate &rArr; PrintHexBuffer &rArr; am_util_stdio_printf &rArr; am_util_stdio_vsprintf &rArr; ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayBeaconUpdate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[13]"></a>OnSysTimeUpdate</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, periodicuplink.o(.text.OnSysTimeUpdate))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = OnSysTimeUpdate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmHandlerCallbacks)
</UL>
<P><STRONG><a name="[1a]"></a>OnTxPeriodicityChanged</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, periodicuplink.o(.text.OnTxPeriodicityChanged))
<BR><BR>[Stack]<UL><LI>Max Depth = 252<LI>Call Chain = OnTxPeriodicityChanged &rArr; TimerSetValue &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[147]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randr
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmhpComplianceParams)
</UL>
<P><STRONG><a name="[1b]"></a>OnTxFrameCtrlChanged</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, periodicuplink.o(.text.OnTxFrameCtrlChanged))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = OnTxFrameCtrlChanged
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmhpComplianceParams)
</UL>
<P><STRONG><a name="[1c]"></a>OnPingSlotPeriodicityChanged</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, periodicuplink.o(.text.OnPingSlotPeriodicityChanged))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = OnPingSlotPeriodicityChanged
</UL>
<BR>[Address Reference Count : 1]<UL><LI> periodicuplink.o(.data.LmhpComplianceParams)
</UL>
<P><STRONG><a name="[310]"></a>__NVIC_EnableIRQ</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, adc.o(.text.__NVIC_EnableIRQ))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __NVIC_EnableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
</UL>

<P><STRONG><a name="[311]"></a>__NVIC_SetPriority</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, adc.o(.text.__NVIC_SetPriority))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __NVIC_SetPriority
</UL>
<BR>[Called By]<UL><LI><a href="#[30e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;getAdcSample
</UL>

<P><STRONG><a name="[2bb]"></a>bcd_to_dec</STRONG> (Thumb, 30 bytes, Stack size 4 bytes, am1805.o(.text.bcd_to_dec))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = bcd_to_dec
</UL>
<BR>[Called By]<UL><LI><a href="#[297]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_get_time
</UL>

<P><STRONG><a name="[2bc]"></a>dec_to_bcd</STRONG> (Thumb, 40 bytes, Stack size 4 bytes, am1805.o(.text.dec_to_bcd))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = dec_to_bcd
</UL>
<BR>[Called By]<UL><LI><a href="#[299]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_devices_am1805_set_time
</UL>

<P><STRONG><a name="[25e]"></a>SHTC3_ReadBytesAndCrc</STRONG> (Thumb, 202 bytes, Stack size 64 bytes, shtc3.o(.text.SHTC3_ReadBytesAndCrc))
<BR><BR>[Stack]<UL><LI>Max Depth = 336<LI>Call Chain = SHTC3_ReadBytesAndCrc &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[262]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_CheckCrc
<LI><a href="#[261]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_device_command_read
</UL>
<BR>[Called By]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_GetTempAndHumi
</UL>

<P><STRONG><a name="[25f]"></a>SHTC3_CalcTemperature</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, shtc3.o(.text.SHTC3_CalcTemperature))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SHTC3_CalcTemperature
</UL>
<BR>[Called By]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_GetTempAndHumi
</UL>

<P><STRONG><a name="[260]"></a>SHTC3_CalcHumidity</STRONG> (Thumb, 40 bytes, Stack size 4 bytes, shtc3.o(.text.SHTC3_CalcHumidity))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SHTC3_CalcHumidity
</UL>
<BR>[Called By]<UL><LI><a href="#[25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_GetTempAndHumi
</UL>

<P><STRONG><a name="[262]"></a>SHTC3_CheckCrc</STRONG> (Thumb, 182 bytes, Stack size 16 bytes, shtc3.o(.text.SHTC3_CheckCrc))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = SHTC3_CheckCrc
</UL>
<BR>[Called By]<UL><LI><a href="#[25e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SHTC3_ReadBytesAndCrc
</UL>

<P><STRONG><a name="[31d]"></a>__NVIC_EnableIRQ</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, taskhandler.o(.text.__NVIC_EnableIRQ))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __NVIC_EnableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;initSpecMeasurement
</UL>

<P><STRONG><a name="[28e]"></a>SpectrometerMeasurement</STRONG> (Thumb, 160 bytes, Stack size 24 bytes, taskhandler.o(.text.SpectrometerMeasurement))
<BR><BR>[Stack]<UL><LI>Max Depth = 448<LI>Call Chain = SpectrometerMeasurement &rArr; as7341_transmitMeasurementsFIFO &rArr; as7341_readRegister &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[293]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_stopMeasuring
<LI><a href="#[28f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_setGain
<LI><a href="#[292]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_transmitMeasurementsFIFO
<LI><a href="#[291]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_startMeasurement
<LI><a href="#[290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;as7341_writeSMUXmapping
<LI><a href="#[c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_hal_sysctrl_sleep
</UL>
<BR>[Called By]<UL><LI><a href="#[306]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;executeSpecMeasurement
</UL>

<P><STRONG><a name="[32b]"></a>__NVIC_EnableIRQ</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, timing.o(.text.__NVIC_EnableIRQ))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __NVIC_EnableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
</UL>

<P><STRONG><a name="[2ec]"></a>__NVIC_DisableIRQ</STRONG> (Thumb, 56 bytes, Stack size 4 bytes, timing.o(.text.__NVIC_DisableIRQ))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __NVIC_DisableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[4e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_stimer_cmpr5_isr
<LI><a href="#[c1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;timerDelay
</UL>

<P><STRONG><a name="[2f1]"></a>decstr_to_int</STRONG> (Thumb, 166 bytes, Stack size 28 bytes, am_util_stdio.o(.text.decstr_to_int))
<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = decstr_to_int
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[2f2]"></a>simple_strlen</STRONG> (Thumb, 54 bytes, Stack size 12 bytes, am_util_stdio.o(.text.simple_strlen))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = simple_strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[2f3]"></a>padbuffer</STRONG> (Thumb, 80 bytes, Stack size 20 bytes, am_util_stdio.o(.text.padbuffer))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = padbuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[2f4]"></a>ndigits_in_hex</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, am_util_stdio.o(.text.ndigits_in_hex))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ndigits_in_hex
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[2f5]"></a>uint64_to_hexstr</STRONG> (Thumb, 192 bytes, Stack size 48 bytes, am_util_stdio.o(.text.uint64_to_hexstr))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = uint64_to_hexstr
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[2f6]"></a>ndigits_in_u64</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, am_util_stdio.o(.text.ndigits_in_u64))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ndigits_in_u64 &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;divu64_10
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
<LI><a href="#[2f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_i64
</UL>

<P><STRONG><a name="[2f7]"></a>uint64_to_str</STRONG> (Thumb, 136 bytes, Stack size 72 bytes, am_util_stdio.o(.text.uint64_to_str))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;divu64_10
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
<LI><a href="#[2f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ftoa
</UL>

<P><STRONG><a name="[2f8]"></a>ndigits_in_i64</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, am_util_stdio.o(.text.ndigits_in_i64))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = ndigits_in_i64 &rArr; ndigits_in_u64 &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_u64
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[2f9]"></a>ftoa</STRONG> (Thumb, 560 bytes, Stack size 72 bytes, am_util_stdio.o(.text.ftoa))
<BR><BR>[Stack]<UL><LI>Max Depth = 192<LI>Call Chain = ftoa &rArr; uint64_to_str &rArr; divu64_10
</UL>
<BR>[Calls]<UL><LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uint64_to_str
</UL>
<BR>[Called By]<UL><LI><a href="#[2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;am_util_stdio_vsprintf
</UL>

<P><STRONG><a name="[324]"></a>divu64_10</STRONG> (Thumb, 280 bytes, Stack size 48 bytes, am_util_stdio.o(.text.divu64_10))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = divu64_10
</UL>
<BR>[Called By]<UL><LI><a href="#[2f7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;uint64_to_str
<LI><a href="#[2f6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ndigits_in_u64
</UL>

<P><STRONG><a name="[c7]"></a>__NVIC_SystemReset</STRONG> (Thumb, 38 bytes, Stack size 0 bytes, board.o(.text.__NVIC_SystemReset))
<BR><BR>[Called By]<UL><LI><a href="#[c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardResetMcu
</UL>

<P><STRONG><a name="[254]"></a>__NVIC_EnableIRQ</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, rtc-board.o(.text.__NVIC_EnableIRQ))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __NVIC_EnableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[256]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcStartAlarm
<LI><a href="#[ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcInit
</UL>

<P><STRONG><a name="[274]"></a>__NVIC_EnableIRQ</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, sx126x-board.o(.text.__NVIC_EnableIRQ))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __NVIC_EnableIRQ
</UL>
<BR>[Called By]<UL><LI><a href="#[26e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xIoIrqInit
</UL>

<P><STRONG><a name="[17e]"></a>LoRaMacHandleIrqEvents</STRONG> (Thumb, 136 bytes, Stack size 24 bytes, loramac.o(.text.LoRaMacHandleIrqEvents))
<BR><BR>[Stack]<UL><LI>Max Depth = 1216 + Unknown Stack Size
<LI>Call Chain = LoRaMacHandleIrqEvents &rArr; ProcessRadioRxDone &rArr; LoRaMacCryptoUnsecureMessage &rArr; VerifyCmacB0 &rArr; SecureElementVerifyAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxTimeout
<LI><a href="#[182]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxError
<LI><a href="#[181]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxTimeout
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
<LI><a href="#[17f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxDone
</UL>
<BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[18d]"></a>LoRaMacEnableRequests</STRONG> (Thumb, 26 bytes, Stack size 4 bytes, loramac.o(.text.LoRaMacEnableRequests))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = LoRaMacEnableRequests
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
<LI><a href="#[18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleRequestEvents
</UL>

<P><STRONG><a name="[1b5]"></a>LoRaMacCheckForRxAbort</STRONG> (Thumb, 56 bytes, Stack size 0 bytes, loramac.o(.text.LoRaMacCheckForRxAbort))
<BR><BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[1b6]"></a>IsRequestPending</STRONG> (Thumb, 64 bytes, Stack size 4 bytes, loramac.o(.text.IsRequestPending))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsRequestPending
</UL>
<BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[14e]"></a>LoRaMacCheckForBeaconAcquisition</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, loramac.o(.text.LoRaMacCheckForBeaconAcquisition))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = LoRaMacCheckForBeaconAcquisition &rArr; LoRaMacConfirmQueueIsCmdActive &rArr; GetElement &rArr; IsListEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueIsCmdActive
</UL>
<BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[186]"></a>LoRaMacHandleMlmeRequest</STRONG> (Thumb, 134 bytes, Stack size 8 bytes, loramac.o(.text.LoRaMacHandleMlmeRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = LoRaMacHandleMlmeRequest &rArr; LoRaMacConfirmQueueIsCmdActive &rArr; GetElement &rArr; IsListEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueIsCmdActive
</UL>
<BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[184]"></a>LoRaMacHandleMcpsRequest</STRONG> (Thumb, 234 bytes, Stack size 16 bytes, loramac.o(.text.LoRaMacHandleMcpsRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 872<LI>Call Chain = LoRaMacHandleMcpsRequest &rArr; OnTxDelayedTimerEvent &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxDelayedTimerEvent
<LI><a href="#[185]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StopRetransmission
<LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckRetransConfirmedUplink
<LI><a href="#[d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckRetransUnconfirmedUplink
</UL>
<BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[18c]"></a>LoRaMacHandleRequestEvents</STRONG> (Thumb, 242 bytes, Stack size 16 bytes, loramac.o(.text.LoRaMacHandleRequestEvents))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = LoRaMacHandleRequestEvents &rArr; LoRaMacConfirmQueueHandleCb &rArr; LoRaMacConfirmQueueAdd &rArr; IncreaseBufferPointer
</UL>
<BR>[Calls]<UL><LI><a href="#[18f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBResumeBeaconing
<LI><a href="#[18e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueGetCnt
<LI><a href="#[15e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueHandleCb
<LI><a href="#[18d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacEnableRequests
</UL>
<BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[1b7]"></a>LoRaMacHandleIndicationEvents</STRONG> (Thumb, 112 bytes, Stack size 8 bytes, loramac.o(.text.LoRaMacHandleIndicationEvents))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LoRaMacHandleIndicationEvents
</UL>
<BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[18a]"></a>LoRaMacHandleRejoinEvents</STRONG> (Thumb, 212 bytes, Stack size 32 bytes, loramac.o(.text.LoRaMacHandleRejoinEvents))
<BR><BR>[Stack]<UL><LI>Max Depth = 984 + Unknown Stack Size
<LI>Call Chain = LoRaMacHandleRejoinEvents &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
<LI><a href="#[18b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsReJoin0Required
</UL>
<BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[1a9]"></a>OpenContinuousRxCWindow</STRONG> (Thumb, 136 bytes, Stack size 24 bytes, loramac.o(.text.OpenContinuousRxCWindow))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = OpenContinuousRxCWindow &rArr; RegionComputeRxWindowParameters &rArr; RegionEU868ComputeRxWindowParameters &rArr; RegionCommonComputeRxWindowParameters
</UL>
<BR>[Calls]<UL><LI><a href="#[1c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionRxConfig
<LI><a href="#[db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionComputeRxWindowParameters
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
<LI><a href="#[1a5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SwitchClass
</UL>

<P><STRONG><a name="[187]"></a>LoRaMacHandleNvm</STRONG> (Thumb, 384 bytes, Stack size 24 bytes, loramac.o(.text.LoRaMacHandleNvm))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = LoRaMacHandleNvm &rArr; Crc32
</UL>
<BR>[Calls]<UL><LI><a href="#[188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Crc32
<LI><a href="#[189]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CallNvmDataChangeCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[137]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacProcess
</UL>

<P><STRONG><a name="[17f]"></a>ProcessRadioTxDone</STRONG> (Thumb, 360 bytes, Stack size 104 bytes, loramac.o(.text.ProcessRadioTxDone))
<BR><BR>[Stack]<UL><LI>Max Depth = 340<LI>Call Chain = ProcessRadioTxDone &rArr; TimerSetValue &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[1f1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionSetBandTxDone
<LI><a href="#[142]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetCurrentTime
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetPhyParam
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSub
<LI><a href="#[193]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGetMcuTime
</UL>
<BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleIrqEvents
</UL>

<P><STRONG><a name="[180]"></a>ProcessRadioRxDone</STRONG> (Thumb, 3186 bytes, Stack size 248 bytes, loramac.o(.text.ProcessRadioRxDone))
<BR><BR>[Stack]<UL><LI>Max Depth = 1192 + Unknown Stack Size
<LI>Call Chain = ProcessRadioRxDone &rArr; LoRaMacCryptoUnsecureMessage &rArr; VerifyCmacB0 &rArr; SecureElementVerifyAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoUnsecureMessage
<LI><a href="#[1ee]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSetFPendingBit
<LI><a href="#[17b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacParserData
<LI><a href="#[1ed]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionApplyCFList
<LI><a href="#[162]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueSetStatus
<LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
<LI><a href="#[117]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBMulticastSlotTimerEvent
<LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSetMulticastSlotState
<LI><a href="#[cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsMulticastExpected
<LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBPingSlotTimerEvent
<LI><a href="#[114]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSetPingSlotState
<LI><a href="#[cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsPingExpected
<LI><a href="#[1ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBRxBeacon
<LI><a href="#[19b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionVerify
<LI><a href="#[1ef]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DetermineFrameType
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetPhyParam
<LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsAddCmd
<LI><a href="#[1a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementGetJoinEui
<LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueIsCmdActive
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[1f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RemoveMacCommands
<LI><a href="#[10b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetFCntDown
<LI><a href="#[1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareRxDoneAbort
<LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateRxSlotIdleState
<LI><a href="#[61]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRetransmitTimeoutTimerEvent
<LI><a href="#[192]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ResetMacParameters
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleIrqEvents
</UL>

<P><STRONG><a name="[181]"></a>ProcessRadioTxTimeout</STRONG> (Thumb, 112 bytes, Stack size 16 bytes, loramac.o(.text.ProcessRadioTxTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = ProcessRadioTxTimeout &rArr; LoRaMacConfirmQueueSetStatusCmn &rArr; IsListEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueSetStatusCmn
<LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateRxSlotIdleState
</UL>
<BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleIrqEvents
</UL>

<P><STRONG><a name="[182]"></a>ProcessRadioRxError</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, loramac.o(.text.ProcessRadioRxError))
<BR><BR>[Stack]<UL><LI>Max Depth = 244<LI>Call Chain = ProcessRadioRxError &rArr; HandleRadioRxErrorTimeout &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleIrqEvents
</UL>

<P><STRONG><a name="[183]"></a>ProcessRadioRxTimeout</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, loramac.o(.text.ProcessRadioRxTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 244<LI>Call Chain = ProcessRadioRxTimeout &rArr; HandleRadioRxErrorTimeout &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[17e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleIrqEvents
</UL>

<P><STRONG><a name="[d0]"></a>CheckRetransUnconfirmedUplink</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, loramac.o(.text.CheckRetransUnconfirmedUplink))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = CheckRetransUnconfirmedUplink &rArr; CheckRetrans
</UL>
<BR>[Calls]<UL><LI><a href="#[cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckRetrans
</UL>
<BR>[Called By]<UL><LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleMcpsRequest
</UL>

<P><STRONG><a name="[ce]"></a>CheckRetransConfirmedUplink</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, loramac.o(.text.CheckRetransConfirmedUplink))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = CheckRetransConfirmedUplink &rArr; CheckRetrans
</UL>
<BR>[Calls]<UL><LI><a href="#[cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckRetrans
</UL>
<BR>[Called By]<UL><LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleMcpsRequest
</UL>

<P><STRONG><a name="[185]"></a>StopRetransmission</STRONG> (Thumb, 280 bytes, Stack size 16 bytes, loramac.o(.text.StopRetransmission))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = StopRetransmission &rArr; LoRaMacCommandsGetCmd
</UL>
<BR>[Calls]<UL><LI><a href="#[1df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsGetCmd
<LI><a href="#[295]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IncreaseAdrAckCounter
</UL>
<BR>[Called By]<UL><LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxDelayedTimerEvent
<LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleMcpsRequest
</UL>

<P><STRONG><a name="[5e]"></a>OnTxDelayedTimerEvent</STRONG> (Thumb, 132 bytes, Stack size 24 bytes, loramac.o(.text.OnTxDelayedTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 856<LI>Call Chain = OnTxDelayedTimerEvent &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueSetStatusCmn
<LI><a href="#[190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleResponseTimeout
<LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
<LI><a href="#[185]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StopRetransmission
</UL>
<BR>[Called By]<UL><LI><a href="#[184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleMcpsRequest
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[18b]"></a>IsReJoin0Required</STRONG> (Thumb, 92 bytes, Stack size 4 bytes, loramac.o(.text.IsReJoin0Required))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsReJoin0Required
</UL>
<BR>[Called By]<UL><LI><a href="#[18a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleRejoinEvents
</UL>

<P><STRONG><a name="[189]"></a>CallNvmDataChangeCallback</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, loramac.o(.text.CallNvmDataChangeCallback))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CallNvmDataChangeCallback
</UL>
<BR>[Called By]<UL><LI><a href="#[187]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacHandleNvm
</UL>

<P><STRONG><a name="[1c6]"></a>ScheduleTx</STRONG> (Thumb, 418 bytes, Stack size 64 bytes, loramac.o(.text.ScheduleTx))
<BR><BR>[Stack]<UL><LI>Max Depth = 832<LI>Call Chain = ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendFrameOnChannel
<LI><a href="#[243]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionNextChannel
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSub
<LI><a href="#[193]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGetMcuTime
<LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyTxFrame
<LI><a href="#[d9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeRxWindowParameters
<LI><a href="#[282]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SerializeTxFrame
<LI><a href="#[281]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalculateBackOff
<LI><a href="#[ca]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckForClassBCollision
</UL>
<BR>[Called By]<UL><LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendReJoinReq
<LI><a href="#[19e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Send
<LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxDelayedTimerEvent
</UL>

<P><STRONG><a name="[10d]"></a>GetMaxAppPayloadWithoutFOptsLength</STRONG> (Thumb, 64 bytes, Stack size 24 bytes, loramac.o(.text.GetMaxAppPayloadWithoutFOptsLength))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = GetMaxAppPayloadWithoutFOptsLength &rArr; RegionGetPhyParam &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetPhyParam
</UL>
<BR>[Called By]<UL><LI><a href="#[13b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacQueryTxPossible
<LI><a href="#[1ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareFrame
<LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ValidatePayloadLength
</UL>

<P><STRONG><a name="[ca]"></a>CheckForClassBCollision</STRONG> (Thumb, 90 bytes, Stack size 16 bytes, loramac.o(.text.CheckForClassBCollision))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CheckForClassBCollision
</UL>
<BR>[Calls]<UL><LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsBeaconExpected
<LI><a href="#[cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsMulticastExpected
<LI><a href="#[cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsPingExpected
</UL>
<BR>[Called By]<UL><LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
</UL>

<P><STRONG><a name="[281]"></a>CalculateBackOff</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, loramac.o(.text.CalculateBackOff))
<BR><BR>[Called By]<UL><LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
</UL>

<P><STRONG><a name="[282]"></a>SerializeTxFrame</STRONG> (Thumb, 270 bytes, Stack size 16 bytes, loramac.o(.text.SerializeTxFrame))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = SerializeTxFrame &rArr; LoRaMacSerializerData &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[177]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerData
<LI><a href="#[172]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerReJoinType0or2
<LI><a href="#[174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerReJoinType1
<LI><a href="#[170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacSerializerJoinRequest
</UL>
<BR>[Called By]<UL><LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
</UL>

<P><STRONG><a name="[d9]"></a>ComputeRxWindowParameters</STRONG> (Thumb, 194 bytes, Stack size 24 bytes, loramac.o(.text.ComputeRxWindowParameters))
<BR><BR>[Stack]<UL><LI>Max Depth = 144<LI>Call Chain = ComputeRxWindowParameters &rArr; RegionComputeRxWindowParameters &rArr; RegionEU868ComputeRxWindowParameters &rArr; RegionCommonComputeRxWindowParameters
</UL>
<BR>[Calls]<UL><LI><a href="#[da]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionApplyDrOffset
<LI><a href="#[db]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionComputeRxWindowParameters
</UL>
<BR>[Called By]<UL><LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
</UL>

<P><STRONG><a name="[283]"></a>VerifyTxFrame</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, loramac.o(.text.VerifyTxFrame))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = VerifyTxFrame &rArr; ValidatePayloadLength &rArr; GetMaxAppPayloadWithoutFOptsLength &rArr; RegionGetPhyParam &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[15b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsGetSizeSerializedCmds
<LI><a href="#[2a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ValidatePayloadLength
</UL>
<BR>[Called By]<UL><LI><a href="#[1c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ScheduleTx
</UL>

<P><STRONG><a name="[1a5]"></a>SwitchClass</STRONG> (Thumb, 640 bytes, Stack size 24 bytes, loramac.o(.text.SwitchClass))
<BR><BR>[Stack]<UL><LI>Max Depth = 168<LI>Call Chain = SwitchClass &rArr; OpenContinuousRxCWindow &rArr; RegionComputeRxWindowParameters &rArr; RegionEU868ComputeRxWindowParameters &rArr; RegionCommonComputeRxWindowParameters
</UL>
<BR>[Calls]<UL><LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsAddCmd
<LI><a href="#[296]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSwitchClass
<LI><a href="#[1a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OpenContinuousRxCWindow
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendReJoinReq
</UL>

<P><STRONG><a name="[287]"></a>SecureFrame</STRONG> (Thumb, 344 bytes, Stack size 24 bytes, loramac.o(.text.SecureFrame))
<BR><BR>[Stack]<UL><LI>Max Depth = 712<LI>Call Chain = SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSecureMessage
<LI><a href="#[171]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareReJoinType0or2
<LI><a href="#[173]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareReJoinType1
<LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareJoinRequest
<LI><a href="#[1cf]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoGetFCntUp
</UL>
<BR>[Called By]<UL><LI><a href="#[284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendFrameOnChannel
</UL>

<P><STRONG><a name="[192]"></a>ResetMacParameters</STRONG> (Thumb, 498 bytes, Stack size 96 bytes, loramac.o(.text.ResetMacParameters))
<BR><BR>[Stack]<UL><LI>Max Depth = 332 + Unknown Stack Size
<LI>Call Chain = ResetMacParameters &rArr; RegionInitDefaults &rArr; RegionEU868InitDefaults &rArr; memcpy1
</UL>
<BR>[Calls]<UL><LI><a href="#[247]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBInit
<LI><a href="#[14d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionInitDefaults
</UL>
<BR>[Called By]<UL><LI><a href="#[123]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacInitialization
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[5f]"></a>OnRxWindow1TimerEvent</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, loramac.o(.text.OnRxWindow1TimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 244<LI>Call Chain = OnRxWindow1TimerEvent &rArr; RxWindowSetup &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[1c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RxWindowSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[60]"></a>OnRxWindow2TimerEvent</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, loramac.o(.text.OnRxWindow2TimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 244<LI>Call Chain = OnRxWindow2TimerEvent &rArr; RxWindowSetup &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[1c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RxWindowSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[61]"></a>OnRetransmitTimeoutTimerEvent</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, loramac.o(.text.OnRetransmitTimeoutTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 228<LI>Call Chain = OnRetransmitTimeoutTimerEvent &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Called By]<UL><LI><a href="#[1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareRxDoneAbort
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[62]"></a>OnRejoin0CycleTimerEvent</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, loramac.o(.text.OnRejoin0CycleTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 260<LI>Call Chain = OnRejoin0CycleTimerEvent &rArr; TimerSetValue &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[1ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertRejoinCycleTime
<LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[63]"></a>OnRejoin1CycleTimerEvent</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, loramac.o(.text.OnRejoin1CycleTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 260<LI>Call Chain = OnRejoin1CycleTimerEvent &rArr; TimerSetValue &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[1ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertRejoinCycleTime
<LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[64]"></a>OnForceRejoinReqCycleTimerEvent</STRONG> (Thumb, 174 bytes, Stack size 16 bytes, loramac.o(.text.OnForceRejoinReqCycleTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 252<LI>Call Chain = OnForceRejoinReqCycleTimerEvent &rArr; TimerSetValue &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Called By]<UL><LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[65]"></a>OnRadioTxDone</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, loramac.o(.text.OnRadioTxDone))
<BR><BR>[Stack]<UL><LI>Max Depth = 432<LI>Call Chain = OnRadioTxDone &rArr; SysTimeGet &rArr; am_devices_am1805_get_time &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGet
<LI><a href="#[142]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetCurrentTime
<LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[66]"></a>OnRadioRxDone</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, loramac.o(.text.OnRadioRxDone))
<BR><BR>[Stack]<UL><LI>Max Depth = 108<LI>Call Chain = OnRadioRxDone &rArr; TimerGetCurrentTime &rArr; RtcGetTimerValue &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[142]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetCurrentTime
<LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[67]"></a>OnRadioRxError</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, loramac.o(.text.OnRadioRxError))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = OnRadioRxError &rArr; OnMacProcessNotify
</UL>
<BR>[Calls]<UL><LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[68]"></a>OnRadioTxTimeout</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, loramac.o(.text.OnRadioTxTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = OnRadioTxTimeout &rArr; OnMacProcessNotify
</UL>
<BR>[Calls]<UL><LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[69]"></a>OnRadioRxTimeout</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, loramac.o(.text.OnRadioRxTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = OnRadioRxTimeout &rArr; OnMacProcessNotify
</UL>
<BR>[Calls]<UL><LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.LoRaMacInitialization)
</UL>
<P><STRONG><a name="[190]"></a>LoRaMacHandleResponseTimeout</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, loramac.o(.text.LoRaMacHandleResponseTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 116<LI>Call Chain = LoRaMacHandleResponseTimeout &rArr; TimerGetElapsedTime &rArr; RtcGetTimerValue &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetElapsedTime
</UL>
<BR>[Called By]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcpsRequest
<LI><a href="#[5e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnTxDelayedTimerEvent
</UL>

<P><STRONG><a name="[1c5]"></a>RxWindowSetup</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, loramac.o(.text.RxWindowSetup))
<BR><BR>[Stack]<UL><LI>Max Depth = 228<LI>Call Chain = RxWindowSetup &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[1c7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionRxConfig
</UL>
<BR>[Called By]<UL><LI><a href="#[60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRxWindow2TimerEvent
<LI><a href="#[5f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRxWindow1TimerEvent
</UL>

<P><STRONG><a name="[1c4]"></a>OnMacProcessNotify</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, loramac.o(.text.OnMacProcessNotify))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = OnMacProcessNotify
</UL>
<BR>[Called By]<UL><LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnAbpJoinPendingTimerEvent
<LI><a href="#[69]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRadioRxTimeout
<LI><a href="#[68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRadioTxTimeout
<LI><a href="#[67]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRadioRxError
<LI><a href="#[66]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRadioRxDone
<LI><a href="#[65]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRadioTxDone
<LI><a href="#[64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnForceRejoinReqCycleTimerEvent
<LI><a href="#[63]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin1CycleTimerEvent
<LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin0CycleTimerEvent
<LI><a href="#[61]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRetransmitTimeoutTimerEvent
</UL>

<P><STRONG><a name="[1ad]"></a>ConvertRejoinCycleTime</STRONG> (Thumb, 58 bytes, Stack size 12 bytes, loramac.o(.text.ConvertRejoinCycleTime))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = ConvertRejoinCycleTime
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[1dd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessMacCommands
<LI><a href="#[63]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin1CycleTimerEvent
<LI><a href="#[62]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRejoin0CycleTimerEvent
</UL>

<P><STRONG><a name="[11a]"></a>UpdateRxSlotIdleState</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, loramac.o(.text.UpdateRxSlotIdleState))
<BR><BR>[Called By]<UL><LI><a href="#[127]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacStart
<LI><a href="#[111]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HandleRadioRxErrorTimeout
<LI><a href="#[1d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareRxDoneAbort
<LI><a href="#[181]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioTxTimeout
<LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[1a2]"></a>GetNvmData</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, loramac.o(.text.GetNvmData))
<BR><BR>[Called By]<UL><LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
</UL>

<P><STRONG><a name="[1ab]"></a>RestoreNvmData</STRONG> (Thumb, 496 bytes, Stack size 24 bytes, loramac.o(.text.RestoreNvmData))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = RestoreNvmData &rArr; Crc32
</UL>
<BR>[Calls]<UL><LI><a href="#[188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Crc32
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>

<P><STRONG><a name="[ae]"></a>AbpJoinPendingStart</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, loramac.o(.text.AbpJoinPendingStart))
<BR><BR>[Stack]<UL><LI>Max Depth = 252<LI>Call Chain = AbpJoinPendingStart &rArr; TimerSetValue &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInit
</UL>
<BR>[Called By]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>

<P><STRONG><a name="[53]"></a>OnAbpJoinPendingTimerEvent</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, loramac.o(.text.OnAbpJoinPendingTimerEvent))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = OnAbpJoinPendingTimerEvent &rArr; OnMacProcessNotify
</UL>
<BR>[Calls]<UL><LI><a href="#[1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnMacProcessNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> loramac.o(.text.AbpJoinPendingStart)
</UL>
<P><STRONG><a name="[19d]"></a>CheckForMinimumAbpDatarate</STRONG> (Thumb, 68 bytes, Stack size 4 bytes, loramac.o(.text.CheckForMinimumAbpDatarate))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = CheckForMinimumAbpDatarate
</UL>
<BR>[Called By]<UL><LI><a href="#[13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcpsRequest
</UL>

<P><STRONG><a name="[1d0]"></a>PrepareRxDoneAbort</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, loramac.o(.text.PrepareRxDoneAbort))
<BR><BR>[Stack]<UL><LI>Max Depth = 236<LI>Call Chain = PrepareRxDoneAbort &rArr; OnRetransmitTimeoutTimerEvent &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateRxSlotIdleState
<LI><a href="#[61]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnRetransmitTimeoutTimerEvent
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[10b]"></a>GetFCntDown</STRONG> (Thumb, 198 bytes, Stack size 32 bytes, loramac.o(.text.GetFCntDown))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = GetFCntDown &rArr; LoRaMacCryptoGetFCntDown &rArr; GetLastFcntDown
</UL>
<BR>[Calls]<UL><LI><a href="#[10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoGetFCntDown
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[1f0]"></a>RemoveMacCommands</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, loramac.o(.text.RemoveMacCommands))
<BR><BR>[Stack]<UL><LI>Max Depth = 100<LI>Call Chain = RemoveMacCommands &rArr; LoRaMacCommandsRemoveStickyAnsCmds &rArr; LoRaMacCommandsRemoveCmd &rArr; LinkedListRemove &rArr; LinkedListGetPrevious
</UL>
<BR>[Calls]<UL><LI><a href="#[159]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveStickyAnsCmds
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[1dd]"></a>ProcessMacCommands</STRONG> (Thumb, 3074 bytes, Stack size 264 bytes, loramac.o(.text.ProcessMacCommands))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProcessMacCommands &rArr; SysTimeGet &rArr; am_devices_am1805_get_time &rArr; am_device_command_read &rArr; am_hal_iom_blocking_transfer &rArr; internal_iom_reset_on_error &rArr; am_hal_flash_delay
</UL>
<BR>[Calls]<UL><LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGet
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[147]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randr
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[1eb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBBeaconFreqReq
<LI><a href="#[1ea]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBBeaconTimingAns
<LI><a href="#[1e9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBPingSlotChannelReq
<LI><a href="#[1e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBPingSlotInfoAns
<LI><a href="#[1e7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBDeviceTimeAns
<LI><a href="#[140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSet
<LI><a href="#[1e6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeAdd
<LI><a href="#[1e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionDlChannelReq
<LI><a href="#[1e3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionTxParamSetupReq
<LI><a href="#[1e2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionNewChannelReq
<LI><a href="#[1e1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionRxParamSetupReq
<LI><a href="#[1e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionLinkAdrReq
<LI><a href="#[157]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveCmd
<LI><a href="#[1df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsGetCmd
<LI><a href="#[1de]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsGetCmdSize
<LI><a href="#[162]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueSetStatus
<LI><a href="#[10e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionGetPhyParam
<LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsAddCmd
<LI><a href="#[1e5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSub
<LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueIsCmdActive
<LI><a href="#[1ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertRejoinCycleTime
<LI><a href="#[64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnForceRejoinReqCycleTimerEvent
</UL>
<BR>[Called By]<UL><LI><a href="#[180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxDone
</UL>

<P><STRONG><a name="[111]"></a>HandleRadioRxErrorTimeout</STRONG> (Thumb, 374 bytes, Stack size 24 bytes, loramac.o(.text.HandleRadioRxErrorTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 236<LI>Call Chain = HandleRadioRxErrorTimeout &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[cb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsBeaconExpected
<LI><a href="#[117]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBMulticastSlotTimerEvent
<LI><a href="#[116]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSetMulticastSlotState
<LI><a href="#[cd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsMulticastExpected
<LI><a href="#[115]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBPingSlotTimerEvent
<LI><a href="#[114]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSetPingSlotState
<LI><a href="#[cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBIsPingExpected
<LI><a href="#[119]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetElapsedTime
<LI><a href="#[113]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBBeaconTimerEvent
<LI><a href="#[112]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacClassBSetBeaconState
<LI><a href="#[118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueSetStatusCmn
<LI><a href="#[11a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateRxSlotIdleState
</UL>
<BR>[Called By]<UL><LI><a href="#[183]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxTimeout
<LI><a href="#[182]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcessRadioRxError
</UL>

<P><STRONG><a name="[cf]"></a>CheckRetrans</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, loramac.o(.text.CheckRetrans))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = CheckRetrans
</UL>
<BR>[Called By]<UL><LI><a href="#[ce]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckRetransConfirmedUplink
<LI><a href="#[d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckRetransUnconfirmedUplink
</UL>

<P><STRONG><a name="[295]"></a>IncreaseAdrAckCounter</STRONG> (Thumb, 26 bytes, Stack size 4 bytes, loramac.o(.text.IncreaseAdrAckCounter))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IncreaseAdrAckCounter
</UL>
<BR>[Called By]<UL><LI><a href="#[185]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StopRetransmission
</UL>

<P><STRONG><a name="[2a4]"></a>ValidatePayloadLength</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, loramac.o(.text.ValidatePayloadLength))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = ValidatePayloadLength &rArr; GetMaxAppPayloadWithoutFOptsLength &rArr; RegionGetPhyParam &rArr; RegionEU868GetPhyParam &rArr; RegionCommonGetNextLowerTxDr &rArr; RegionCommonChanVerifyDr &rArr; RegionCommonValueInRange
</UL>
<BR>[Calls]<UL><LI><a href="#[10d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetMaxAppPayloadWithoutFOptsLength
</UL>
<BR>[Called By]<UL><LI><a href="#[283]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyTxFrame
</UL>

<P><STRONG><a name="[156]"></a>LinkedListInit</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, loramaccommands.o(.text.LinkedListInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LinkedListInit
</UL>
<BR>[Called By]<UL><LI><a href="#[155]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsInit
</UL>

<P><STRONG><a name="[151]"></a>MallocNewMacCommandSlot</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, loramaccommands.o(.text.MallocNewMacCommandSlot))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = MallocNewMacCommandSlot &rArr; IsSlotFree
</UL>
<BR>[Calls]<UL><LI><a href="#[1b9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsSlotFree
</UL>
<BR>[Called By]<UL><LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsAddCmd
</UL>

<P><STRONG><a name="[152]"></a>LinkedListAdd</STRONG> (Thumb, 88 bytes, Stack size 12 bytes, loramaccommands.o(.text.LinkedListAdd))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = LinkedListAdd
</UL>
<BR>[Called By]<UL><LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsAddCmd
</UL>

<P><STRONG><a name="[153]"></a>IsSticky</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, loramaccommands.o(.text.IsSticky))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsSticky
</UL>
<BR>[Called By]<UL><LI><a href="#[159]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveStickyAnsCmds
<LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsAddCmd
</UL>

<P><STRONG><a name="[154]"></a>IsConfirmationRequired</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, loramaccommands.o(.text.IsConfirmationRequired))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsConfirmationRequired
</UL>
<BR>[Called By]<UL><LI><a href="#[159]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveStickyAnsCmds
<LI><a href="#[150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsAddCmd
</UL>

<P><STRONG><a name="[1b9]"></a>IsSlotFree</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, loramaccommands.o(.text.IsSlotFree))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = IsSlotFree
</UL>
<BR>[Called By]<UL><LI><a href="#[151]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MallocNewMacCommandSlot
</UL>

<P><STRONG><a name="[11d]"></a>LinkedListRemove</STRONG> (Thumb, 118 bytes, Stack size 24 bytes, loramaccommands.o(.text.LinkedListRemove))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = LinkedListRemove &rArr; LinkedListGetPrevious
</UL>
<BR>[Calls]<UL><LI><a href="#[11e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LinkedListGetPrevious
</UL>
<BR>[Called By]<UL><LI><a href="#[157]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveCmd
</UL>

<P><STRONG><a name="[107]"></a>FreeMacCommandSlot</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, loramaccommands.o(.text.FreeMacCommandSlot))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = FreeMacCommandSlot &rArr; memset1
</UL>
<BR>[Calls]<UL><LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[157]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCommandsRemoveCmd
</UL>

<P><STRONG><a name="[11e]"></a>LinkedListGetPrevious</STRONG> (Thumb, 104 bytes, Stack size 20 bytes, loramaccommands.o(.text.LinkedListGetPrevious))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = LinkedListGetPrevious
</UL>
<BR>[Called By]<UL><LI><a href="#[11d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LinkedListRemove
</UL>

<P><STRONG><a name="[15d]"></a>IsListFull</STRONG> (Thumb, 40 bytes, Stack size 4 bytes, loramacconfirmqueue.o(.text.IsListFull))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsListFull
</UL>
<BR>[Called By]<UL><LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueAdd
<LI><a href="#[161]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueIsFull
</UL>

<P><STRONG><a name="[10a]"></a>IncreaseBufferPointer</STRONG> (Thumb, 50 bytes, Stack size 4 bytes, loramacconfirmqueue.o(.text.IncreaseBufferPointer))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IncreaseBufferPointer
</UL>
<BR>[Called By]<UL><LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueRemoveFirst
<LI><a href="#[108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetElement
<LI><a href="#[15c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueAdd
<LI><a href="#[118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueSetStatusCmn
</UL>

<P><STRONG><a name="[109]"></a>IsListEmpty</STRONG> (Thumb, 38 bytes, Stack size 4 bytes, loramacconfirmqueue.o(.text.IsListEmpty))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsListEmpty
</UL>
<BR>[Called By]<UL><LI><a href="#[15f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueRemoveFirst
<LI><a href="#[108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetElement
<LI><a href="#[162]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueSetStatus
<LI><a href="#[118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueSetStatusCmn
</UL>

<P><STRONG><a name="[108]"></a>GetElement</STRONG> (Thumb, 126 bytes, Stack size 32 bytes, loramacconfirmqueue.o(.text.GetElement))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = GetElement &rArr; IsListEmpty
</UL>
<BR>[Calls]<UL><LI><a href="#[109]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsListEmpty
<LI><a href="#[10a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IncreaseBufferPointer
</UL>
<BR>[Called By]<UL><LI><a href="#[162]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueSetStatus
<LI><a href="#[14f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacConfirmQueueIsCmdActive
</UL>

<P><STRONG><a name="[16e]"></a>ResetFCnts</STRONG> (Thumb, 86 bytes, Stack size 4 bytes, loramaccrypto.o(.text.ResetFCnts))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = ResetFCnts
</UL>
<BR>[Called By]<UL><LI><a href="#[16d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoInit
</UL>

<P><STRONG><a name="[c9]"></a>GetLastFcntDown</STRONG> (Thumb, 200 bytes, Stack size 12 bytes, loramaccrypto.o(.text.GetLastFcntDown))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = GetLastFcntDown
</UL>
<BR>[Called By]<UL><LI><a href="#[c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckFCntDown
<LI><a href="#[10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoGetFCntDown
</UL>

<P><STRONG><a name="[de]"></a>DeriveLifeTimeSessionKey</STRONG> (Thumb, 134 bytes, Stack size 40 bytes, loramaccrypto.o(.text.DeriveLifeTimeSessionKey))
<BR><BR>[Stack]<UL><LI>Max Depth = 504<LI>Call Chain = DeriveLifeTimeSessionKey &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementDeriveAndStoreKey
<LI><a href="#[df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpyr
</UL>
<BR>[Called By]<UL><LI><a href="#[16f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoPrepareJoinRequest
</UL>

<P><STRONG><a name="[16b]"></a>IsJoinNonce11xOk</STRONG> (Thumb, 30 bytes, Stack size 4 bytes, loramaccrypto.o(.text.IsJoinNonce11xOk))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsJoinNonce11xOk
</UL>
<BR>[Called By]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
</UL>

<P><STRONG><a name="[16c]"></a>IsJoinNonce10xOk</STRONG> (Thumb, 28 bytes, Stack size 4 bytes, loramaccrypto.o(.text.IsJoinNonce10xOk))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsJoinNonce10xOk
</UL>
<BR>[Called By]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
</UL>

<P><STRONG><a name="[e2]"></a>DeriveSessionKey11x</STRONG> (Thumb, 210 bytes, Stack size 56 bytes, loramaccrypto.o(.text.DeriveSessionKey11x))
<BR><BR>[Stack]<UL><LI>Max Depth = 520<LI>Call Chain = DeriveSessionKey11x &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementDeriveAndStoreKey
<LI><a href="#[df]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpyr
</UL>
<BR>[Called By]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
</UL>

<P><STRONG><a name="[e1]"></a>DeriveSessionKey10x</STRONG> (Thumb, 172 bytes, Stack size 48 bytes, loramaccrypto.o(.text.DeriveSessionKey10x))
<BR><BR>[Stack]<UL><LI>Max Depth = 512<LI>Call Chain = DeriveSessionKey10x &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementDeriveAndStoreKey
</UL>
<BR>[Called By]<UL><LI><a href="#[167]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoHandleJoinAccept
</UL>

<P><STRONG><a name="[176]"></a>PayloadEncrypt</STRONG> (Thumb, 326 bytes, Stack size 80 bytes, loramaccrypto.o(.text.PayloadEncrypt))
<BR><BR>[Stack]<UL><LI>Max Depth = 456<LI>Call Chain = PayloadEncrypt &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementAesEncrypt
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoUnsecureMessage
<LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSecureMessage
</UL>

<P><STRONG><a name="[f8]"></a>FOptsEncrypt</STRONG> (Thumb, 370 bytes, Stack size 64 bytes, loramaccrypto.o(.text.FOptsEncrypt))
<BR><BR>[Stack]<UL><LI>Max Depth = 440<LI>Call Chain = FOptsEncrypt &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementAesEncrypt
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoUnsecureMessage
<LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSecureMessage
</UL>

<P><STRONG><a name="[d7]"></a>ComputeCmacB1</STRONG> (Thumb, 192 bytes, Stack size 72 bytes, loramaccrypto.o(.text.ComputeCmacB1))
<BR><BR>[Stack]<UL><LI>Max Depth = 624<LI>Call Chain = ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementComputeAesCmac
<LI><a href="#[d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareB1
</UL>
<BR>[Called By]<UL><LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSecureMessage
</UL>

<P><STRONG><a name="[d4]"></a>ComputeCmacB0</STRONG> (Thumb, 178 bytes, Stack size 64 bytes, loramaccrypto.o(.text.ComputeCmacB0))
<BR><BR>[Stack]<UL><LI>Max Depth = 616<LI>Call Chain = ComputeCmacB0 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementComputeAesCmac
<LI><a href="#[d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareB0
</UL>
<BR>[Called By]<UL><LI><a href="#[175]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoSecureMessage
</UL>

<P><STRONG><a name="[d8]"></a>PrepareB1</STRONG> (Thumb, 218 bytes, Stack size 20 bytes, loramaccrypto.o(.text.PrepareB1))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = PrepareB1
</UL>
<BR>[Called By]<UL><LI><a href="#[d7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmacB1
</UL>

<P><STRONG><a name="[d5]"></a>PrepareB0</STRONG> (Thumb, 226 bytes, Stack size 12 bytes, loramaccrypto.o(.text.PrepareB0))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = PrepareB0
</UL>
<BR>[Called By]<UL><LI><a href="#[17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VerifyCmacB0
<LI><a href="#[d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmacB0
</UL>

<P><STRONG><a name="[c8]"></a>CheckFCntDown</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, loramaccrypto.o(.text.CheckFCntDown))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = CheckFCntDown &rArr; GetLastFcntDown
</UL>
<BR>[Calls]<UL><LI><a href="#[c9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetLastFcntDown
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoUnsecureMessage
</UL>

<P><STRONG><a name="[166]"></a>GetKeyAddrItem</STRONG> (Thumb, 110 bytes, Stack size 12 bytes, loramaccrypto.o(.text.GetKeyAddrItem))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = GetKeyAddrItem
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoUnsecureMessage
<LI><a href="#[165]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoDeriveMcSessionKeyPair
</UL>

<P><STRONG><a name="[17c]"></a>VerifyCmacB0</STRONG> (Thumb, 226 bytes, Stack size 320 bytes, loramaccrypto.o(.text.VerifyCmacB0))
<BR><BR>[Stack]<UL><LI>Max Depth = 880<LI>Call Chain = VerifyCmacB0 &rArr; SecureElementVerifyAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementVerifyAesCmac
<LI><a href="#[d5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PrepareB0
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
<LI><a href="#[a9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memcpy1
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoUnsecureMessage
</UL>

<P><STRONG><a name="[17d]"></a>UpdateFCntDown</STRONG> (Thumb, 172 bytes, Stack size 12 bytes, loramaccrypto.o(.text.UpdateFCntDown))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = UpdateFCntDown
</UL>
<BR>[Called By]<UL><LI><a href="#[17a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacCryptoUnsecureMessage
</UL>

<P><STRONG><a name="[225]"></a>CountChannels</STRONG> (Thumb, 86 bytes, Stack size 8 bytes, regioncommon.o(.text.CountChannels))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = CountChannels
</UL>
<BR>[Called By]<UL><LI><a href="#[224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonCountChannels
</UL>

<P><STRONG><a name="[22c]"></a>GetDutyCycle</STRONG> (Thumb, 98 bytes, Stack size 24 bytes, regioncommon.o(.text.GetDutyCycle))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = GetDutyCycle
</UL>
<BR>[Called By]<UL><LI><a href="#[28d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMaxTimeCredits
<LI><a href="#[22b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonSetBandTxDone
</UL>

<P><STRONG><a name="[22d]"></a>UpdateTimeCredits</STRONG> (Thumb, 226 bytes, Stack size 40 bytes, regioncommon.o(.text.UpdateTimeCredits))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = UpdateTimeCredits &rArr; SetMaxTimeCredits &rArr; GetDutyCycle
</UL>
<BR>[Calls]<UL><LI><a href="#[28d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMaxTimeCredits
</UL>
<BR>[Called By]<UL><LI><a href="#[229]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonUpdateBandTimeOff
</UL>

<P><STRONG><a name="[28d]"></a>SetMaxTimeCredits</STRONG> (Thumb, 184 bytes, Stack size 32 bytes, regioncommon.o(.text.SetMaxTimeCredits))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = SetMaxTimeCredits &rArr; GetDutyCycle
</UL>
<BR>[Calls]<UL><LI><a href="#[22c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetDutyCycle
</UL>
<BR>[Called By]<UL><LI><a href="#[22d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateTimeCredits
</UL>

<P><STRONG><a name="[233]"></a>VerifyRfFreq</STRONG> (Thumb, 308 bytes, Stack size 24 bytes, regioneu868.o(.text.VerifyRfFreq))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = VerifyRfFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868ChannelAdd
<LI><a href="#[22f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868DlChannelReq
<LI><a href="#[23e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868RxParamSetupReq
<LI><a href="#[242]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868Verify
</UL>

<P><STRONG><a name="[10f]"></a>GetTimeOnAir</STRONG> (Thumb, 182 bytes, Stack size 40 bytes, regioneu868.o(.text.GetTimeOnAir))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = GetTimeOnAir &rArr; RegionCommonGetBandwidth
</UL>
<BR>[Calls]<UL><LI><a href="#[110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionCommonGetBandwidth
</UL>
<BR>[Called By]<UL><LI><a href="#[23d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868NextChannel
<LI><a href="#[240]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RegionEU868TxConfig
</UL>

<P><STRONG><a name="[2b5]"></a>copy_block_nn</STRONG> (Thumb, 48 bytes, Stack size 12 bytes, aes.o(.text.copy_block_nn))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = copy_block_nn
</UL>
<BR>[Called By]<UL><LI><a href="#[ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_set_key
</UL>

<P><STRONG><a name="[2b2]"></a>copy_and_key</STRONG> (Thumb, 236 bytes, Stack size 12 bytes, aes.o(.text.copy_and_key))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = copy_and_key
</UL>
<BR>[Called By]<UL><LI><a href="#[a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_encrypt
</UL>

<P><STRONG><a name="[2b3]"></a>mix_sub_columns</STRONG> (Thumb, 772 bytes, Stack size 32 bytes, aes.o(.text.mix_sub_columns))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[323]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;copy_block
</UL>
<BR>[Called By]<UL><LI><a href="#[a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_encrypt
</UL>

<P><STRONG><a name="[2b0]"></a>add_round_key</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, aes.o(.text.add_round_key))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = add_round_key &rArr; xor_block
</UL>
<BR>[Calls]<UL><LI><a href="#[2b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;xor_block
</UL>
<BR>[Called By]<UL><LI><a href="#[a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_encrypt
</UL>

<P><STRONG><a name="[2b4]"></a>shift_sub_rows</STRONG> (Thumb, 184 bytes, Stack size 8 bytes, aes.o(.text.shift_sub_rows))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = shift_sub_rows
</UL>
<BR>[Called By]<UL><LI><a href="#[a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;aes_encrypt
</UL>

<P><STRONG><a name="[323]"></a>copy_block</STRONG> (Thumb, 138 bytes, Stack size 8 bytes, aes.o(.text.copy_block))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = copy_block
</UL>
<BR>[Called By]<UL><LI><a href="#[2b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mix_sub_columns
</UL>

<P><STRONG><a name="[2b1]"></a>xor_block</STRONG> (Thumb, 202 bytes, Stack size 8 bytes, aes.o(.text.xor_block))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = xor_block
</UL>
<BR>[Called By]<UL><LI><a href="#[2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;add_round_key
</UL>

<P><STRONG><a name="[d3]"></a>GetKeyByID</STRONG> (Thumb, 122 bytes, Stack size 12 bytes, soft-se.o(.text.GetKeyByID))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = GetKeyByID
</UL>
<BR>[Called By]<UL><LI><a href="#[f9]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementAesEncrypt
<LI><a href="#[d2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ComputeCmac
</UL>

<P><STRONG><a name="[d2]"></a>ComputeCmac</STRONG> (Thumb, 148 bytes, Stack size 336 bytes, soft-se.o(.text.ComputeCmac))
<BR><BR>[Stack]<UL><LI>Max Depth = 520<LI>Call Chain = ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[d3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetKeyByID
<LI><a href="#[a6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_Final
<LI><a href="#[ad]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_Update
<LI><a href="#[ab]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_SetKey
<LI><a href="#[aa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AES_CMAC_Init
</UL>
<BR>[Called By]<UL><LI><a href="#[286]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementVerifyAesCmac
<LI><a href="#[d6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SecureElementComputeAesCmac
</UL>

<P><STRONG><a name="[20e]"></a>RadioGetFskBandwidthRegValue</STRONG> (Thumb, 136 bytes, Stack size 12 bytes, radio.o(.text.RadioGetFskBandwidthRegValue))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = RadioGetFskBandwidthRegValue
</UL>
<BR>[Called By]<UL><LI><a href="#[77]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetTxConfig
<LI><a href="#[76]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioSetRxConfig
</UL>

<P><STRONG><a name="[218]"></a>RadioGetGfskTimeOnAirNumerator</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, radio.o(.text.RadioGetGfskTimeOnAirNumerator))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = RadioGetGfskTimeOnAirNumerator
</UL>
<BR>[Called By]<UL><LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTimeOnAir
</UL>

<P><STRONG><a name="[219]"></a>RadioGetLoRaTimeOnAirNumerator</STRONG> (Thumb, 320 bytes, Stack size 52 bytes, radio.o(.text.RadioGetLoRaTimeOnAirNumerator))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = RadioGetLoRaTimeOnAirNumerator
</UL>
<BR>[Called By]<UL><LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTimeOnAir
</UL>

<P><STRONG><a name="[21a]"></a>RadioGetLoRaBandwidthInHz</STRONG> (Thumb, 138 bytes, Stack size 12 bytes, radio.o(.text.RadioGetLoRaBandwidthInHz))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = RadioGetLoRaBandwidthInHz
</UL>
<BR>[Called By]<UL><LI><a href="#[79]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioTimeOnAir
</UL>

<P><STRONG><a name="[27c]"></a>SX126xConvertFreqInHzToPllStep</STRONG> (Thumb, 62 bytes, Stack size 12 bytes, sx126x.o(.text.SX126xConvertFreqInHzToPllStep))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = SX126xConvertFreqInHzToPllStep
</UL>
<BR>[Called By]<UL><LI><a href="#[20f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetModulationParams
<LI><a href="#[20b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SX126xSetRfFrequency
</UL>

<P><STRONG><a name="[2a1]"></a>TimerExists</STRONG> (Thumb, 66 bytes, Stack size 12 bytes, timer.o(.text.TimerExists))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = TimerExists
</UL>
<BR>[Called By]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
</UL>

<P><STRONG><a name="[29c]"></a>TimerInsertNewHeadTimer</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, timer.o(.text.TimerInsertNewHeadTimer))
<BR><BR>[Stack]<UL><LI>Max Depth = 204<LI>Call Chain = TimerInsertNewHeadTimer &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[29d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetTimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
</UL>

<P><STRONG><a name="[2a2]"></a>TimerInsertTimer</STRONG> (Thumb, 92 bytes, Stack size 12 bytes, timer.o(.text.TimerInsertTimer))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = TimerInsertTimer
</UL>
<BR>[Called By]<UL><LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
</UL>

<P><STRONG><a name="[29d]"></a>TimerSetTimeout</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, timer.o(.text.TimerSetTimeout))
<BR><BR>[Stack]<UL><LI>Max Depth = 188<LI>Call Chain = TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[24b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetTimerElapsedTime
<LI><a href="#[255]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcSetAlarm
<LI><a href="#[2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RtcGetMinimumTimeout
</UL>
<BR>[Called By]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
<LI><a href="#[29e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerIrqHandler
<LI><a href="#[29c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInsertNewHeadTimer
</UL>

<P><STRONG><a name="[54]"></a>McpsConfirm</STRONG> (Thumb, 110 bytes, Stack size 16 bytes, lmhandler.o(.text.McpsConfirm))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = McpsConfirm &rArr; LmHandlerPackagesNotify
</UL>
<BR>[Calls]<UL><LI><a href="#[1ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackagesNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhandler.o(.text.LmHandlerInit)
</UL>
<P><STRONG><a name="[55]"></a>McpsIndication</STRONG> (Thumb, 216 bytes, Stack size 24 bytes, lmhandler.o(.text.McpsIndication))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = McpsIndication &rArr; LmHandlerPackagesNotify
</UL>
<BR>[Calls]<UL><LI><a href="#[1ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackagesNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhandler.o(.text.LmHandlerInit)
</UL>
<P><STRONG><a name="[56]"></a>MlmeConfirm</STRONG> (Thumb, 356 bytes, Stack size 112 bytes, lmhandler.o(.text.MlmeConfirm))
<BR><BR>[Stack]<UL><LI>Max Depth = 1184 + Unknown Stack Size
<LI>Call Chain = MlmeConfirm &rArr; LmHandlerPingSlotReq &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[5a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerDeviceTimeReq
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[134]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPingSlotReq
<LI><a href="#[121]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerGetCurrentDatarate
<LI><a href="#[13a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnClassChangeNotify
<LI><a href="#[11f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerBeaconReq
<LI><a href="#[1ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackagesNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhandler.o(.text.LmHandlerInit)
</UL>
<P><STRONG><a name="[57]"></a>MlmeIndication</STRONG> (Thumb, 304 bytes, Stack size 80 bytes, lmhandler.o(.text.MlmeIndication))
<BR><BR>[Stack]<UL><LI>Max Depth = 1064 + Unknown Stack Size
<LI>Call Chain = MlmeIndication &rArr; LmHandlerDeviceTimeReq &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[5a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerDeviceTimeReq
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
<LI><a href="#[1bb]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnBeaconStatusChangeNotify
<LI><a href="#[13a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OnClassChangeNotify
<LI><a href="#[1ba]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackagesNotify
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhandler.o(.text.LmHandlerInit)
</UL>
<P><STRONG><a name="[1ba]"></a>LmHandlerPackagesNotify</STRONG> (Thumb, 286 bytes, Stack size 24 bytes, lmhandler.o(.text.LmHandlerPackagesNotify))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = LmHandlerPackagesNotify
</UL>
<BR>[Called By]<UL><LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeIndication
<LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeConfirm
<LI><a href="#[55]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;McpsIndication
<LI><a href="#[54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;McpsConfirm
</UL>

<P><STRONG><a name="[11f]"></a>LmHandlerBeaconReq</STRONG> (Thumb, 104 bytes, Stack size 32 bytes, lmhandler.o(.text.LmHandlerBeaconReq))
<BR><BR>[Stack]<UL><LI>Max Depth = 984 + Unknown Stack Size
<LI>Call Chain = LmHandlerBeaconReq &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>
<BR>[Called By]<UL><LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeConfirm
</UL>

<P><STRONG><a name="[13a]"></a>OnClassChangeNotify</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, lmhandler.o(.text.OnClassChangeNotify))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = OnClassChangeNotify
</UL>
<BR>[Called By]<UL><LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerRequestClass
<LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeIndication
<LI><a href="#[56]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeConfirm
</UL>

<P><STRONG><a name="[1bb]"></a>OnBeaconStatusChangeNotify</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, lmhandler.o(.text.OnBeaconStatusChangeNotify))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = OnBeaconStatusChangeNotify
</UL>
<BR>[Called By]<UL><LI><a href="#[57]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MlmeIndication
</UL>

<P><STRONG><a name="[12c]"></a>LmHandlerPackageIsTxPending</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, lmhandler.o(.text.LmHandlerPackageIsTxPending))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = LmHandlerPackageIsTxPending
</UL>
<BR>[Called By]<UL><LI><a href="#[128]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerIsBusy
<LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerProcess
</UL>

<P><STRONG><a name="[59]"></a>LmHandlerJoinRequest</STRONG> (Thumb, 146 bytes, Stack size 40 bytes, lmhandler.o(.text.LmHandlerJoinRequest))
<BR><BR>[Stack]<UL><LI>Max Depth = 992 + Unknown Stack Size
<LI>Call Chain = LmHandlerJoinRequest &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>
<BR>[Called By]<UL><LI><a href="#[12b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerJoin
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhandler.o(.text.LmHandlerPackageRegister)
</UL>
<P><STRONG><a name="[132]"></a>LmHandlerPackagesProcess</STRONG> (Thumb, 116 bytes, Stack size 16 bytes, lmhandler.o(.text.LmHandlerPackagesProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = LmHandlerPackagesProcess &rArr; LmHandlerPackageIsInitialized
</UL>
<BR>[Calls]<UL><LI><a href="#[133]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerPackageIsInitialized
</UL>
<BR>[Called By]<UL><LI><a href="#[136]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerProcess
</UL>

<P><STRONG><a name="[fb]"></a>SetRow</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, fragdecoder.o(.text.SetRow))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = SetRow
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[fc]"></a>FragFindMissingFrags</STRONG> (Thumb, 154 bytes, Stack size 8 bytes, fragdecoder.o(.text.FragFindMissingFrags))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = FragFindMissingFrags
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[fd]"></a>FragGetParityMatrixRow</STRONG> (Thumb, 172 bytes, Stack size 40 bytes, fragdecoder.o(.text.FragGetParityMatrixRow))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = FragGetParityMatrixRow &rArr; FragPrbs23
</UL>
<BR>[Calls]<UL><LI><a href="#[106]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragPrbs23
<LI><a href="#[105]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsPowerOfTwo
<LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetParity
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[b4]"></a>GetParity</STRONG> (Thumb, 52 bytes, Stack size 12 bytes, fragdecoder.o(.text.GetParity))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = GetParity
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
<LI><a href="#[104]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragPushLineToBinaryMatrix
<LI><a href="#[b5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BitArrayIsAllZeros
<LI><a href="#[102]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XorParityLine
<LI><a href="#[b3]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BitArrayFindFirstOne
</UL>

<P><STRONG><a name="[fe]"></a>SetParity</STRONG> (Thumb, 76 bytes, Stack size 12 bytes, fragdecoder.o(.text.SetParity))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = SetParity
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
<LI><a href="#[102]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;XorParityLine
<LI><a href="#[101]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragExtractLineFromBinaryMatrix
<LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragGetParityMatrixRow
</UL>

<P><STRONG><a name="[ff]"></a>GetRow</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, fragdecoder.o(.text.GetRow))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = GetRow
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[100]"></a>XorDataLine</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, fragdecoder.o(.text.XorDataLine))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = XorDataLine
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[b3]"></a>BitArrayFindFirstOne</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, fragdecoder.o(.text.BitArrayFindFirstOne))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = BitArrayFindFirstOne &rArr; GetParity
</UL>
<BR>[Calls]<UL><LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetParity
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[101]"></a>FragExtractLineFromBinaryMatrix</STRONG> (Thumb, 250 bytes, Stack size 32 bytes, fragdecoder.o(.text.FragExtractLineFromBinaryMatrix))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = FragExtractLineFromBinaryMatrix &rArr; SetParity
</UL>
<BR>[Calls]<UL><LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetParity
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[102]"></a>XorParityLine</STRONG> (Thumb, 80 bytes, Stack size 40 bytes, fragdecoder.o(.text.XorParityLine))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = XorParityLine &rArr; SetParity
</UL>
<BR>[Calls]<UL><LI><a href="#[fe]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetParity
<LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetParity
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[103]"></a>FragFindMissingIndex</STRONG> (Thumb, 104 bytes, Stack size 8 bytes, fragdecoder.o(.text.FragFindMissingIndex))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = FragFindMissingIndex
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[b5]"></a>BitArrayIsAllZeros</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, fragdecoder.o(.text.BitArrayIsAllZeros))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = BitArrayIsAllZeros &rArr; GetParity
</UL>
<BR>[Calls]<UL><LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetParity
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[104]"></a>FragPushLineToBinaryMatrix</STRONG> (Thumb, 202 bytes, Stack size 32 bytes, fragdecoder.o(.text.FragPushLineToBinaryMatrix))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = FragPushLineToBinaryMatrix &rArr; GetParity
</UL>
<BR>[Calls]<UL><LI><a href="#[b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetParity
</UL>
<BR>[Called By]<UL><LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
</UL>

<P><STRONG><a name="[105]"></a>IsPowerOfTwo</STRONG> (Thumb, 100 bytes, Stack size 12 bytes, fragdecoder.o(.text.IsPowerOfTwo))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = IsPowerOfTwo
</UL>
<BR>[Called By]<UL><LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragGetParityMatrixRow
</UL>

<P><STRONG><a name="[106]"></a>FragPrbs23</STRONG> (Thumb, 38 bytes, Stack size 12 bytes, fragdecoder.o(.text.FragPrbs23))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = FragPrbs23
</UL>
<BR>[Called By]<UL><LI><a href="#[fd]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragGetParityMatrixRow
</UL>

<P><STRONG><a name="[14]"></a>LmhpClockSyncInit</STRONG> (Thumb, 70 bytes, Stack size 12 bytes, lmhpclocksync.o(.text.LmhpClockSyncInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = LmhpClockSyncInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpclocksync.o(.data.LmhpClockSyncPackage)
</UL>
<P><STRONG><a name="[15]"></a>LmhpClockSyncIsInitialized</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, lmhpclocksync.o(.text.LmhpClockSyncIsInitialized))
<BR>[Address Reference Count : 1]<UL><LI> lmhpclocksync.o(.data.LmhpClockSyncPackage)
</UL>
<P><STRONG><a name="[16]"></a>LmhpClockSyncIsTxPending</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, lmhpclocksync.o(.text.LmhpClockSyncIsTxPending))
<BR>[Address Reference Count : 1]<UL><LI> lmhpclocksync.o(.data.LmhpClockSyncPackage)
</UL>
<P><STRONG><a name="[17]"></a>LmhpClockSyncProcess</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, lmhpclocksync.o(.text.LmhpClockSyncProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 1128 + Unknown Stack Size
<LI>Call Chain = LmhpClockSyncProcess &rArr; LmhpClockSyncAppTimeReq &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[13e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpClockSyncAppTimeReq
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpclocksync.o(.data.LmhpClockSyncPackage)
</UL>
<P><STRONG><a name="[18]"></a>LmhpClockSyncOnMcpsConfirm</STRONG> (Thumb, 108 bytes, Stack size 64 bytes, lmhpclocksync.o(.text.LmhpClockSyncOnMcpsConfirm))
<BR><BR>[Stack]<UL><LI>Max Depth = 640<LI>Call Chain = LmhpClockSyncOnMcpsConfirm &rArr; LoRaMacMibSetRequestConfirm &rArr; LoRaMacCryptoSetKey &rArr; LoRaMacCryptoDeriveMcKEKey &rArr; SecureElementDeriveAndStoreKey &rArr; SecureElementSetKey &rArr; SecureElementAesEncrypt &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpclocksync.o(.data.LmhpClockSyncPackage)
</UL>
<P><STRONG><a name="[19]"></a>LmhpClockSyncOnMcpsIndication</STRONG> (Thumb, 676 bytes, Stack size 72 bytes, lmhpclocksync.o(.text.LmhpClockSyncOnMcpsIndication))
<BR><BR>[Stack]<UL><LI>Max Depth = 1104 + Unknown Stack Size
<LI>Call Chain = LmhpClockSyncOnMcpsIndication &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGet
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
<LI><a href="#[140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeSet
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpclocksync.o(.data.LmhpClockSyncPackage)
</UL>
<P><STRONG><a name="[0]"></a>LmhpComplianceInit</STRONG> (Thumb, 124 bytes, Stack size 32 bytes, lmhpcompliance.o(.text.LmhpComplianceInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = LmhpComplianceInit &rArr; ClassBStatusReset &rArr; memset1
</UL>
<BR>[Calls]<UL><LI><a href="#[d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ClassBStatusReset
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpcompliance.o(.data.CompliancePackage)
</UL>
<P><STRONG><a name="[d1]"></a>ClassBStatusReset</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, lmhpcompliance.o(.text.ClassBStatusReset))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ClassBStatusReset &rArr; memset1
</UL>
<BR>[Calls]<UL><LI><a href="#[a7]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;memset1
</UL>
<BR>[Called By]<UL><LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceOnMlmeIndication
<LI><a href="#[5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceOnMlmeConfirm
<LI><a href="#[0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceInit
</UL>

<P><STRONG><a name="[1]"></a>LmhpComplianceIsInitialized</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, lmhpcompliance.o(.text.LmhpComplianceIsInitialized))
<BR>[Address Reference Count : 1]<UL><LI> lmhpcompliance.o(.data.CompliancePackage)
</UL>
<P><STRONG><a name="[2]"></a>LmhpComplianceIsTxPending</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, lmhpcompliance.o(.text.LmhpComplianceIsTxPending))
<BR>[Address Reference Count : 1]<UL><LI> lmhpcompliance.o(.data.CompliancePackage)
</UL>
<P><STRONG><a name="[3]"></a>LmhpComplianceProcess</STRONG> (Thumb, 244 bytes, Stack size 32 bytes, lmhpcompliance.o(.text.LmhpComplianceProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 1080 + Unknown Stack Size
<LI>Call Chain = LmhpComplianceProcess &rArr; LmHandlerRequestClass &rArr; LmHandlerDeviceTimeReq &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerRequestClass
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
<LI><a href="#[142]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerGetCurrentTime
<LI><a href="#[c5]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardResetMcu
<LI><a href="#[143]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerGetDutyCycleWaitTime
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpcompliance.o(.data.CompliancePackage)
</UL>
<P><STRONG><a name="[4]"></a>LmhpComplianceOnMcpsIndication</STRONG> (Thumb, 1796 bytes, Stack size 280 bytes, lmhpcompliance.o(.text.LmhpComplianceOnMcpsIndication))
<BR><BR>[Stack]<UL><LI>Max Depth = 1232 + Unknown Stack Size
<LI>Call Chain = LmhpComplianceOnMcpsIndication &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[126]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacTestSetDutyCycleOn
<LI><a href="#[125]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibSetRequestConfirm
<LI><a href="#[f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMibGetRequestConfirm
<LI><a href="#[120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMlmeRequest
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpcompliance.o(.data.CompliancePackage)
</UL>
<P><STRONG><a name="[5]"></a>LmhpComplianceOnMlmeConfirm</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, lmhpcompliance.o(.text.LmhpComplianceOnMlmeConfirm))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = LmhpComplianceOnMlmeConfirm &rArr; ClassBStatusReset &rArr; memset1
</UL>
<BR>[Calls]<UL><LI><a href="#[d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ClassBStatusReset
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpcompliance.o(.data.CompliancePackage)
</UL>
<P><STRONG><a name="[6]"></a>LmhpComplianceOnMlmeIndication</STRONG> (Thumb, 192 bytes, Stack size 32 bytes, lmhpcompliance.o(.text.LmhpComplianceOnMlmeIndication))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = LmhpComplianceOnMlmeIndication &rArr; ClassBStatusReset &rArr; memset1
</UL>
<BR>[Calls]<UL><LI><a href="#[141]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendBeaconRxStatusInd
<LI><a href="#[d1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ClassBStatusReset
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpcompliance.o(.data.CompliancePackage)
</UL>
<P><STRONG><a name="[141]"></a>SendBeaconRxStatusInd</STRONG> (Thumb, 458 bytes, Stack size 12 bytes, lmhpcompliance.o(.text.SendBeaconRxStatusInd))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = SendBeaconRxStatusInd
</UL>
<BR>[Called By]<UL><LI><a href="#[6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmhpComplianceOnMlmeIndication
</UL>

<P><STRONG><a name="[1d]"></a>LmhpFragmentationInit</STRONG> (Thumb, 132 bytes, Stack size 24 bytes, lmhpfragmentation.o(.text.LmhpFragmentationInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = LmhpFragmentationInit &rArr; TimerInit
</UL>
<BR>[Calls]<UL><LI><a href="#[af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpfragmentation.o(.data.LmhpFragmentationPackage)
</UL>
<P><STRONG><a name="[5b]"></a>OnFragmentTxDelay</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, lmhpfragmentation.o(.text.OnFragmentTxDelay))
<BR><BR>[Stack]<UL><LI>Max Depth = 228<LI>Call Chain = OnFragmentTxDelay &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpfragmentation.o(.text.LmhpFragmentationInit)
</UL>
<P><STRONG><a name="[1e]"></a>LmhpFragmentationIsInitialized</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, lmhpfragmentation.o(.text.LmhpFragmentationIsInitialized))
<BR>[Address Reference Count : 1]<UL><LI> lmhpfragmentation.o(.data.LmhpFragmentationPackage)
</UL>
<P><STRONG><a name="[1f]"></a>LmhpFragmentationIsTxPending</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, lmhpfragmentation.o(.text.LmhpFragmentationIsTxPending))
<BR>[Address Reference Count : 1]<UL><LI> lmhpfragmentation.o(.data.LmhpFragmentationPackage)
</UL>
<P><STRONG><a name="[20]"></a>LmhpFragmentationProcess</STRONG> (Thumb, 120 bytes, Stack size 32 bytes, lmhpfragmentation.o(.text.LmhpFragmentationProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 1064 + Unknown Stack Size
<LI>Call Chain = LmhpFragmentationProcess &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpfragmentation.o(.data.LmhpFragmentationPackage)
</UL>
<P><STRONG><a name="[21]"></a>LmhpFragmentationOnMcpsIndication</STRONG> (Thumb, 1784 bytes, Stack size 104 bytes, lmhpfragmentation.o(.text.LmhpFragmentationOnMcpsIndication))
<BR><BR>[Stack]<UL><LI>Max Depth = 1136 + Unknown Stack Size
<LI>Call Chain = LmhpFragmentationOnMcpsIndication &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
<LI><a href="#[147]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;randr
<LI><a href="#[144]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderGetStatus
<LI><a href="#[fa]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderProcess
<LI><a href="#[145]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderGetMaxFileSize
<LI><a href="#[146]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FragDecoderInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpfragmentation.o(.data.LmhpFragmentationPackage)
</UL>
<P><STRONG><a name="[22]"></a>LmhpRemoteMcastSetupInit</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupInit))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = LmhpRemoteMcastSetupInit &rArr; TimerInit
</UL>
<BR>[Calls]<UL><LI><a href="#[af]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
</UL>
<P><STRONG><a name="[5c]"></a>OnSessionStartTimer</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, lmhpremotemcastsetup.o(.text.OnSessionStartTimer))
<BR><BR>[Stack]<UL><LI>Max Depth = 228<LI>Call Chain = OnSessionStartTimer &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupInit)
</UL>
<P><STRONG><a name="[5d]"></a>OnSessionStopTimer</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, lmhpremotemcastsetup.o(.text.OnSessionStopTimer))
<BR><BR>[Stack]<UL><LI>Max Depth = 228<LI>Call Chain = OnSessionStopTimer &rArr; TimerStop &rArr; TimerSetTimeout &rArr; RtcSetAlarm &rArr; RtcStartAlarm &rArr; RtcSetTimerContext &rArr; RtcGetCalendarValue &rArr; am_hal_rtc_time_get &rArr; bcd_to_dec
</UL>
<BR>[Calls]<UL><LI><a href="#[b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStop
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupInit)
</UL>
<P><STRONG><a name="[23]"></a>LmhpRemoteMcastSetupIsInitialized</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupIsInitialized))
<BR>[Address Reference Count : 1]<UL><LI> lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
</UL>
<P><STRONG><a name="[24]"></a>LmhpRemoteMcastSetupIsTxPending</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupIsTxPending))
<BR>[Address Reference Count : 1]<UL><LI> lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
</UL>
<P><STRONG><a name="[25]"></a>LmhpRemoteMcastSetupProcess</STRONG> (Thumb, 130 bytes, Stack size 32 bytes, lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupProcess))
<BR><BR>[Stack]<UL><LI>Max Depth = 1080 + Unknown Stack Size
<LI>Call Chain = LmhpRemoteMcastSetupProcess &rArr; LmHandlerRequestClass &rArr; LmHandlerDeviceTimeReq &rArr; LoRaMacMlmeRequest &rArr; SendReJoinReq &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[139]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerRequestClass
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionEnd
<LI><a href="#[c6]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BoardCriticalSectionBegin
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
</UL>
<P><STRONG><a name="[26]"></a>LmhpRemoteMcastSetupOnMcpsIndication</STRONG> (Thumb, 2518 bytes, Stack size 144 bytes, lmhpremotemcastsetup.o(.text.LmhpRemoteMcastSetupOnMcpsIndication))
<BR><BR>[Stack]<UL><LI>Max Depth = 1176 + Unknown Stack Size
<LI>Call Chain = LmhpRemoteMcastSetupOnMcpsIndication &rArr; LmHandlerSend &rArr; LoRaMacMcpsRequest &rArr; Send &rArr; ScheduleTx &rArr; SendFrameOnChannel &rArr; SecureFrame &rArr; LoRaMacCryptoSecureMessage &rArr; ComputeCmacB1 &rArr; SecureElementComputeAesCmac &rArr; ComputeCmac &rArr; AES_CMAC_Final &rArr; aes_encrypt &rArr; mix_sub_columns &rArr; copy_block
</UL>
<BR>[Calls]<UL><LI><a href="#[13f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SysTimeGet
<LI><a href="#[135]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LmHandlerSend
<LI><a href="#[b2]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerStart
<LI><a href="#[b1]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TimerSetValue
<LI><a href="#[14b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcChannelSetupRxParams
<LI><a href="#[14a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcChannelDelete
<LI><a href="#[149]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoRaMacMcChannelSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lmhpremotemcastsetup.o(.data.LmhpRemoteMcastSetupPackage)
</UL>
<P><STRONG><a name="[a1]"></a>_tm_carry</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, mktime.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _tm_carry
</UL>
<BR>[Called By]<UL><LI><a href="#[a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;mktime
</UL>

<P><STRONG><a name="[33c]"></a>_dadd1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, daddsub_clz.o(x$fpl$dadd), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[33d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub
<LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_drsb
</UL>

<P><STRONG><a name="[332]"></a>_dsub1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, daddsub_clz.o(x$fpl$dsub), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[33b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_drsb
<LI><a href="#[331]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd
</UL>
<P>
<H3>
Undefined Global Symbols
</H3><HR></body></html>
